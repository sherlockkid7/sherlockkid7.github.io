<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="rgba(10,10,10,.7)"><meta name="description" content=""><meta name="author" content="tq"><meta name="keywords" content=""><title>前端面试——Vue篇 - TQ个人博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>TQ个人博客</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-07-14 10:08">2020年7月14日 上午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 3.3k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 35 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><h4 id="1-单页应用（SPA）的理解，及优缺点"><a href="#1-单页应用（SPA）的理解，及优缺点" class="headerlink" title="1.单页应用（SPA）的理解，及优缺点"></a>1.单页应用（SPA）的理解，及优缺点</h4><p>通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css，有时候考虑到首屏加载太慢会按需加载。利用路由机制（js）实现 HTML 内容的变换</p><p>优点：</p><p>1、用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。基于这一点spa对服务器压力较小</p><p>2、前后端分离，前端进行交互逻辑，后端负责数据处理</p><p>3、页面效果会比较炫酷（比如切换页面内容时的专场动画）</p><p>缺点：</p><p>1、初次加载时耗时多（可用路由懒加载解决）</p><p>2、前进后退功能路由管理（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</p><p>3、不利于seo(所有的内容都在一个页面中动态替换显示)</p><h4 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2.MVVM"></a>2.MVVM</h4><p>MVVM由View、ViewModel、Model三部分组成</p><ul><li>View（视图层）：可以简单的理解为DOM层。主要用于给用户展示各种信息</li><li>ViewModel（视图模型层）：是Model和View之间的通信桥梁。</li><li>Model（模型/数据层）：负责处理业务逻辑以及和服务器端进行交互</li></ul><p>在MVVM的架构下，<strong>View层和Model层并没有直接联系，而是通过ViewModel层进行交互。</strong> 一方面它实现了数据绑定，将Model的改变实时的反应到View中；另一方面它实现了DOM监听，当DOM发生一些事件(点击、滚动、touch等)时可以监听到，并在需要的情况下改变对应的Data ，因此开发者只需关注业务逻辑，无需手动操作DOM</p><h4 id="3-Vue-是如何实现数据双向绑定的（响应式原理）"><a href="#3-Vue-是如何实现数据双向绑定的（响应式原理）" class="headerlink" title="3.Vue 是如何实现数据双向绑定的（响应式原理）"></a>3.Vue 是如何实现数据双向绑定的（响应式原理）</h4><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p><p>采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter、getter，在数据变化时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><ol><li>实现一个监听器 Observer，对数据对象进行递归遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter<br>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li><li>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，<strong>通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/2020071415034244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="4-v-show-与-v-if-有什么区别"><a href="#4-v-show-与-v-if-有什么区别" class="headerlink" title="4.v-show 与 v-if 有什么区别"></a>4.v-show 与 v-if 有什么区别</h4><p>v-if和v-show都是用来<strong>控制元素/组件的渲染</strong>。<strong>v-if</strong> 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<strong>v-show</strong> 不管初始条件是什么，元素总是会被渲染，通过设置DOM元素的display样式属性控制显隐</p><p>适用场景：如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，不需要频繁切换条件，则使用 v-if 较好。</p><h4 id="5-watch、methods-和-computed-的区别"><a href="#5-watch、methods-和-computed-的区别" class="headerlink" title="5.watch、methods 和 computed 的区别"></a>5.watch、methods 和 computed 的区别</h4><p><strong>watch</strong> 为了监听某个<strong>响应数据</strong>的变化。</p><p><strong>computed</strong> 是<strong>计算属性</strong>，依赖其它属性值，自动<strong>监听依赖值</strong>的变化，从而<strong>动态返回内容</strong>。computed 是可以缓存的，也就是说computed中的依赖项没有变化，computed中的值就不会重新计算</p><p><strong>methods</strong>是一个方法，它可以接受参数，用于<strong>存储监听事件回调函数</strong></p><p>运用场景：</p><ul><li><p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算</p></li><li><p>需要在某个数据变化时做一些事情，才用 watch。</p></li><li><p>methods没有缓存，所以每次访问都要重新执行。当不需要缓存功能，就使用methods</p></li></ul><h4 id="6-Vue单向数据流（有点难以理解）"><a href="#6-Vue单向数据流（有点难以理解）" class="headerlink" title="6.Vue单向数据流（有点难以理解）"></a>6.Vue单向数据流（有点难以理解）</h4><p>Vue 中，父子组件之间，prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解</p><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告</p><p>通常有两种改变 prop 的情况：</p><ol><li>prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；</li><li>prop 作为需要被转变的原始值传入。（定义一个 computed 属性，此属性从 prop 的值计算得出。）</li></ol><p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间。所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</p><h4 id="7-Vue-生命周期"><a href="#7-Vue-生命周期" class="headerlink" title="7.Vue 生命周期"></a>7.Vue 生命周期</h4><p>Vue 实例从创建到销毁的过程，主要包括四个阶段：创建、挂载、更新、销毁</p><p><strong>beforeCreate（创建前）</strong></p><p><strong>created（创建后）</strong></p><p><strong>beforeMount（挂载前）</strong></p><p><strong>mounted（挂载后）</strong></p><p><strong>beforeUpdate（更新前）</strong></p><p><strong>updated（更新后）</strong></p><p><strong>beforeDestroy（销毁前）</strong></p><p><strong>destroyed（销毁后）</strong></p><p><strong>activited</strong>：keep-alive 专属，组件被激活时调用<br><strong>deactivated</strong>：keep-alive 专属，组件被销毁时调用</p><p>平时比较常用的是created和mounted。</p><p>created 钩子函数中调用异步请求,获取后台数据</p><p>mounted钩子函数中通过插件操作页面的DOM节点</p><h4 id="8-keep-alive-组件的理解"><a href="#8-keep-alive-组件的理解" class="headerlink" title="8.keep-alive 组件的理解"></a>8.keep-alive 组件的理解</h4><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><p>适用场景：</p><p>有两个页面，商品列表和商品详情页面，一般我们会经常执行打开详情=&gt;返回列表=&gt;打开详情这样的操作，那么就可以对列表组件使用keep-alive组件进行缓存，这样每次返回列表的时候，都是从缓存中快速渲染，而不是重新渲染</p><h4 id="9-组件中-data-为什么必须是一个函数？"><a href="#9-组件中-data-为什么必须是一个函数？" class="headerlink" title="9.组件中 data 为什么必须是一个函数？"></a>9.组件中 data 为什么必须是一个函数？</h4><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例；而采用函数形式定义，那么每个组件实例会返回一个全新的data对象，组件实例之间的 data 属性值不会互相影响。而在Vue根实例创建过程中则不存在该限制，因为根实例只能有一个，不需要担心这种情况</p><h4 id="10-v-model-的原理"><a href="#10-v-model-的原理" class="headerlink" title="10.v-model 的原理"></a>10.v-model 的原理</h4><p>实现表单元素和数据的双向绑定<br>v-model其实是一个语法糖，它本质上是包含两个操作：<br>1.v-bind绑定一个value属性<br>2.v-on指令给当前元素绑定input事件</p><h4 id="11-Vue-组件间通信"><a href="#11-Vue-组件间通信" class="headerlink" title="11.Vue 组件间通信"></a>11.Vue 组件间通信</h4><ul><li><h5 id="父子组件间通信"><a href="#父子组件间通信" class="headerlink" title="父子组件间通信"></a>父子组件间通信</h5><ul><li><p>父传子<strong>（通过props）</strong></p><p>父组件通过import引入子组件，并注册，在子组件标签上添加需要传递的属性。在子组件中通过props接收。props的值有两种方式：</p><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p><p>方式二：对象，对象可以设置传递的类型，也可以设置默认值等</p></li><li><p>子传父（通过$emit）</p><p>子组件通过绑定事件触发函数，在函数中设置this.$emit(‘要派发的自定义事件’，传递的值)，在父组件中，通过v-on监听子组件派发的自定义事件</p></li></ul></li><li><h5 id="兄弟组件间通信"><a href="#兄弟组件间通信" class="headerlink" title="兄弟组件间通信"></a>兄弟组件间通信</h5><p>方法一：通过事件总线（event bus）实现</p><p>在vue的原型对象上初始化bus,作为全局的事件总线（即两个组件之间的桥梁）。在一个组件中通过this.bus.$emit(‘自定义事件’，值)发送数据，在另一个组件中通过this.bus.$on(‘自定义事件’，function(){})接收数据</p><p>方法二：通过Vuex实现</p></li></ul><h4 id="12-Vuex的理解"><a href="#12-Vuex的理解" class="headerlink" title="12.Vuex的理解"></a>12.Vuex的理解</h4><p>Vuex是一个状态管理工具，每个Vuex应用的核心就是store对象（仓库），包含着应用中所有需要共享的组件状态。主要用于解决大中型复杂项目数据共享问题。</p><p>五大核心属性：</p><ul><li><p>State（单一状态树）</p><p>存储数据、状态</p></li><li><p>Getter</p><p>可以认为是 store 的计算属性，从其中获取一些<strong>state变异后的状态</strong></p></li><li><p>Mutation</p><p>是唯一更改 store 中状态的方法，且必须是同步函数（方便devtools跟踪每一个状态的变化）</p></li><li><p>Action</p><p>可以包含任意异步操作，通过提交mutation间接更新状态</p></li><li><p>Module</p><p>将 store 分割成模块，每个模块都具有state、mutation、action、getter、甚至是嵌套子模块。</p></li></ul><p>vuex的数据传递流程：</p><p>当组件进行数据修改的时候，通过调用dispatch来触发actions，actions通过commit来触发mutations里面的方法进行数据的修改。mutations里面的每个函数都会有一个state参数，这样就可以在mutations里面进行state的数据修改，从而同步到组件，更新其数据状态</p><h4 id="13-vue-router-路由模式"><a href="#13-vue-router-路由模式" class="headerlink" title="13.vue-router 路由模式"></a>13.vue-router 路由模式</h4><ul><li><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用 HTML5 History API 来实现 URL 的变化。</p><p>其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录</p></li><li><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><p>使用 URL hash 值来作路由。hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换。可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</p></li></ul><h4 id="14-虚拟-DOM"><a href="#14-虚拟-DOM" class="headerlink" title="14.虚拟 DOM"></a>14.虚拟 DOM</h4><p>虚拟DOM是为了解决浏览器性能问题而设计出来的</p><ul><li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li><li>状态变更时，记录新树和旧树的差异</li><li>最后把差异更新到真正的dom中</li></ul><p>举例说明：一次操作中有10次更新dom的动作，虚拟dom不会立即操作dom，而是使用而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 <code>attch</code> 到 DOM 树上</p><p>优点：</p><ul><li>无需手动操作dom</li><li>跨平台</li></ul><h4 id="15-Vue-的-nextTick-的原理是什么？"><a href="#15-Vue-的-nextTick-的原理是什么？" class="headerlink" title="15.Vue 的 nextTick 的原理是什么？"></a>15.Vue 的 nextTick 的原理是什么？</h4><p>主要作用：为了处理数据动态变化后，dom未及时更新</p><p>nextTick 的原理正是 vue 通过异步队列控制 dom更新和 nextTick 回调函数先后执行的方式</p><h4 id="16-vue-首屏加载优化"><a href="#16-vue-首屏加载优化" class="headerlink" title="16.vue 首屏加载优化"></a>16.vue 首屏加载优化</h4><ol><li><p>vue 路由的懒加载</p><p><code>const home = () =&gt; import(&#39;./Home.vue&#39;)</code></p></li><li><p>把不常改变的库放到 index.html 中，通过 cdn 引入,然后在vue.config.js文件中，使用webpack的externals属性将不需要打包的库文件分离出去，减少打包文件后的大小</p><div class="hljs"><pre><code class="hljs js">externals: &#123;
  <span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span>,
  <span class="hljs-string">'vue-router'</span>: <span class="hljs-string">'VueRouter'</span>,
  <span class="hljs-string">'element-ui'</span>: <span class="hljs-string">'ELEMENT'</span>,
&#125;,</code></pre></div></li></ol><h4 id="17-route-和-router-的区别是什么？"><a href="#17-route-和-router-的区别是什么？" class="headerlink" title="17. route 和 router 的区别是什么？"></a>17. <code>route</code> 和 <code>router</code> 的区别是什么？</h4><p><code>route</code>是“路由信息对象”，包括<code>path</code>,<code>params</code>,<code>hash</code>,<code>query</code>,<code>fullPath</code>,<code>matched</code>,<code>name</code>等路由信息参数。<br><code>router</code>是“路由实例对象”，包括了路由的跳转方法(<code>push</code>、<code>replace</code>)，钩子函数等。</p><h4 id="18-Vue中key的作用"><a href="#18-Vue中key的作用" class="headerlink" title="18.Vue中key的作用"></a>18.Vue中key的作用</h4><p><strong>key 的作用主要是为了高效的更新虚拟DOM</strong></p></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/vue/">vue</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"></div><div class="post-next col-6"><a href="/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94JavaScript%E7%AF%87/"><span class="hidden-mobile">前端面试——JavaScript篇</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div>©2020 By TQ</div><div>Power by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><p id="hitokoto">获取中...</p></footer><style>#hitokoto{text-align:center;color:#fff;background-color:rgba(10,10,10,.8);margin-bottom:0;padding:10px 0}</style><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","前端面试——Vue篇&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>!function(e,r,t){var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},function e(){for(var t=0;t<n.length;t++)n[t].alpha<=0?(r.body.removeChild(n[t].el),n.splice(t,1)):(n[t].y--,n[t].scale+=.004,n[t].alpha-=.013,n[t].el.style.cssText="left:"+n[t].x+"px;top:"+n[t].y+"px;opacity:"+n[t].alpha+";transform:scale("+n[t].scale+","+n[t].scale+") rotate(45deg);background:"+n[t].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script>var now = new Date();
  function createtime(){
      var grt= new Date("05/27/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  fetch('https://v1.hitokoto.cn/')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script></body></html>