<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="rgba(10,10,10,.7)"><meta name="description" content=""><meta name="author" content="tq"><meta name="keywords" content=""><title>前端面试——JavaScript篇 - TQ个人博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>TQ个人博客</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-07-06 15:46">2020年7月6日 下午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 5.9k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 68 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><h4 id="1-js-的数据类型有哪些-值（变量）是如何存储的"><a href="#1-js-的数据类型有哪些-值（变量）是如何存储的" class="headerlink" title="1.js 的数据类型有哪些,值（变量）是如何存储的"></a>1.js 的数据类型有哪些,值（变量）是如何存储的</h4><h5 id="基本数据类型（原始数据类型）【七种】："><a href="#基本数据类型（原始数据类型）【七种】：" class="headerlink" title="基本数据类型（原始数据类型）【七种】："></a><strong>基本数据类型</strong>（原始数据类型）【七种】：</h5><ul><li><p>Undefined</p></li><li><p>Null</p></li><li><p>Boolean</p></li><li><p>Number</p></li><li><p>String</p></li><li><p>Symbol</p><p>ES6新增的一种原始数据类型 ，表示为 <strong>独一无二 的值</strong>，用来定义独一无二的对象属性名。</p><p><strong>Symbol的定义</strong></p><ul><li><p>一种Symbol类型可以通过使用Symbol()函数来生成；</p></li><li><p>Symbol()函数可以接收一个字符串作为参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);
<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);
<span class="hljs-built_in">console</span>.log(s1 === s2); <span class="hljs-comment">// false ,Symbol()函数接收的参数相同，其变量的值不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s1); <span class="hljs-comment">//symbol</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s2); <span class="hljs-comment">//symbol</span></code></pre></div></li></ul></li><li><p>BigInt（es10新增,表示任意精度格式的整数）</p></li></ul><p>基本数据类型：直接存放在<strong>栈（stack）</strong>中，在内存中以固定的大小存储</p><h5 id="引用数据类型【一种】："><a href="#引用数据类型【一种】：" class="headerlink" title="引用数据类型【一种】："></a>引用数据类型【一种】：</h5><ul><li><p>Object</p><p>Object本质上是由一组无序的键值对组成的。里面包含 function、Array、Date等</p></li></ul><p>引用数据类型：在<strong>栈（stack）</strong>中存储指向其堆内存的地址，值存放在<strong>堆（heap）</strong>中。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后通过地址指针找到其在堆中的数据。</p><h5 id="扩展：（将一个变量赋值给另一个变量）"><a href="#扩展：（将一个变量赋值给另一个变量）" class="headerlink" title="扩展：（将一个变量赋值给另一个变量）"></a><strong>扩展：</strong>（将一个变量赋值给另一个变量）</h5><ul><li><p>基本数据类型复制的是值，赋值完成，两个变量没有任何关系；</p></li><li><p>引用数据类型复制的是地址，修改一个变量另一个变量也会跟着一起变化。</p></li></ul><h4 id="2-对于基本数据类型和引用数据类型的理解"><a href="#2-对于基本数据类型和引用数据类型的理解" class="headerlink" title="2.对于基本数据类型和引用数据类型的理解"></a>2.对于基本数据类型和引用数据类型的理解</h4><p>基本数据类型的值指的是简单的数据段，引用数据类型指的是可能有多个值构成的对象。可以从三个方面来理解：动态的属性、变量赋值、传递参数</p><ul><li><p>动态的属性</p><p>定义基本数据类型和引用数据类型的值，都是创建一个变量并为该变量赋值。两者的区别在于，引用数据类型的值，我们可以为其添加、改变和删除其属性和方法，而对于基本数据类型的值则不能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">//创建一个对象并将其保存在变量person中</span>
person.name = <span class="hljs-string">"Song"</span>; <span class="hljs-comment">//为该对象添加一个名为name的属性，并赋值为Song</span>
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">//访问name这个属性 结果为Song</span></code></pre></div></li><li><p>变量赋值</p><p>一个变量向另一个变量复制（基本数据类型或引用数据类型的）值时，两则的区别：</p><ul><li><p>基本数据类型的值</p><p>基本数据类型的值存储在栈中，当变量赋值时，会重新创建一个新值将其复制到为新变量分配的位置上,此时两个变量各自拥有属于自己的独立的内存空间，因此两者可以参与任何操作而不会相互影响。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b = a;
b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//1</span>
<span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">//2</span></code></pre></div></li><li><p>引用数据类型的值</p><p>引用数据类型的值存储在堆中，同时在栈中会有相应的堆地址（指针），指向堆的位置。当复制引用数据类型的值时，复制的不是堆内存中的值，而是将栈内存中的地址复制过去，复制操作结束后，两个对象实际上都指向堆中的同一个地方。因此改变其中一个对象（堆中的值改变），那么会影响到另一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;
  name:<span class="hljs-string">"Song"</span>
&#125;;
<span class="hljs-keyword">var</span> obj2 = obj1;
obj2.name = <span class="hljs-string">"D"</span>; <span class="hljs-comment">//改变obj2的name属性的值，则将obj1的也改变了</span>
<span class="hljs-built_in">console</span>.log(obj1.name);<span class="hljs-comment">// D</span></code></pre></div></li></ul></li><li><p>传递参数(函数的形参可以看做是一个变量)</p><ul><li><p><strong>基本数据类型传参</strong><br>当我们把一个基本类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p></li><li><p><strong>引用数据类型传参</strong></p><p>当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person</span>)</span>&#123;
person.age = <span class="hljs-number">26</span>;
person = &#123;  <span class="hljs-comment">//重新开辟了一个内存空间，然后将此内存空间的地址赋给person，可以理解为将刚才指向p1的指针地址给覆盖了，所以改变了person的指向</span>
　　name:<span class="hljs-string">'yyy'</span>,
　　age:<span class="hljs-number">30</span>
&#125;
<span class="hljs-keyword">return</span> person
&#125;
<span class="hljs-keyword">const</span> p1 = &#123;
　　name:<span class="hljs-string">'yck'</span>,
　　age:<span class="hljs-number">25</span>
&#125;;
<span class="hljs-keyword">const</span> p2 = test(p1);<span class="hljs-comment">//将p1的内存地址指针复制给了形参person，两者引用的是同一个对象，这个时候在函数中改变变量，就会影响到外部。</span>
<span class="hljs-built_in">console</span>.log(p1);<span class="hljs-comment">//&#123;name: "yck", age: 26&#125;</span>
<span class="hljs-built_in">console</span>.log(p2);<span class="hljs-comment">//&#123;name: "yyy", age: 30&#125;</span></code></pre></div></li></ul></li></ul><h4 id="3-JS中数据类型的判断"><a href="#3-JS中数据类型的判断" class="headerlink" title="3.JS中数据类型的判断"></a>3.JS中数据类型的判断</h4><ul><li><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>typeof 检测<strong>变量的数据类型</strong>，返回一个<strong>字符串</strong>。</p><p>对于基本类型，除了null都可以返回正确类型;对于对象来说，除了function都返回object。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">'str'</span>);           <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object     null 的数据类型被 typeof 解释为 object</span>
-----------------------------------------------------------------
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object     []数组的数据类型在 typeof 中被解释为 object</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);    <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span></code></pre></div></li><li><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>instanceof 用来判断<strong>对象的类型</strong>，<strong>原理</strong>是检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。也就是判断对象是否是某一数据类型（如Array）的实例</p><div class="hljs"><pre><code class="hljs plain">object instanceof constructor
&#x2F;&#x2F;object  某个实例对象
&#x2F;&#x2F;constructor  某个构造函数</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//使用instanceof来判断基本类型，则始终返回false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>);                    <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span>);                <span class="hljs-comment">// false </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'str'</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>);                <span class="hljs-comment">// false  </span>
----------------------------------------------------------------
<span class="hljs-comment">//引用数据类型的值都是object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终返回true。</span>
<span class="hljs-built_in">console</span>.log([] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);                    <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>);       <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);                   <span class="hljs-comment">// true</span></code></pre></div></li><li><h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a><strong>Object.prototype.toString()</strong></h5><p>Object.prototype.toString()方法得到对象内部属性[[Class]]？不理解</p><p>使用 call 对基本数据类型进行包装，使用 Object 对象的原型方法 toString转成字符串 。传入基本类型也能够判断出结果</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//结果都为true</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;)  ===  <span class="hljs-string">'[object Object]'</span>   
<span class="hljs-built_in">Object</span>.prototype.toString.call([])   ===  <span class="hljs-string">'[object Array]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)  ===  <span class="hljs-string">'[object Function]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'somestring'</span>)  ===  <span class="hljs-string">'[object String]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>)  ===  <span class="hljs-string">'[object Number]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)  ===  <span class="hljs-string">'[object Boolean]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>()) ===  <span class="hljs-string">'[object Symbol]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)   ===  <span class="hljs-string">'[object Null]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>)  === <span class="hljs-string">'[object Undefined]'</span></code></pre></div></li><li><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h5><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span>).constructor === <span class="hljs-built_in">Number</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-literal">true</span>).constructor === <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-string">'str'</span>).constructor === <span class="hljs-built_in">String</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(([]).constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;).constructor === <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((&#123;&#125;).constructor === <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span>

----------------------------------------------------------
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;
Fn.prototype=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> Fn();
<span class="hljs-built_in">console</span>.log(f.constructor===Fn);    <span class="hljs-comment">// false，函数Fn的原型改变了，constructor也会发生改变</span>
<span class="hljs-built_in">console</span>.log(f.constructor===<span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span></code></pre></div></li></ul><h4 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h4><table><thead><tr><th>转换类型</th><th>方法</th></tr></thead><tbody><tr><td>转换为字符串</td><td><strong>toString()</strong>、String() 强制转化、<strong>加号拼接字符串</strong></td></tr><tr><td>转换为数字型</td><td><strong>parseInt()</strong>、<strong>parseFloat()</strong>、Number()强制转换、js隐式转换（- * /）</td></tr><tr><td>转换为布尔型</td><td>Boolean()方法</td></tr></tbody></table><p><strong>包装类型</strong></p><p>为了便于操作基本类型值，衍生出来了三个包装类型:Boolean,Number,String,每当读取一个基本类型值的时候，后台会创建一个对应的基本包装类型的对象，从而能够调用一些方法来操作这些基本类型。每个包装类型都映射到同名的基本类型。</p><p><strong>引用数据类型和包装类型的主要区别</strong>：就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，因此我们不能在运行时为基本类型值添加属性和方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"stringtext"</span>;
s1.color = <span class="hljs-string">"red"</span>; <span class="hljs-comment">//在这一句话执行完的瞬间，第二行创建的String就已经被销毁了。</span>
<span class="hljs-built_in">console</span>.log(s1.color);<span class="hljs-comment">//执行这一行代码时又创建了自己的String对象，而该对象没有color属性，结果为undefine</span></code></pre></div><p><strong>宽松相等“==”和严格相等“===”有什么区别？</strong>（“==”和“===”是隐式类型转换）</p><p>==在相等比较中会自动类型转换，而===不会自动类型转换，直接比较</p><p>扩展：<a href="https://zhuanlan.zhihu.com/p/31105614" target="_blank" rel="noopener">面试题</a></p><h4 id="5-作用域和作用域链"><a href="#5-作用域和作用域链" class="headerlink" title="5.作用域和作用域链"></a>5.作用域和作用域链</h4><ul><li><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域是定义变量（函数）时产生的，决定了代码执行区域对于变量，函数，对象的可访问性</p><p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><ul><li><p>全局作用域</p><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件，一般来说以下几种情形拥有全局作用域：</p><p>1.最外层函数和在最外层函数外面定义的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> outVariable = <span class="hljs-string">"我是最外层变量"</span>; <span class="hljs-comment">//最外层变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//最外层函数</span>
    <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">"内层变量"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//内层函数</span>
        <span class="hljs-built_in">console</span>.log(inVariable);
    &#125;
    innerFun();
&#125;
<span class="hljs-built_in">console</span>.log(outVariable); <span class="hljs-comment">//我是最外层变量</span>
outFun(); <span class="hljs-comment">//内层变量</span>
<span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">//inVariable is not defined</span>
innerFun(); <span class="hljs-comment">//innerFun is not defined</span></code></pre></div><p>2.所有末定义直接赋值的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun2</span>(<span class="hljs-params"></span>) </span>&#123;
    variable = <span class="hljs-string">"未定义直接赋值的变量"</span>;
    <span class="hljs-keyword">var</span> inVariable2 = <span class="hljs-string">"内层变量2"</span>;
&#125;
outFun2();<span class="hljs-comment">//要先执行这个函数，否则根本不知道里面是啥</span>
<span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">//未定义直接赋值的变量</span>
<span class="hljs-built_in">console</span>.log(inVariable2); <span class="hljs-comment">//inVariable2 is not defined</span></code></pre></div><p>3.所有window对象的属性</p><p><strong>全局作用域的缺点</strong>：如果变量都定义全局作用域中，会污染全局命名空间, 容易引起命名冲突。</p></li><li><p>函数作用域</p><p>作用于函数内的代码环境，只能在函数内部访问</p><div class="hljs"><pre><code class="hljs plain">function doSomething()&#123;
    var blogName&#x3D;&quot;blog&quot;;
    function innerSay()&#123;
        alert(blogName);
    &#125;
    innerSay();
&#125;
alert(blogName); &#x2F;&#x2F;blogName is not defined
innerSay(); &#x2F;&#x2F;innerSay is not defined</code></pre></div><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong></p><p><strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><div class="hljs"><pre><code class="hljs plain">if (true) &#123;
    &#x2F;&#x2F; &#39;if&#39; 条件语句块不会创建一个新的作用域
    var name &#x3D; &#39;Hammad&#39;; &#x2F;&#x2F; name 依然在全局作用域中
&#125;
console.log(name); &#x2F;&#x2F; logs &#39;Hammad&#39;</code></pre></div></li><li><p>块级作用域（<strong>ES6</strong>）</p><p>块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol></li></ul></li><li><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>当我们查找一个变量时，如果当前执行环境中没有找到，就向外层去找同名变量，这种作用域产生的“由内向外”的过程就是作用域链。</p></li></ul><p><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">关于作用域和作用域链的详细介绍</a></p><h4 id="6-原型和原型链"><a href="#6-原型和原型链" class="headerlink" title="6.原型和原型链"></a>6.原型和原型链</h4><p>使用构造函数创建某一类对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;
    
&#125;
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Star();
person.name = <span class="hljs-string">'Kevin'</span>;
<span class="hljs-comment">//Star 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</span></code></pre></div><ul><li><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>每一个构造函数的内部都有一个 prototype 属性(原型对象)，prototype是一个对<br>象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</p><p>new的实例化对象都具有的一个<code>__proto__</code>属性(原型)，这个属性会指向构造函数的原型对象。</p><p><code>__proto__</code>的意义就在于为对象的查找机制提供一个方向，或者说一条路线。但是它是一个非标准属性，因此实际开发中，不可以使用这个属性。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p></li><li><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型上查找，如果还没有就查找原型对象的原型，一直找到Object原型对象的原型（null）为止，这就是原型链</p><p><img src="https://img-blog.csdnimg.cn/20200613090128300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><p>构造函数实例和原型对象三角关系：</p><p>1.构造函数的prototype属性指向了构造函数原型对象<br>2.实例对象是由构造函数创建的,实例对象的<code>__proto__</code>属性指向了构造函数的原型对象<br>3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数</p><h4 id="7-new对象是内部做了什么"><a href="#7-new对象是内部做了什么" class="headerlink" title="7.new对象是内部做了什么"></a>7.new对象是内部做了什么</h4><p>（1）<strong>创建一个新对象，并继承其构造函数的<code>prototype</code></strong>（继承构造函数原型对象上的属性和方法）</p><p>（2）<strong>执行构造函数，方法内的<code>this</code>指向该对象</strong>（执行构造函数内的赋值操作）</p><p>（3）<strong>返回新对象</strong></p><h4 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8.闭包"></a>8.闭包</h4><p>闭包（closure）是指能够访问另一个函数内部变量的函数。</p><p>创建闭包：在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包的用途：</p><ul><li><p>创建私有变量</p><p>通过使用闭包，我们可以通过在函数外部调用闭包函数，从而在外部访问到函数内部的变量</p></li><li><p>延伸变量的作用域</p><p>闭包函数保留了这个变量对象的引用，让这个变量在函数执行完毕之后不会被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;
       n++;
       <span class="hljs-built_in">console</span>.log(n);
    &#125;
    <span class="hljs-keyword">return</span> add;
&#125;
<span class="hljs-keyword">var</span> f = fn(); <span class="hljs-comment">//注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span>
f();    <span class="hljs-comment">//1</span>
f();    <span class="hljs-comment">//2  第二次调用n变量还在内存中</span></code></pre></div></li><li><p>避免全局变量污染</p></li></ul><p>闭包的缺点：</p><ul><li>导致内存泄漏（不合理的使用闭包，从而导致某些变量一直被留在内存当中。）</li></ul><p>闭包应用场景：</p><ol><li><p>Ajax请求的成功回调</p></li><li><p>事件绑定的回调方法</p></li><li><p>setTimeout的延时回调</p></li><li><p>一个函数内部返回另一个匿名函数</p></li></ol><h4 id="9-DOM事件流"><a href="#9-DOM事件流" class="headerlink" title="9.DOM事件流"></a>9.DOM事件流</h4><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p>DOM 事件流会经历3个阶段：</p><ol><li><p>捕获阶段</p><p>由 DOM 最顶层节点（document）开始，然后逐级向下传播到最具体的元素接收的过程。</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段</p><p>事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点（document）的过程</p></li></ol><h4 id="10-事件委托"><a href="#10-事件委托" class="headerlink" title="10.事件委托"></a>10.事件委托</h4><p>事件委托也称为事件代理,利用事件冒泡机制，当子元素的事件触发，会冒泡到父元素，让父元素代替执行</p><p><strong>事件委托的好处</strong></p><ul><li>只绑定一次事件，无频繁访问DOM，性能较高</li><li>当有新DOM生成时，无需重复绑定事件</li></ul><p><strong>事件委托的局限性</strong></p><p>比如 onblur、onfocus、onmouseenter、onmouseleave之类的事件本身没有事件冒泡机制，所以无法委托</p><p>事件委托的应用场景</p><p>1.实现事件的动态绑定，比如说新增了一个子节点，我们直接父元素中的监听函数处理这个子节点触发的事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oUl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ul"</span>);
<span class="hljs-keyword">let</span> num = <span class="hljs-number">4</span>;
oUl.addEventListener(<span class="hljs-string">'mouseover'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
  <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;
  <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;
  <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;
     target.style.background=<span class="hljs-string">'red'</span>;
  &#125;
&#125;);　　
oUl.addEventListener(<span class="hljs-string">'mouseout'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
   <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;
   <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;
   <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;
       target.style.background=<span class="hljs-string">'orange'</span>;
    &#125;                
 &#125;);
 btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
   num++;
   <span class="hljs-keyword">let</span> oLi = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);
   oLi.innerHTML = <span class="hljs-number">111</span>*num;
   oUl.appendChild(oLi);
&#125;</code></pre></div><p>2.实现ul中的每个li的点击打印事件</p><div class="hljs"><pre><code class="hljs plain">&lt;script&gt;
  const oUl &#x3D; document.getElementById(&quot;ul&quot;);
  oUl.addEventListener(&#39;click&#39;,function(e)&#123;
     let evt &#x3D; e || window.event;
     let target &#x3D; evt.target || evt.srcElement;&#x2F;&#x2F;target是e对象的一个属性，可以返回事件的目标节点
     &#x2F;&#x2F;nodeName获取具体的标签名，返回是大写的；toLowerCase()将其转换成小写
     if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;
       console.log(&#39;事件委托实现li的点击事件&#39;);
     &#125;
 &#125;)　　              　　
&lt;&#x2F;script&gt;</code></pre></div><p>参考资料：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js中的事件委托或是事件代理详解</a></p><h4 id="11-DOM-操作——节点操作、获取元素"><a href="#11-DOM-操作——节点操作、获取元素" class="headerlink" title="11.DOM 操作——节点操作、获取元素"></a>11.DOM 操作——节点操作、获取元素</h4><table><thead><tr><th>操作类型</th><th>方法</th><th>方法的解释</th></tr></thead><tbody><tr><td>创建节点</td><td><strong>document.createElement(‘tagName’)</strong></td><td>创建由 tagName 指定的 HTML 元素</td></tr><tr><td>添加节点</td><td><strong>node.appendChild(child)</strong></td><td>将一个节点添加到指定父节点的子节点列表末尾</td></tr><tr><td>插入节点</td><td><strong>node.insertBefore(child, 指定元素)</strong></td><td>将一个节点添加到父节点的指定子节点前面</td></tr><tr><td>删除节点</td><td>node.removeChild()</td><td>从 DOM 中删除一个子节点</td></tr><tr><td>复制节点</td><td>node.cloneNode()</td><td>返回调用该方法的节点的一个副本</td></tr><tr><td>查找节点</td><td>getElementById(‘id’)<br>getElementsByTagName(‘标签名’)<br>getElementsByClassName(‘类名’)<br>querySelector(‘选择器’)<br>querySelectorAll(‘选择器’)</td><td>根据ID获取元素对象<br>根据标签名获取元素对象<br>根据类名返回元素对象集合<br>根据指定选择器返回第一个元素对象<br>根据指定选择器返回所有元素对象集合</td></tr></tbody></table><h4 id="12-数组和对象常见的原生方法"><a href="#12-数组和对象常见的原生方法" class="headerlink" title="12.数组和对象常见的原生方法"></a>12.数组和对象常见的原生方法</h4><p>下划线（_）：表示改变原数组的方法</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td><u>push()</u></td><td>数组末尾添加一个或多个元素</td></tr><tr><td><u>unshift()</u></td><td>数组首位添加一个或多个元素</td></tr><tr><td><u>shift()</u></td><td>删除数组的第一个元素，并返回该值</td></tr><tr><td><u>pop()</u></td><td>删除数组的最后一个元素，并返回该值</td></tr><tr><td><u>splice()</u></td><td>用于插入、删除、替换数组的元素</td></tr><tr><td><u>reverse()</u></td><td>颠倒数组中元素的位置</td></tr><tr><td><u>sort()</u></td><td>对数组元素进行排序（从小到大）</td></tr><tr><td>isArray()</td><td>用于确定传递的值是否是一个 Array，返回一个布尔值</td></tr><tr><td>toString()</td><td>把数组转换成字符串，并返回结果</td></tr><tr><td>join()</td><td>所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来</td></tr><tr><td>slice()</td><td>可从已有的数组中返回选定的元素</td></tr><tr><td>concat()</td><td>用于连接两个或多个数组</td></tr><tr><td>indexOf()</td><td>返回指定元素在数组中的第一个索引，如果不存在，则返回-1（用于查找一个元素的位置）</td></tr><tr><td>lastindexOf()</td><td>返回指定元素在数组中的最后一个的索引,如果不存在，则返回-1</td></tr><tr><td><code>forEach()</code></td><td>为每个数组元素执行一次 <code>callback</code> 函数</td></tr><tr><td><code>map()</code></td><td>给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数,该函数每次执行后的返回值组成一个新数组（映射函数）</td></tr><tr><td><code>every()</code></td><td>测试一个数组内的所有元素是否都能通过某个指定函数的测试。返回一个布尔值</td></tr><tr><td><code>some()</code></td><td>测试数组中是不是至少有1个元素通过了指定函数测试。返回一个布尔值</td></tr><tr><td><code>filter()</code></td><td>为数组中的每个元素调用一次 <code>callback</code> 函数，该函数每次执行后的结果返回 true 的元素形成一个新数组（过滤函数）</td></tr><tr><td><code>includes()</code></td><td>方法用来判断一个数组是否包含一个指定的值，返回一个布尔值(用于判断一个元素是否存在于数组中)</td></tr><tr><td><code>find()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>值</strong>。否则返回 undefined</td></tr><tr><td><code>findIndex()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>索引</strong>。否则返回-1</td></tr></tbody></table><table><thead><tr><th>对象方法</th><th>说明</th></tr></thead><tbody><tr><td>charAt()</td><td>返回指定位置的字符</td></tr><tr><td>charCodeAt()</td><td>返回在指定位置字符的Unicode 编码</td></tr><tr><td>concat()</td><td>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回(不推荐)</td></tr><tr><td><code>indexOf()</code></td><td>返回调用它的 String对象中第一次出现的指定值的索引，如果未找到该值，则返回 -1。</td></tr><tr><td><strong><code>substring()</code></strong></td><td>提取字符串中两个指定的索引之间的字符</td></tr><tr><td><code>slice()</code></td><td>提取某个字符串的一部分，并返回一个新的字符串</td></tr><tr><td><code>split()</code></td><td>使用指定的分隔符字符串将一个String对象分割成子字符串数组</td></tr><tr><td>toLocaleLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLocaleUpperCase()</td><td>把字符串转换为大写格式</td></tr></tbody></table><h4 id="12-null、undefined-与-undeclared-的区别"><a href="#12-null、undefined-与-undeclared-的区别" class="headerlink" title="12.null、undefined 与 undeclared 的区别"></a>12.null、undefined 与 undeclared 的区别</h4><ul><li><h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null表示“没有对象”，即该处不应该有值</p><p>典型用法：</p><ul><li>作为函数的参数，表示该函数的参数不是对象</li><li>作为对象原型链的终点</li></ul></li><li><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>undefined表示“缺少值”，此处应该有一个值，只是没有定义</p><p>典型用法：</p><ul><li><p>变量被声明了，但没有赋值时，就等于undefined</p></li><li><p>调用函数时，应该提供的参数没有提供，该参数等于undefined</p></li><li><p>对象没有赋值的属性，该属性的值为undefined</p></li><li><p>函数没有返回值时，默认返回undefined</p></li></ul></li><li><h5 id="undeclared"><a href="#undeclared" class="headerlink" title="undeclared"></a>undeclared</h5><p>没有在作用域中声明过的变量，对其引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</p><p>扩展：我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p></li></ul><p>扩展：</p><p>null == undefined 为true，因为它们是类似的值；如果用全等于(===)，null === undefined会返回false ,因为它们是不同类型的值。</p><h4 id="13-call、apply和bind的理解"><a href="#13-call、apply和bind的理解" class="headerlink" title="13.call、apply和bind的理解"></a>13.call、apply和bind的理解</h4><blockquote><p><code>call</code> 和 <code>apply</code> 实现函数调用，并都可以改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p></blockquote><p>模拟实现call()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//变更函数调用者示例</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
 &#125;            
 <span class="hljs-keyword">const</span> obj = &#123;
    name: <span class="hljs-string">'写代码'</span>
 &#125;
 
<span class="hljs-comment">//思路：  </span>
<span class="hljs-comment">// 改变了 this 指向，让新的对象可以执行该函数。</span>
<span class="hljs-comment">// 那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？      </span>
<span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,...args</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">//this不是函数，抛出异常</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)
    &#125;
    <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>
    <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>
    param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>
    <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>
    <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>
    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>
&#125;
foo.myCall(obj);  <span class="hljs-comment">//输出写代码</span></code></pre></div><p>模拟实现apply()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,args</span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
      <span class="hljs-comment">//this不是函数，抛出异常</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)
      &#125;
      <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>
      <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>
      param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>
      <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>
      <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>
      <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>
  &#125;
  foo.myApply(obj,[]);  <span class="hljs-comment">//输出写代码</span></code></pre></div><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br>语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><p>14.Ajax 是什么? 如何创建一个 Ajax？</p></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/JS/">JS</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"></div><div class="post-next col-6"><a href="/2020/07/06/%E7%BD%91%E9%A1%B5%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"><span class="hidden-mobile">网页、移动端特效和本地存储</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div>©2020 By TQ</div><div>Power by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><p id="hitokoto">获取中...</p></footer><style>#hitokoto{text-align:center;color:#fff;background-color:rgba(10,10,10,.8);margin-bottom:0;padding:10px 0}</style><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","前端面试——JavaScript篇&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>!function(e,r,t){var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},function e(){for(var t=0;t<n.length;t++)n[t].alpha<=0?(r.body.removeChild(n[t].el),n.splice(t,1)):(n[t].y--,n[t].scale+=.004,n[t].alpha-=.013,n[t].el.style.cssText="left:"+n[t].x+"px;top:"+n[t].y+"px;opacity:"+n[t].alpha+";transform:scale("+n[t].scale+","+n[t].scale+") rotate(45deg);background:"+n[t].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script>var now = new Date();
  function createtime(){
      var grt= new Date("05/27/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  fetch('https://v1.hitokoto.cn/')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script></body></html>