<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="rgba(10,10,10,.7)"><meta name="description" content=""><meta name="author" content="tq"><meta name="keywords" content=""><title>前端面试——JavaScript篇 - TQ个人博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>TQ个人博客</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-07-06 15:46">2020年7月6日 下午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 10.4k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 122 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><h4 id="1-js-的数据类型有哪些-值（变量）是如何存储的"><a href="#1-js-的数据类型有哪些-值（变量）是如何存储的" class="headerlink" title="1.js 的数据类型有哪些,值（变量）是如何存储的"></a>1.js 的数据类型有哪些,值（变量）是如何存储的</h4><h5 id="基本数据类型（原始数据类型）【七种】："><a href="#基本数据类型（原始数据类型）【七种】：" class="headerlink" title="基本数据类型（原始数据类型）【七种】："></a><strong>基本数据类型</strong>（原始数据类型）【七种】：</h5><ul><li><p>Undefined</p></li><li><p>Null</p></li><li><p>Boolean</p></li><li><p>Number</p></li><li><p>String</p></li><li><p>Symbol</p><p>ES6新增的一种原始数据类型 ，表示为 <strong>独一无二 的值</strong>，用来定义独一无二的对象属性名。</p><p><strong>Symbol的定义</strong></p><ul><li><p>一种Symbol类型可以通过使用Symbol()函数来生成；</p></li><li><p>Symbol()函数可以接收一个字符串作为参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);
<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);
<span class="hljs-built_in">console</span>.log(s1 === s2); <span class="hljs-comment">// false ,Symbol()函数接收的参数相同，其变量的值不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s1); <span class="hljs-comment">//symbol</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s2); <span class="hljs-comment">//symbol</span></code></pre></div></li></ul></li><li><p>BigInt（es10新增,表示任意精度格式的整数）</p></li></ul><p>基本数据类型：直接存放在<strong>栈（stack）</strong>中，在内存中以固定的大小存储</p><h5 id="引用数据类型【一种】："><a href="#引用数据类型【一种】：" class="headerlink" title="引用数据类型【一种】："></a>引用数据类型【一种】：</h5><ul><li><p>Object</p><p>Object本质上是由一组无序的名值对组成的。里面包含 function、Array、Date等</p></li></ul><p>引用数据类型：在<strong>栈（stack）</strong>中存储指向其堆内存的地址，值存放在<strong>堆（heap）</strong>中。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后通过地址指针找到其在堆中的数据。</p><h5 id="扩展：（将一个变量赋值给另一个变量）"><a href="#扩展：（将一个变量赋值给另一个变量）" class="headerlink" title="扩展：（将一个变量赋值给另一个变量）"></a><strong>扩展：</strong>（将一个变量赋值给另一个变量）</h5><ul><li><p>基本数据类型复制的是值，赋值完成，两个变量没有任何关系；</p></li><li><p>引用数据类型复制的是地址，修改一个变量另一个变量也会跟着一起变化。</p></li></ul><h4 id="2-对于基本数据类型和引用数据类型的理解"><a href="#2-对于基本数据类型和引用数据类型的理解" class="headerlink" title="2.对于基本数据类型和引用数据类型的理解"></a>2.对于基本数据类型和引用数据类型的理解</h4><p>基本数据类型的值指的是简单的数据段，引用数据类型指的是可能有多个值构成的对象。可以从三个方面来理解：动态的属性、变量赋值、传递参数</p><ul><li><p>动态的属性</p><p>定义基本数据类型和引用数据类型的值，都是创建一个变量并为该变量赋值。两者的区别在于，引用数据类型的值，我们可以为其添加、改变和删除其属性和方法，而对于基本数据类型的值则不能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">//创建一个对象并将其保存在变量person中</span>
person.name = <span class="hljs-string">"Song"</span>; <span class="hljs-comment">//为该对象添加一个名为name的属性，并赋值为Song</span>
<span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">//访问name这个属性 结果为Song</span></code></pre></div></li><li><p>变量赋值</p><p>一个变量向另一个变量复制（基本数据类型或引用数据类型的）值时，两则的区别：</p><ul><li><p>基本数据类型的值</p><p>基本数据类型的值存储在栈中，当变量赋值时，会重新创建一个新值将其复制到为新变量分配的位置上,此时两个变量各自拥有属于自己的独立的内存空间，因此两者可以参与任何操作而不会相互影响。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;
<span class="hljs-keyword">var</span> b = a;
b = <span class="hljs-number">2</span>;
<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//1</span>
<span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">//2</span></code></pre></div></li><li><p>引用数据类型的值</p><p>引用数据类型的值存储在堆中，同时在栈中会有相应的堆地址（指针），指向堆的位置。当复制引用数据类型的值时，复制的不是堆内存中的值，而是将栈内存中的地址复制过去，复制操作结束后，两个对象实际上都指向堆中的同一个地方。因此改变其中一个对象（堆中的值改变），那么会影响到另一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;
  name:<span class="hljs-string">"Song"</span>
&#125;;
<span class="hljs-keyword">var</span> obj2 = obj1;
obj2.name = <span class="hljs-string">"D"</span>; <span class="hljs-comment">//改变obj2的name属性的值，则将obj1的也改变了</span>
<span class="hljs-built_in">console</span>.log(obj1.name);<span class="hljs-comment">// D</span></code></pre></div></li></ul></li><li><p>传递参数(函数的形参可以看做是一个变量)</p><ul><li><p><strong>基本数据类型传参</strong><br>当我们把一个基本类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p></li><li><p><strong>引用数据类型传参</strong></p><p>当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person</span>)</span>&#123;
person.age = <span class="hljs-number">26</span>;
person = &#123;  <span class="hljs-comment">//重新开辟了一个内存空间，然后将此内存空间的地址赋给person，可以理解为将刚才指向p1的指针地址给覆盖了，所以改变了person的指向</span>
　　name:<span class="hljs-string">'yyy'</span>,
　　age:<span class="hljs-number">30</span>
&#125;
<span class="hljs-keyword">return</span> person
&#125;
<span class="hljs-keyword">const</span> p1 = &#123;
　　name:<span class="hljs-string">'yck'</span>,
　　age:<span class="hljs-number">25</span>
&#125;;
<span class="hljs-keyword">const</span> p2 = test(p1);<span class="hljs-comment">//将p1的内存地址指针复制给了形参person，两者引用的是同一个对象，这个时候在函数中改变变量，就会影响到外部。</span>
<span class="hljs-built_in">console</span>.log(p1);<span class="hljs-comment">//&#123;name: "yck", age: 26&#125;</span>
<span class="hljs-built_in">console</span>.log(p2);<span class="hljs-comment">//&#123;name: "yyy", age: 30&#125;</span></code></pre></div></li></ul></li></ul><h4 id="3-JS中数据类型的判断"><a href="#3-JS中数据类型的判断" class="headerlink" title="3.JS中数据类型的判断"></a>3.JS中数据类型的判断</h4><ul><li><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>typeof 检测<strong>变量的数据类型</strong>，返回一个<strong>字符串</strong>。</p><p>对于基本类型，除了null都可以返回正确类型;对于对象来说，除了function都返回object。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">'str'</span>);           <span class="hljs-comment">// string</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object     null 的数据类型被 typeof 解释为 object</span>
-----------------------------------------------------------------
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object     []数组的数据类型在 typeof 中被解释为 object</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);    <span class="hljs-comment">// function</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span></code></pre></div></li><li><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>instanceof 用来判断<strong>对象的类型</strong>，<strong>原理</strong>是检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。也就是判断对象是否是某一数据类型（如Array）的实例</p><div class="hljs"><pre><code class="hljs plain">object instanceof constructor
&#x2F;&#x2F;object  某个实例对象
&#x2F;&#x2F;constructor  某个构造函数</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//使用instanceof来判断基本类型，则始终返回false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>);                    <span class="hljs-comment">// false</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span>);                <span class="hljs-comment">// false </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'str'</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>);                <span class="hljs-comment">// false  </span>
----------------------------------------------------------------
<span class="hljs-comment">//引用数据类型的值都是object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终返回true。</span>
<span class="hljs-built_in">console</span>.log([] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);                    <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>);       <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);                   <span class="hljs-comment">// true</span></code></pre></div></li><li><h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a><strong>Object.prototype.toString()</strong></h5><p>Object.prototype.toString()方法得到对象内部属性[[Class]]？不理解</p><p>使用 call 对基本数据类型进行包装，使用 Object 对象的原型方法 toString转成字符串 。传入基本类型也能够判断出结果</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//结果都为true</span>
<span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;)  ===  <span class="hljs-string">'[object Object]'</span>   
<span class="hljs-built_in">Object</span>.prototype.toString.call([])   ===  <span class="hljs-string">'[object Array]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)  ===  <span class="hljs-string">'[object Function]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'somestring'</span>)  ===  <span class="hljs-string">'[object String]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>)  ===  <span class="hljs-string">'[object Number]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)  ===  <span class="hljs-string">'[object Boolean]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>()) ===  <span class="hljs-string">'[object Symbol]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)   ===  <span class="hljs-string">'[object Null]'</span>　　
<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>)  === <span class="hljs-string">'[object Undefined]'</span></code></pre></div></li><li><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h5><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span>).constructor === <span class="hljs-built_in">Number</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-literal">true</span>).constructor === <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-string">'str'</span>).constructor === <span class="hljs-built_in">String</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(([]).constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;).constructor === <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log((&#123;&#125;).constructor === <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span>

----------------------------------------------------------
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;
Fn.prototype=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();
<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> Fn();
<span class="hljs-built_in">console</span>.log(f.constructor===Fn);    <span class="hljs-comment">// false，函数Fn的原型改变了，constructor也会发生改变</span>
<span class="hljs-built_in">console</span>.log(f.constructor===<span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span></code></pre></div></li></ul><h4 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h4><table><thead><tr><th>转换类型</th><th>方法</th></tr></thead><tbody><tr><td>转换为字符串</td><td><strong>toString()</strong>、String() 强制转化、<strong>加号拼接字符串</strong></td></tr><tr><td>转换为数字型</td><td><strong>parseInt()</strong>、<strong>parseFloat()</strong>、Number()强制转换、js隐式转换（- * /）</td></tr><tr><td>转换为布尔型</td><td>Boolean()方法</td></tr></tbody></table><p><strong>包装类型</strong></p><p>为了便于操作基本类型值，衍生出来了三个包装类型:Boolean,Number,String,每当读取一个基本类型值的时候，后台会创建一个对应的基本包装类型的对象，从而能够调用一些方法来操作这些基本类型。每个包装类型都映射到同名的基本类型。</p><p><strong>引用数据类型和包装类型的主要区别</strong>：就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，因此我们不能在运行时为基本类型值添加属性和方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"stringtext"</span>;
s1.color = <span class="hljs-string">"red"</span>; <span class="hljs-comment">//在这一句话执行完的瞬间，第二行创建的String就已经被销毁了。</span>
<span class="hljs-built_in">console</span>.log(s1.color);<span class="hljs-comment">//执行这一行代码时又创建了自己的String对象，而该对象没有color属性，结果为undefine</span></code></pre></div><p><strong>宽松相等“==”和严格相等“===”有什么区别？</strong>（“==”和“===”是隐式类型转换）</p><p>==在相等比较中会自动类型转换，而===不会自动类型转换，直接比较</p><p>扩展：<a href="https://zhuanlan.zhihu.com/p/31105614" target="_blank" rel="noopener">面试题</a></p><h4 id="5-作用域和作用域链"><a href="#5-作用域和作用域链" class="headerlink" title="5.作用域和作用域链"></a>5.作用域和作用域链</h4><ul><li><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域是定义变量（函数）时产生的，决定了代码执行区域对于变量，函数，对象的可访问性</p><p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><ul><li><p>全局作用域</p><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件，在任何地方都可以访问.一般来说以下几种情形拥有全局作用域：</p><p>1.最外层函数和在最外层函数外面定义的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> outVariable = <span class="hljs-string">"我是最外层变量"</span>; <span class="hljs-comment">//最外层变量</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//最外层函数</span>
    <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">"内层变量"</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//内层函数</span>
        <span class="hljs-built_in">console</span>.log(inVariable);
    &#125;
    innerFun();
&#125;
<span class="hljs-built_in">console</span>.log(outVariable); <span class="hljs-comment">//我是最外层变量</span>
outFun(); <span class="hljs-comment">//内层变量</span>
<span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">//inVariable is not defined</span>
innerFun(); <span class="hljs-comment">//innerFun is not defined</span></code></pre></div><p>2.所有末定义直接赋值的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun2</span>(<span class="hljs-params"></span>) </span>&#123;
    variable = <span class="hljs-string">"未定义直接赋值的变量"</span>;
    <span class="hljs-keyword">var</span> inVariable2 = <span class="hljs-string">"内层变量2"</span>;
&#125;
outFun2();<span class="hljs-comment">//要先执行这个函数，否则根本不知道里面是啥</span>
<span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">//未定义直接赋值的变量</span>
<span class="hljs-built_in">console</span>.log(inVariable2); <span class="hljs-comment">//inVariable2 is not defined</span></code></pre></div><p>3.所有window对象的属性</p><p><strong>全局作用域的缺点</strong>：如果变量都定义全局作用域中，会污染全局命名空间, 容易引起命名冲突。</p></li><li><p>函数作用域</p><p>作用于函数内的代码环境，只能在函数内部访问</p><div class="hljs"><pre><code class="hljs plain">function doSomething()&#123;
    var blogName&#x3D;&quot;blog&quot;;
    function innerSay()&#123;
        alert(blogName);
    &#125;
    innerSay();
&#125;
alert(blogName); &#x2F;&#x2F;blogName is not defined
innerSay(); &#x2F;&#x2F;innerSay is not defined</code></pre></div><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong></p><p><strong>块语句（大括号“｛｝”中间的语句），如 if 和 switch 条件语句或 for 和 while 循环语句，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><div class="hljs"><pre><code class="hljs plain">if (true) &#123;
    &#x2F;&#x2F; &#39;if&#39; 条件语句块不会创建一个新的作用域
    var name &#x3D; &#39;Hammad&#39;; &#x2F;&#x2F; name 依然在全局作用域中
&#125;
console.log(name); &#x2F;&#x2F; logs &#39;Hammad&#39;</code></pre></div></li><li><p>块级作用域（<strong>ES6</strong>）</p><p>块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol></li></ul></li><li><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>当我们查找一个变量时，如果当前执行环境中没有找到，就向外层去找同名变量，这种作用域产生的“由内向外”的过程就是作用域链。</p></li></ul><p><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">关于作用域和作用域链的详细介绍</a></p><h4 id="6-原型和原型链"><a href="#6-原型和原型链" class="headerlink" title="6.原型和原型链"></a>6.原型和原型链</h4><p>使用构造函数创建某一类对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;
    
&#125;
<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Star();
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf( person)); 
person.name = <span class="hljs-string">'Kevin'</span>;
<span class="hljs-comment">//Star 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</span></code></pre></div><ul><li><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>js作者在设计js的时候，希望是一门简单的编程语言，但js里面的所有数据类型都是对象（Object）,必须有一种机制，将所有对象联系起来，所以设计了“继承”。但是不想js变得复杂，没有引入“类”（Class）的概念，根据（java、c++语言的思想）引入了new命令，通过new构造函数实例化对象，同时为构造函数设置了 prototype 属性，这样所有的实例对象共享同一个prototype，从外界来看，prototype就好像是实例对象的原型对象</p><p>每一个构造函数的内部都有一个 prototype 属性(原型对象)，prototype是一个对<br>象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。</p></li><li><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>new的实例化对象都具有的一个<code>__proto__</code>属性(原型)，这个属性会指向构造函数的原型对象。</p><p><code>__proto__</code>的意义就在于为对象的查找机制提供一个方向，或者说一条路线。但是它是一个非标准属性，因此实际开发中，不可以使用这个属性。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p></li><li><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型上查找，如果还没有就查找原型对象的原型，一直找到Object原型对象的原型（null）为止，这就是原型链</p><p><img src="https://img-blog.csdnimg.cn/20200613090128300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><p>构造函数实例和原型对象三角关系：</p><p>1.构造函数的prototype属性指向了构造函数原型对象<br>2.实例对象是由构造函数创建的,实例对象的<code>__proto__</code>属性指向了构造函数的原型对象<br>3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数</p><h4 id="7-new对象是内部做了什么"><a href="#7-new对象是内部做了什么" class="headerlink" title="7.new对象是内部做了什么"></a>7.new对象是内部做了什么</h4><p>（1）<strong>创建一个新对象，并继承其构造函数的<code>prototype</code></strong>（继承构造函数原型对象上的属性和方法）</p><p>（2）<strong>执行构造函数，方法内的<code>this</code>指向该对象</strong>（执行构造函数内的赋值操作）</p><p>（3）<strong>返回新对象</strong></p><h4 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8.闭包"></a>8.闭包</h4><p>闭包（closure）是指能够访问另一个函数内部变量的函数。</p><p>创建闭包：在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包的用途：</p><ul><li><p>创建私有变量</p><p>通过使用闭包，我们可以通过在函数外部调用闭包函数，从而在外部访问到函数内部的变量</p></li><li><p>延伸变量的作用域</p><p>闭包函数保留了变量对象的引用，让这个变量在函数执行完毕之后不会被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;
       n++;
       <span class="hljs-built_in">console</span>.log(n);
    &#125;
    <span class="hljs-keyword">return</span> add;
&#125;
<span class="hljs-keyword">var</span> f = fn(); <span class="hljs-comment">//注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span>
f();    <span class="hljs-comment">//1</span>
f();    <span class="hljs-comment">//2  第二次调用n变量还在内存中</span></code></pre></div></li><li><p>避免全局变量污染</p></li></ul><p>闭包的缺点：</p><ul><li>导致内存泄漏（不合理的使用闭包，从而导致某些变量一直被留在内存当中。）</li></ul><p>闭包应用场景：</p><ol><li><p>Ajax请求的成功回调</p></li><li><p>事件绑定的回调方法</p></li><li><p>setTimeout的延时回调</p></li><li><p>一个函数内部返回另一个匿名函数</p></li></ol><h4 id="9-DOM事件流"><a href="#9-DOM事件流" class="headerlink" title="9.DOM事件流"></a>9.DOM事件流</h4><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p>DOM 事件流会经历3个阶段：</p><ol><li><p>捕获阶段</p><p>由 DOM 最顶层节点（document）开始，然后逐级向下传播到最具体的元素接收的过程。</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段</p><p>事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点（document）的过程</p></li></ol><h4 id="10-事件委托"><a href="#10-事件委托" class="headerlink" title="10.事件委托"></a>10.事件委托</h4><p>事件委托也称为事件代理,利用事件冒泡机制，当子元素的事件触发，会冒泡到父元素，让父元素代替执行</p><p><strong>事件委托的好处</strong></p><ul><li>只绑定一次事件，无频繁访问DOM，性能较高</li><li>当有新DOM生成时，无需重复绑定事件</li></ul><p><strong>事件委托的局限性</strong></p><p>比如 onblur、onfocus、onmouseenter、onmouseleave之类的事件本身没有事件冒泡机制，所以无法委托</p><p>事件委托的应用场景</p><p>1.实现事件的动态绑定，比如说新增了一个子节点，我们直接父元素中的监听函数处理这个子节点触发的事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oUl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ul"</span>);
<span class="hljs-keyword">let</span> num = <span class="hljs-number">4</span>;
oUl.addEventListener(<span class="hljs-string">'mouseover'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
  <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;
  <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;
  <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;
     target.style.background=<span class="hljs-string">'red'</span>;
  &#125;
&#125;);　　
oUl.addEventListener(<span class="hljs-string">'mouseout'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;
   <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;
   <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;
   <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;
       target.style.background=<span class="hljs-string">'orange'</span>;
    &#125;                
 &#125;);
 btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
   num++;
   <span class="hljs-keyword">let</span> oLi = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);
   oLi.innerHTML = <span class="hljs-number">111</span>*num;
   oUl.appendChild(oLi);
&#125;</code></pre></div><p>2.实现ul中的每个li的点击打印事件</p><div class="hljs"><pre><code class="hljs plain">&lt;script&gt;
  const oUl &#x3D; document.getElementById(&quot;ul&quot;);
  oUl.addEventListener(&#39;click&#39;,function(e)&#123;
     let evt &#x3D; e || window.event;&#x2F;&#x2F;e指事件对象
     let target &#x3D; evt.target || evt.srcElement;&#x2F;&#x2F;target是e对象的一个属性，可以返回事件的目标节点
     &#x2F;&#x2F;nodeName获取具体的标签名，返回是大写的；toLowerCase()将其转换成小写
     if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;
       console.log(&#39;事件委托实现li的点击事件&#39;);
     &#125;
 &#125;)　
 
&#x2F;&#x2F;jq方式实现相对而言简单 $(“oul”).on(“click”,“li”,function()&#123;&#x2F;&#x2F;事件逻辑&#125;)  
&#x2F;&#x2F;其中第二个参数指的是触发事件的具体目标，特别是给动态添加的元素绑定事件，这个特别起作用
&lt;&#x2F;script&gt;</code></pre></div><p>参考资料：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js中的事件委托或是事件代理详解</a></p><h4 id="11-DOM-操作——节点操作、获取元素"><a href="#11-DOM-操作——节点操作、获取元素" class="headerlink" title="11.DOM 操作——节点操作、获取元素"></a>11.DOM 操作——节点操作、获取元素</h4><table><thead><tr><th>操作类型</th><th>方法</th><th>方法的解释</th></tr></thead><tbody><tr><td>创建节点</td><td><strong>document.createElement(‘tagName’)</strong></td><td>创建由 tagName 指定的 HTML 元素</td></tr><tr><td>添加节点</td><td><strong>node.appendChild(child)</strong></td><td>将一个节点添加到指定父节点的子节点列表末尾</td></tr><tr><td>插入节点</td><td><strong>node.insertBefore(child, 指定元素)</strong></td><td>将一个节点添加到父节点的指定子节点前面</td></tr><tr><td>删除节点</td><td>node.removeChild()</td><td>从 DOM 中删除一个子节点</td></tr><tr><td>复制节点</td><td>node.cloneNode()</td><td>返回调用该方法的节点的一个副本</td></tr><tr><td>查找节点</td><td>getElementById(‘id’)<br>getElementsByTagName(‘标签名’)<br>getElementsByClassName(‘类名’)<br>querySelector(‘选择器’)<br>querySelectorAll(‘选择器’)</td><td>根据ID获取元素对象<br>根据标签名获取元素对象<br>根据类名返回元素对象集合<br>根据指定选择器返回第一个元素对象<br>根据指定选择器返回所有元素对象集合</td></tr></tbody></table><h4 id="12-数组和对象常见的原生方法"><a href="#12-数组和对象常见的原生方法" class="headerlink" title="12.数组和对象常见的原生方法"></a>12.数组和对象常见的原生方法</h4><p>下划线（_）：表示改变原数组的方法</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td><u>push()</u></td><td>数组末尾添加一个或多个元素</td></tr><tr><td><u>unshift()</u></td><td>数组首位添加一个或多个元素</td></tr><tr><td><u>shift()</u></td><td>删除数组的第一个元素，并返回该值</td></tr><tr><td><u>pop()</u></td><td>删除数组的最后一个元素，并返回该值</td></tr><tr><td><u>splice()</u></td><td>用于插入、删除、替换数组的元素</td></tr><tr><td><u>reverse()</u></td><td>颠倒数组中元素的位置</td></tr><tr><td><u>sort()</u></td><td>对数组元素进行排序（从小到大）</td></tr><tr><td>isArray()</td><td>用于确定传递的值是否是一个 Array，返回一个布尔值</td></tr><tr><td>toString()</td><td>把数组转换成字符串，并返回结果</td></tr><tr><td>join()</td><td>所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来</td></tr><tr><td>slice()</td><td>可从已有的数组中返回选定的元素</td></tr><tr><td>concat()</td><td>用于连接两个或多个数组</td></tr><tr><td>indexOf()</td><td>返回指定元素在数组中的第一个索引，如果不存在，则返回-1（用于查找一个元素的位置）</td></tr><tr><td>lastindexOf()</td><td>返回指定元素在数组中的最后一个的索引,如果不存在，则返回-1</td></tr><tr><td><code>forEach()</code></td><td>为每个数组元素执行一次 <code>callback</code> 函数</td></tr><tr><td><code>map()</code></td><td>给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数,该函数每次执行后的返回值组成一个新数组（映射函数）</td></tr><tr><td><code>every()</code></td><td>测试一个数组内的所有元素是否都能通过某个指定函数的测试。返回一个布尔值</td></tr><tr><td><code>some()</code></td><td>测试数组中是不是至少有1个元素通过了指定函数测试。返回一个布尔值</td></tr><tr><td><code>filter()</code></td><td>为数组中的每个元素调用一次 <code>callback</code> 函数，该函数每次执行后的结果返回 true 的元素形成一个新数组（过滤函数）</td></tr><tr><td><code>includes()</code></td><td>方法用来判断一个数组是否包含一个指定的值，返回一个布尔值(用于判断一个元素是否存在于数组中)</td></tr><tr><td><code>find()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>值</strong>。否则返回 undefined</td></tr><tr><td><code>findIndex()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>索引</strong>。否则返回-1</td></tr></tbody></table><table><thead><tr><th>对象方法</th><th>说明</th></tr></thead><tbody><tr><td>charAt()</td><td>返回指定位置的字符</td></tr><tr><td>charCodeAt()</td><td>返回在指定位置字符的Unicode 编码</td></tr><tr><td>concat()</td><td>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回(不推荐)</td></tr><tr><td><code>indexOf()</code></td><td>返回调用它的 String对象中第一次出现的指定值的索引，如果未找到该值，则返回 -1。</td></tr><tr><td><strong><code>substring()</code></strong></td><td>提取字符串中两个指定的索引之间的字符</td></tr><tr><td><code>slice()</code></td><td>提取某个字符串的一部分，并返回一个新的字符串</td></tr><tr><td><code>split()</code></td><td>使用指定的分隔符字符串将一个String对象分割成子字符串数组</td></tr><tr><td>toLocaleLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLocaleUpperCase()</td><td>把字符串转换为大写格式</td></tr></tbody></table><h4 id="12-null、undefined-与-undeclared-的区别"><a href="#12-null、undefined-与-undeclared-的区别" class="headerlink" title="12.null、undefined 与 undeclared 的区别"></a>12.null、undefined 与 undeclared 的区别</h4><ul><li><h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null表示“没有对象”，即该处不应该有值</p><p>典型用法：</p><ul><li>作为函数的参数，表示该函数的参数不是对象</li><li>作为对象原型链的终点</li></ul></li><li><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>undefined表示“缺少值”，此处应该有一个值，只是没有定义</p><p>典型用法：</p><ul><li><p>变量被声明了，但没有赋值时，就等于undefined</p></li><li><p>调用函数时，应该提供的参数没有提供，该参数等于undefined</p></li><li><p>对象没有赋值的属性，该属性的值为undefined</p></li><li><p>函数没有返回值时，默认返回undefined</p></li></ul></li><li><h5 id="undeclared"><a href="#undeclared" class="headerlink" title="undeclared"></a>undeclared</h5><p>没有在作用域中声明过的变量，对其引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</p><p>扩展：我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p></li></ul><p>扩展：</p><p>null == undefined 为true，因为它们是类似的值；如果用全等于(===)，null === undefined会返回false ,因为它们是不同类型的值。</p><h4 id="13-call、apply和bind的理解"><a href="#13-call、apply和bind的理解" class="headerlink" title="13.call、apply和bind的理解"></a>13.call、apply和bind的理解</h4><blockquote><p><code>call</code> 和 <code>apply</code> 实现函数调用，并都可以改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p></blockquote><p>模拟实现call()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//变更函数调用者示例</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
 &#125;            
 <span class="hljs-keyword">const</span> obj = &#123;
    name: <span class="hljs-string">'写代码'</span>
 &#125;
 
<span class="hljs-comment">//思路：  </span>
<span class="hljs-comment">// 改变了 this 指向，让新的对象可以执行该函数。</span>
<span class="hljs-comment">// 那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？      </span>
<span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,...args</span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
    <span class="hljs-comment">//this不是函数，抛出异常</span>
    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;
        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)
    &#125;
    <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>
    <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>
    param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>
    <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>
    <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>
    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>
&#125;
foo.myCall(obj);  <span class="hljs-comment">//输出写代码</span></code></pre></div><p>模拟实现apply()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,args</span>)</span>&#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
      <span class="hljs-comment">//this不是函数，抛出异常</span>
      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;
          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)
      &#125;
      <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>
      <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>
      param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>
      <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>
      <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>
      <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>
  &#125;
  foo.myApply(obj,[]);  <span class="hljs-comment">//输出写代码</span></code></pre></div><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br>语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><h4 id="14-Ajax-是什么-如何创建一个-Ajax？"><a href="#14-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="14.Ajax 是什么? 如何创建一个 Ajax？"></a>14.Ajax 是什么? 如何创建一个 Ajax？</h4><p>Ajax是一种异步通信的方法，通过 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。（异步局部刷新技术）</p><p>创建步骤：</p><p>创建对象 =&gt; 配置Ajax请求地址 =&gt; 发送请求 =&gt; 监听请求，接受响应</p><p>原生写法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1：创建Ajax对象</span>
<span class="hljs-keyword">var</span> xhr = <span class="hljs-built_in">window</span>.XMLHttpRequest?<span class="hljs-keyword">new</span> XMLHttpRequest():<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>);<span class="hljs-comment">// 兼容IE6及以下版本</span>
<span class="hljs-comment">//2：配置 Ajax请求地址</span>
xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'url'</span>,<span class="hljs-literal">true</span>);
<span class="hljs-comment">//3：发送请求</span>
xhr.send(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 严谨写法</span>
<span class="hljs-comment">//4:监听请求，接受响应</span>
xhr.onreadysatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
<span class="hljs-comment">//readystate是当前的状态值</span>
<span class="hljs-comment">//status是Http的状态码 200表示ok  </span>
   <span class="hljs-keyword">if</span>(xhr.readySate==<span class="hljs-number">4</span>&amp;&amp;xhr.status==<span class="hljs-number">200</span>)      <span class="hljs-built_in">console</span>.log(xhr.responseText)
&#125;</code></pre></div><p>jQuery写法</p><div class="hljs"><pre><code class="hljs js">.ajax(&#123;
 type:<span class="hljs-string">'post'</span>,
 url:<span class="hljs-string">''</span>,
 <span class="hljs-keyword">async</span>:ture,<span class="hljs-comment">//async 异步  sync同步</span>
 data:data,<span class="hljs-comment">//针对post请求</span>
 dataType:<span class="hljs-string">'json'</span>,
 success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;&#125;,
 error:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;&#125;
&#125;)</code></pre></div><p>promise 封装实现</p><div class="hljs"><pre><code class="hljs plain">function getJSON(url) &#123;
  &#x2F;&#x2F; 创建一个 promise 对象
  let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;
      let xhr &#x3D; new XMLHttpRequest();
      &#x2F;&#x2F; 新建一个 http 请求
      xhr.open(&quot;GET&quot;, url, true);
      &#x2F;&#x2F; 设置状态的监听函数
      xhr.onreadystatechange &#x3D; function() &#123;
          if (this.readyState !&#x3D;&#x3D; 4) return;
      &#x2F;&#x2F; 当请求成功或失败时，改变 promise 的状态
      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;
        resolve(this.response);
      &#125; else &#123;
        reject(new Error(this.statusText));
      &#125;
    &#125;;

    &#x2F;&#x2F; 设置错误监听函数
    xhr.onerror &#x3D; function() &#123;
      reject(new Error(this.statusText));
    &#125;;
    &#x2F;&#x2F; 设置响应的数据类型
    xhr.responseType &#x3D; &quot;json&quot;;
    &#x2F;&#x2F; 设置请求头信息
    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);
    &#x2F;&#x2F; 发送 http 请求
    xhr.send(null);
  &#125;);

  return promise;
&#125;</code></pre></div><h4 id="15-如何实现继承"><a href="#15-如何实现继承" class="headerlink" title="15.如何实现继承"></a>15.如何实现继承</h4><h5 id="一-原型链继承"><a href="#一-原型链继承" class="headerlink" title="一. 原型链继承"></a>一. 原型链继承</h5><p>原型链继承的原理很简单，直接让<strong>子类的原型对象指向父类实例</strong>，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而<strong>实现对父类的属性和方法的继承</strong></p><p>原型继承的缺点:</p><p>1.由于子类实例原型对象指向父类实例, 因此子类实例继承的引用类型如果被修改，会影响到所有的实例对象</p><p>2.创建子类实例无法向父类构造函数传参, 即没有实现<code>super()</code>的功能</p><h5 id="二-构造函数继承"><a href="#二-构造函数继承" class="headerlink" title="二. 构造函数继承"></a>二. 构造函数继承</h5><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数</strong>（使用call或者apply方法），并为其绑定子类的<code>this</code>，让父类的构造函数把成员属性和方法都挂到<code>子类的this</code>上去，这样既能<strong>避免实例之间共享一个原型实例</strong>，又能向<strong>父类构造方法传参</strong></p><p>构造函数继承的缺点:</p><p>1.继承不到父类原型上的属性和方法</p><h5 id="三-组合式继承"><a href="#三-组合式继承" class="headerlink" title="三. 组合式继承"></a>三. 组合式继承</h5><p>原型链继承和构造函数继承组合起来使用</p><p>组合式继承的缺点:</p><p>1.每次创建子类实例都执行了两次构造函数(<code>Parent.call()</code>和<code>new Parent()</code>)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅</p><h5 id="四-寄生式组合继承"><a href="#四-寄生式组合继承" class="headerlink" title="四. 寄生式组合继承"></a>四. 寄生式组合继承</h5><p>为了解决构造函数被执行两次的问题, 我们将<code>指向父类实例</code>改为<code>指向父类原型</code>, 减去一次构造函数的执行</p><p>寄生式组合继承的缺点:</p><p>1.由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给<code>Child.prototype</code>增加一个getName()方法，那么会导致<code>Parent.prototype</code>也增加或被覆盖一个getName()方法，为了解决这个问题，我们给<code>Parent.prototype</code>做一个浅拷贝 <code>Object.create(Parent.prototype)</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 父类初始化实例属性和原型属性</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>)</span>&#123;
	<span class="hljs-keyword">this</span>.name = name
	<span class="hljs-keyword">this</span>.hobby = [<span class="hljs-string">"吃饭"</span>, <span class="hljs-string">"睡觉"</span>];
&#125;
Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name,age</span>) </span>&#123;
    <span class="hljs-comment">// 构造函数继承</span>
    Parent.call(<span class="hljs-keyword">this</span>, name) 
    <span class="hljs-keyword">this</span>.age = age
&#125;
<span class="hljs-comment">//原型链继承</span>
<span class="hljs-comment">// Child.prototype = new Parent()</span>

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">Child,Parent</span>)</span>&#123;
 <span class="hljs-keyword">let</span> parentProto = <span class="hljs-built_in">Object</span>.create(Parent.prototype)<span class="hljs-comment">//创建父类原型的一个副本</span>
 parentProto.constructor = Child
 Child.prototype = parentProto <span class="hljs-comment">//子类原型指向父类原型</span>
&#125;
<span class="hljs-comment">// 将父类原型指向子类</span>
inheritPrototype(Child, Parent);

<span class="hljs-comment">// 新增子类原型属性</span>
Child.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);
&#125;;

<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"儿子1"</span>, <span class="hljs-number">23</span>);
<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"儿子2"</span>, <span class="hljs-number">23</span>);
instance1.hobby.push(<span class="hljs-string">"打豆豆"</span>);
<span class="hljs-built_in">console</span>.log(instance1.hobby);<span class="hljs-comment">// ["吃饭", "睡觉"，"打豆豆"]</span>
<span class="hljs-built_in">console</span>.log(instance2.hobby);<span class="hljs-comment">// ["吃饭", "睡觉"]</span></code></pre></div><blockquote><p>以上四种继承方式是在ES5环境下继承的实现，具体实现过程：</p><p>一开始最容易想到的是<code>原型链继承</code>，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<code>对子类实例继承的引用类型的修改会影响到所有的实例对象</code>以及<code>无法向父类的构造方法传参</code>。<br>因此我们引入了<code>构造函数继承</code>, 通过在子类构造函数中调用父类构造函数，并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承<code>不能继承到父类原型链上的属性和方法</code>。<br>所以我们综合了两种继承的优点，提出了<code>组合式继承</code>，但组合式继承也引入了新的问题，它<code>每次创建子类实例都执行了两次父类构造方法</code>，我们通过将<code>子类原型指向父类实例</code>改为<code>子类原型指向父类原型的浅拷贝</code>来解决这一问题，也就是最终实现 —— <code>寄生组合式继承</code></p></blockquote><h5 id="五-ES6中的继承方式"><a href="#五-ES6中的继承方式" class="headerlink" title="五.ES6中的继承方式"></a>五.ES6中的继承方式</h5><p>用class定义类，用extends继承类，用super()表示父类</p><div class="hljs"><pre><code class="hljs js">创建父类
<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Father</span></span>&#123;
  <span class="hljs-keyword">constructor</span>(name) &#123;
   <span class="hljs-comment">//构造器代码，new时自动执行</span>
      <span class="hljs-keyword">this</span>.name = name;
  &#125;
  work()&#123;
        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">'刷碗'</span>);
    &#125;
&#125;
 
创建子类并继承父类
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;
  <span class="hljs-keyword">constructor</span>() &#123;
   <span class="hljs-keyword">super</span>()  <span class="hljs-comment">//表示父类</span>
  &#125;
&#125;
<span class="hljs-keyword">var</span> son=<span class="hljs-keyword">new</span> Son( )
son.work()</code></pre></div><h4 id="16-ES6新增特性"><a href="#16-ES6新增特性" class="headerlink" title="16.ES6新增特性"></a>16.ES6新增特性</h4><p>常用的主要有</p><ul><li><h5 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h5><ul><li><p>let</p><p>1.用于声明变量的关键字</p><p>2.let声明的变量有一个块级作用域范围</p></li><li><p>const</p><p>1.用于声明一个只读的常量</p><p>2.一旦声明必须赋值,不能使用null占位。并且声明后不能再修改<br>3.如果声明的是复合类型数据，可以修改其属性</p></li></ul><p><code>var</code>,<code>let</code>和<code>const</code>的区别是什么？</p><p>1.var声明变量存在变量提升，let和const不存在变量提升</p><p>2.let和const声明形成块作用域</p><p>3.同一作用域下let和const不能声明同名变量，而var可以</p></li><li><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>ES6中使用箭头函数(=&gt;)来定义函数，有以下特点：</p><ul><li><p>当函数体中只有一个表达式或值需要返回，不需要 return 语句，箭头函数就会有一个隐式的返回。</p></li><li><p>箭头函数中有一个参数，则可以省略括号</p></li><li><p>箭头函数不能访问arguments对象，可以使用rest参数来获得在箭头函数中传递的所有参数</p></li></ul></li><li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>反引号和使用<code>${express}</code>嵌入一个表达式组成</p></li><li><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>在ES6中可以从数组和对象中提取值，对变量进行赋值，称为解构赋值。</p><p>解构赋值就是只要等号两边的模式相同，左边的变量就会被对应赋值。</p><p>解构赋值允许指定默认值。应该注意undefined，因为undefined是不能赋值的</p></li><li><h5 id="模块的导入-import-和导出-export-default-export"><a href="#模块的导入-import-和导出-export-default-export" class="headerlink" title="模块的导入(import)和导出(export default/export)"></a>模块的导入(import)和导出(export default/export)</h5></li><li><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>Promise 是异步编程的一种解决方案。以同步的方式写异步的代码，避免了多层回调函数嵌套问题。</p><p>一个Promise有几种状态：</p><ol><li>pending初始状态，既不是成功状态，也不是失败状态。</li><li>fulfilled表示操作成功完成。</li><li>rejected表示操作失败。</li></ol><p>pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch()方法</p><p><strong>Promise.all()</strong></p><p><code>Promise.all(iterable)</code>用于将多个Promise 实例包装成一个新的 Promise实例，参数为一组 Promise 实例组成的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);

<span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1,p2,p3]);

p.then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;
  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// [1,2,3]</span>
&#125;
------------------------------------------------
<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)
<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)
<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)

<span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])
p.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(data)
&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"err:"</span> + err) <span class="hljs-comment">// 3</span>
&#125;)</code></pre></div><p>当 p1, p2, p3 状态都 Resolved 的时候，p 的状态才会 Resolved;</p><p>只要有一个实例 Rejected ，此时第一个被 Rejected 的实例返回值就会传递给 P 的回调函数(只要有一个失败了就直接失败)</p><p><strong>Promise.race()</strong></p><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br><code>const p = Promise.race([p1, p2, p3]);</code></p><p>说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态</p></li><li><h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h5><p><code>async</code> 是异步的意思，而 <code>await</code> 是 <code>async wait</code>的简写，即异步等待</p><p>从语义上理解 <code>async</code> 用于声明一个 <code>function</code> 是异步的，<code>await</code> 用于等待一个异步方法执行完成</p><p>另外 <code>await</code> 只能出现在 <code>async</code> 函数中</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">return</span> <span class="hljs-string">"this is async"</span>
&#125;
<span class="hljs-keyword">const</span> res = test()
<span class="hljs-built_in">console</span>.log(res)<span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: "this is async"&#125;</span></code></pre></div><p><code>async</code> 函数返回的是一个 Promise 对象</p><p>实现一个业务需求：多个请求，每个请求依赖于上一个请求的结果</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeTime</span>(<span class="hljs-params">n</span>)</span>&#123;
	<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;
		setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(n+<span class="hljs-number">200</span>),n)
	&#125;)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">n</span>)</span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)
	<span class="hljs-keyword">return</span> takeTime(n)
&#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">n</span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)
  <span class="hljs-keyword">return</span> takeTime(n)
 &#125;
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">n</span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)
    <span class="hljs-keyword">return</span> takeTime(n)
&#125;
-----------------------------------
<span class="hljs-comment">//使用Promise</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">200</span>;
    step1(time1)
    	.then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))
    	.then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))
    	.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;
        	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>)
    &#125;)
&#125;
doIt();
-------------------------------------
<span class="hljs-comment">//使用async/await</span>
<span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>)</span>&#123;
    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;
    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> step1(time1);
    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> step2(time2);
    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> step3(time3);
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);
&#125;
doIt();</code></pre></div><p>优点：</p><ul><li><p>内置执行器</p><p><code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p></li><li><p>更好的语义</p><p><code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p></li></ul><p>缺点：</p><p>滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></li><li><p>数组字符串的新方法</p></li></ul><h4 id="17-从输入URL到页面加载完中间发生了什么"><a href="#17-从输入URL到页面加载完中间发生了什么" class="headerlink" title="17.从输入URL到页面加载完中间发生了什么"></a>17.从输入URL到页面加载完中间发生了什么</h4><p>大致过程：</p><ol><li><p>DNS解析</p></li><li><p>TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求并返回需要的数据</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ol><p>输入了一个域名,域名要通过DNS解析,找到这个域名对应的服务器地址(ip),通过TCP请求连接服务,WEB服务器(apache)返回数据,浏览器根据返回数据构建DOM树,通过css渲染引擎及js解析引擎将页面渲染出来,关闭tcp连接</p><h4 id="18-git相关"><a href="#18-git相关" class="headerlink" title="18.git相关"></a>18.git相关</h4><p>（1） 你的项目是如何管理的？</p><p>答：主要通过git来进行项目版本控制的</p><p>（2） 说几个git常用命令？</p><p>答：我工作中常用的有git add ,git status,git commit –m,git push,git pull等</p><p>（3） 说一下多人操作同一个文件，如果出现冲突该如何解决？</p><p>答：当遇到多人协作修改同一个文件时出现冲突，我先将远程文件先git pull下来，手动修改冲突代码后，再git add ,git commit,git push再上传到远程仓库。如果pull也pull不下来提示冲突的话，可以先通过git stash暂存下来，然后再pull拉取，然后git stash pop，取出原来写的，手动修改，然后提交</p><h4 id="19-浅拷贝、深拷贝"><a href="#19-浅拷贝、深拷贝" class="headerlink" title="19.浅拷贝、深拷贝"></a>19.浅拷贝、深拷贝</h4><ul><li><strong>浅拷贝：</strong> 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</li><li><strong>深拷贝：</strong> 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</li></ul><blockquote><p><strong>浅拷贝的实现方式：</strong></p><p><strong>Object.assign() 方法</strong>：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p><p><strong>Array.prototype.slice()：</strong>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><p>扩展运算符（…）</p><p>应用场景：寄生式组合继承</p></blockquote><blockquote><p><strong>深拷贝的实现方式：</strong></p><p>JSON.parse(JSON.stringify(object)): 缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</p><p>浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）</p></blockquote><h4 id="20-跨域的解决方案"><a href="#20-跨域的解决方案" class="headerlink" title="20.跨域的解决方案"></a>20.跨域的解决方案</h4><p>产生跨域的情况有：不同协议，不同域名，不同端口的域名和ip地址的访问都会产生跨域。</p><ul><li>代理（前端代理和后端代理）</li></ul><p>前端代理,在vue中主要是通过vue.config.js文件来配置的，其中有个proxyTable来配置跨域的</p><ul><li>CORS</li></ul><p>CORS全称叫跨域资源共享，主要是后台工程师设置后端代码来达到前端跨域请求的</p><p>​ 注：现在主流框架都是用代理和CORS跨域实现的</p><h4 id="21-JavaScript执行机制"><a href="#21-JavaScript执行机制" class="headerlink" title="21.JavaScript执行机制"></a>21.JavaScript执行机制</h4><p>JavaScript是一门单线程语言</p><p><strong>JS执行步骤</strong></p><ol><li><strong>先执行</strong>执行栈中的<strong>同步任务</strong>。</li><li><strong>异步任务</strong>（回调函数）放入<strong>任务队列</strong>中。</li><li>一旦执行栈中的所有<strong>同步任务执行完毕</strong>，系统就会按次序<strong>读取</strong>任务队列中的<strong>异步任务</strong>，于是被读取的异步任务结束等待状态，<strong>进入执行栈</strong>，开始<strong>执行</strong>。</li></ol><p>事件循环(Event Loop)是js实现异步的一种方法，也是js的执行机制。</p><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li><p>macro-task(宏任务)：包括整体js代码，setTimeout，setInterval</p></li><li><p>micro-task(微任务)：Promise.then,process.nextTick</p><p>注：</p><p>1.一般js代码是同步的，promise也是同步执行的</p><p>2.setTimeout，setInterval是异步的</p><p>3.promise需要resolve或者reject才会执行then或者catch里面的内容</p></li></ul><p>事件循环，宏任务，微任务的关系</p><ol><li>同步的代码会按照执行顺序执行，其它代码属于宏任务的放到宏队列，微任务放到微队列</li><li>执行顺序是宏任务-微任务-宏任务……，进入整体代码(宏任务)后，开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到任务队列里的第一个宏任务执行完毕，再执行所有微任务。再进入任务队列里的下一个宏任务</li></ol><h5 id="总结：（面试回答）"><a href="#总结：（面试回答）" class="headerlink" title="总结：（面试回答）"></a>总结：（面试回答）</h5><p>js是一门单线程语言。整体js代码作为第一个宏任务进入主线程中，同步代码按照执行顺序执行，其它代码划分为宏任务和微任务，放入任务队列中。一旦同步任务执行完毕，就按照宏任务=&gt;微任务=&gt;宏任务的执行顺序执行，因为整体js代码为宏任务，所以接着执行所有的微任务。然后再从宏任务开始，找到任务队列中第一个宏任务执行完毕，再执行所有微任务。再进入任务队列里的下一个宏任务。直到全部代码执行完毕</p><h4 id="22-垃圾回收机制"><a href="#22-垃圾回收机制" class="headerlink" title="22.垃圾回收机制"></a>22.垃圾回收机制</h4><p>JavaScript垃圾回收机制的原理：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，为此垃圾回收器会按照固定的时间间隔周期性的执行</p><ul><li><p><strong>标记清除</strong></p><p>垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。</p></li><li><p>引用计数</p><p>给一个变量赋引用类型值，则该值的引用次数就是1。如果又把该值赋给另一个变量，则该值引用次数加1；相反，如果包含该值的变量又取得另外一个值，则该值的引用次数减1；垃圾回收器会回收引用次数为0的值所占用的内存空间。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。</p></li></ul></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/%E9%9D%A2%E8%AF%95/">面试</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/JS/">JS</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/2020/07/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94Vue%E7%AF%87/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">前端面试——Vue篇</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/2020/07/06/%E7%BD%91%E9%A1%B5%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"><span class="hidden-mobile">网页、移动端特效和本地存储</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div>©2020 By TQ</div><div>Power by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><p id="hitokoto">获取中...</p></footer><style>#hitokoto{text-align:center;color:#fff;background-color:rgba(10,10,10,.8);margin-bottom:0;padding:10px 0}</style><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","前端面试——JavaScript篇&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>!function(e,r,t){var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},function e(){for(var t=0;t<n.length;t++)n[t].alpha<=0?(r.body.removeChild(n[t].el),n.splice(t,1)):(n[t].y--,n[t].scale+=.004,n[t].alpha-=.013,n[t].el.style.cssText="left:"+n[t].x+"px;top:"+n[t].y+"px;opacity:"+n[t].alpha+";transform:scale("+n[t].scale+","+n[t].scale+") rotate(45deg);background:"+n[t].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script>var now = new Date();
  function createtime(){
      var grt= new Date("05/27/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  fetch('https://v1.hitokoto.cn/')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script></body></html>