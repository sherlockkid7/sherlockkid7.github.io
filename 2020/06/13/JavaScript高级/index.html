<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="rgba(10,10,10,.7)"><meta name="description" content=""><meta name="author" content="tq"><meta name="keywords" content=""><title>JavaScript高级 - TQ个人博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>TQ个人博客</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-06-13 12:04">2020年6月13日 中午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 9.1k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 107 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><p><img src="https://img-blog.csdnimg.cn/20200613120140686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-编程思想"><a href="#1-编程思想" class="headerlink" title="1.编程思想"></a>1.编程思想</h2><h3 id="1-1面向过程编程POP"><a href="#1-1面向过程编程POP" class="headerlink" title="1.1面向过程编程POP"></a>1.1面向过程编程POP</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。<br>简单来说：面向过程，就是按照我们分析好了的步骤，<strong>按照步骤解决问题</strong>。</p><h3 id="1-2面向对象编程OOP"><a href="#1-2面向对象编程OOP" class="headerlink" title="1.2面向对象编程OOP"></a>1.2面向对象编程OOP</h3><ul><li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。以<strong>对象功能来划分问题</strong>。</li><li>面向对象的特性： 封装性、 继承性、多态性</li><li>面向对象的思维特点:<ul><li>抽取对象共用的属性和行为组织封装成一个类(模板)</li><li>对类进行实例化, 获取类的对象</li></ul></li></ul><h3 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h3><table><thead><tr><th></th><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>优点</td><td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td></tr><tr><td>缺点</td><td>不易维护、不易复用、不易扩展</td><td>性能比面向过程低</td></tr></tbody></table><h2 id="2-类和对象（ES6）"><a href="#2-类和对象（ES6）" class="headerlink" title="2.类和对象（ES6）"></a>2.类和对象（ES6）</h2><h3 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h3><p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物。例如字符串、数值、数组、函数等。<br>对象是由属性和方法组成的：</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//创建对象</span>
<span class="hljs-comment">//字面量创建对象</span>
<span class="hljs-keyword">var</span> ldh = &#123;
    name: <span class="hljs-string">'刘德华'</span>,
    age: <span class="hljs-number">18</span>
&#125;
<span class="hljs-comment">//new关键字</span>
<span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();

<span class="hljs-comment">//构造函数创建对象</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.age = age;
 &#125;
<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">//实例化对象</span></code></pre></div><h3 id="2-2类-class"><a href="#2-2类-class" class="headerlink" title="2.2类 class"></a>2.2类 class</h3><ul><li><p>基本介绍</p><ul><li><p>在 ES6 中,可以使用 class 关键字声明一个类，之后以这个类来实例化对象。</p></li><li><p>类与对象的区别：</p><p>类抽象了对象的公共部分，它泛指某一大类（class）<br>对象特指某一个，通过类实例化一个具体的对象</p></li></ul></li><li><p>创建类</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> </span>&#123;
<span class="hljs-comment">// class body</span>
&#125;
<span class="hljs-keyword">var</span> 对象名 = <span class="hljs-keyword">new</span> Name();
注意： 类必须使用 <span class="hljs-keyword">new</span> 实例化对象</code></pre></div></li><li><p>添加属性和方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;
    <span class="hljs-keyword">constructor</span>(name,age) &#123; <span class="hljs-comment">// constructor 构造方法或者构造函数(类的共有属性)</span>
    <span class="hljs-keyword">this</span>.name = name;
    <span class="hljs-keyword">this</span>.age = age;
    &#125; <span class="hljs-comment">//-----&gt;注意,方法与方法之间不需要添加逗号,同时方法不需要添加 function 关键字。</span>
    sing(song) &#123;
      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">'唱'</span> + song);
    &#125;
&#125;

<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>);
<span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;name: "刘德华", age: 18&#125;</span>
ldh.sing(<span class="hljs-string">'冰雨'</span>); <span class="hljs-comment">// 刘德华唱冰雨</span></code></pre></div><p><strong>注意:</strong></p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范:创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li></ol></li></ul><h3 id="2-3类的继承"><a href="#2-3类的继承" class="headerlink" title="2.3类的继承"></a>2.3类的继承</h3><ul><li><p>子类可以继承父类的一些属性和方法。<br>语法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">// 父类</span>
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123; <span class="hljs-comment">// 子类继承父类</span>
&#125;</code></pre></div></li></ul><ul><li><p>子类使用super关键字访问父类的方法</p><p>super关键字 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;
    <span class="hljs-keyword">constructor</span>(surname) &#123;
    <span class="hljs-keyword">this</span>.surname = surname;
    &#125;
    saySurname() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我的姓是'</span> + <span class="hljs-keyword">this</span>.surname);
    &#125; 
&#125;
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span>
    <span class="hljs-keyword">constructor</span>(surname, fristname) &#123;
    <span class="hljs-keyword">super</span>(surname); <span class="hljs-comment">// 调用父类的constructor(surname)</span>
    <span class="hljs-keyword">this</span>.fristname = fristname;
    &#125;
    sayFristname() &#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我的名字是："</span> + <span class="hljs-keyword">this</span>.fristname);
    &#125; 
&#125;
<span class="hljs-keyword">var</span> damao = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘'</span>, <span class="hljs-string">"德华"</span>);
damao.saySurname();
damao.sayFristname();</code></pre></div><p>注意: 子类在构造函数中使用super, 必须放到 this 前面 (必须先调用父类的构造方法,再使用子类构造方法)</p></li></ul><p><strong>重点：</strong></p><ul><li><p>this的指向问题,类里面的共有的属性和方法一定要加this使用.</p><ul><li>constructor中的this指向的是new出来的实例对象</li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li></ul></li><li><p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p></li></ul><h2 id="3-构造函数和原型"><a href="#3-构造函数和原型" class="headerlink" title="3.构造函数和原型"></a>3.构造函数和原型</h2><h3 id="3-1构造函数"><a href="#3-1构造函数" class="headerlink" title="3.1构造函数"></a>3.1构造函数</h3><ul><li><p>基本介绍</p><ul><li><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>在 JS 中，使用构造函数时要注意以下两点：</p><p>1.构造函数用于创建某一类对象，其首字母要大写</p><p>2.构造函数要和 new 一起使用才有意义</p><p><strong>new 在执行时会做四件事情</strong>：</p><p>① 在内存中创建一个新的空对象。</p><p>② 让 this 指向这个新的对象。</p><p>③ 执行构造函数里面的代码，给这个新对象添加属性和方法。</p><p>④ 返回这个新对象（所以构造函数里面不需要 return ）。</p></li></ul></li><li><p>静态成员和实例成员</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问</li><li>实例成员：在构造函数内部通过this添加的对象成员称为实例成员，只能由实例化的对象来访问</li></ul></li><li><p>构造函数的问题</p><ul><li>存在浪费内存的问题</li></ul></li></ul><h3 id="3-2构造函数原型对象（-prototype）"><a href="#3-2构造函数原型对象（-prototype）" class="headerlink" title="3.2构造函数原型对象（ prototype）"></a>3.2构造函数原型对象（ prototype）</h3><p>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。<br>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><p><strong>原型对象this指向</strong></p><p>构造函数中的this 指向我们实例对象.</p><p>原型对象里面放的是方法, 这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象.</p><h3 id="3-3对象原型-（proto-）"><a href="#3-3对象原型-（proto-）" class="headerlink" title="3.3对象原型 （proto ）"></a>3.3对象原型 （<strong><strong>proto</strong></strong> ）</h3><p>对象都会有一个属性 <strong><strong>proto</strong></strong> 指向构造函数的原型对象（prototype） ，之所以我们对象可以使用构造函数原型对象（prototype）的属性和方法，就是因为对象有原型（<strong><strong>proto</strong></strong> ）的存在。<br>对象原型 （<strong><strong>proto</strong></strong> ）和原型对象 prototype 是等价的<br>对象原型 （<strong><strong>proto</strong></strong> ）的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p><h3 id="3-4-constructor构造函数"><a href="#3-4-constructor构造函数" class="headerlink" title="3.4 constructor构造函数"></a>3.4 constructor构造函数</h3><p>对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。<br>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。<br>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;
     <span class="hljs-keyword">this</span>.uname = uname;
     <span class="hljs-keyword">this</span>.age = age;
 &#125;
 <span class="hljs-comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span>
 Star.prototype = &#123;
 <span class="hljs-comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span>
   <span class="hljs-keyword">constructor</span>: Star, // 手动设置指回原来的构造函数
   sing: function() &#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会唱歌'</span>);
   &#125;,
   movie: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会演电影'</span>);
   &#125;
&#125;
<span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'张学友'</span>, <span class="hljs-number">19</span>);
<span class="hljs-built_in">console</span>.log(zxy)</code></pre></div><h3 id="3-5原型链"><a href="#3-5原型链" class="headerlink" title="3.5原型链"></a>3.5原型链</h3><p>每一个实例对象都有一个<strong><strong>proto</strong></strong>属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有<strong><strong>proto</strong></strong>属性，这样一层一层往上找就形成了原型链。</p><div class="hljs"><pre><code class="hljs text">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。
如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。
如果还没有就查找原型对象的原型（Object的原型对象）。
依此类推一直找到 Object 为止（null）。
__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200613090128300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>构造函数实例和原型对象三角关系：</p><p>1.构造函数的prototype属性指向了构造函数原型对象<br>2.实例对象是由构造函数创建的,实例对象的<strong>proto</strong>属性指向了构造函数的原型对象<br>3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数</p><p><img src="https://img-blog.csdnimg.cn/20200613090128279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-6扩展内置对象"><a href="#3-6扩展内置对象" class="headerlink" title="3.6扩展内置对象"></a><strong>3.6扩展内置对象</strong></h3><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><p>注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;
  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;
  sum += <span class="hljs-keyword">this</span>[i];
  &#125;
  <span class="hljs-keyword">return</span> sum;
&#125;;
<span class="hljs-comment">//此时数组对象中已经存在sum()方法了  可以始终使用 数组.sum()进行数据的求和</span></code></pre></div><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><h3 id="4-1call"><a href="#4-1call" class="headerlink" title="4.1call()"></a>4.1call()</h3><ul><li><p>call()可以调用函数</p></li><li><p>call()可以修改this的指向</p><div class="hljs"><pre><code class="hljs js">fun.call(thisArg, arg1, arg2, ...)
thisArg ：当前调用函数 <span class="hljs-keyword">this</span> 的指向对象
arg1，arg2：传递的其他参数</code></pre></div></li></ul><h3 id="4-2子构造函数继承父构造函数中的属性"><a href="#4-2子构造函数继承父构造函数中的属性" class="headerlink" title="4.2子构造函数继承父构造函数中的属性"></a>4.2子构造函数继承父构造函数中的属性</h3><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 父构造函数</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;
   <span class="hljs-comment">// this 指向父构造函数的对象实例</span>
   <span class="hljs-keyword">this</span>.uname = uname;
   <span class="hljs-keyword">this</span>.age = age;
 &#125;
  <span class="hljs-comment">// 2 .子构造函数 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;
  <span class="hljs-comment">// this 指向子构造函数的对象实例</span>
  <span class="hljs-number">3.</span>使用call方式实现子继承父的属性
  Father.call(<span class="hljs-keyword">this</span>, uname, age);
  <span class="hljs-keyword">this</span>.score = score;
&#125;
<span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);
<span class="hljs-built_in">console</span>.log(son);</code></pre></div><h3 id="4-3借用原型对象继承父类型方法"><a href="#4-3借用原型对象继承父类型方法" class="headerlink" title="4.3借用原型对象继承父类型方法"></a>4.3借用原型对象继承父类型方法</h3><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br>核心原理：<br>① 将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()<br>② 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象<br>③ 将子类的 constructor 从新指向子类的构造函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 父构造函数</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;
  <span class="hljs-comment">// this 指向父构造函数的对象实例</span>
  <span class="hljs-keyword">this</span>.uname = uname;
  <span class="hljs-keyword">this</span>.age = age;
&#125;
Father.prototype.money = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100000</span>);
 &#125;;
 <span class="hljs-comment">// 2 .子构造函数 </span>
  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;
      <span class="hljs-comment">// this 指向子构造函数的对象实例</span>
      Father.call(<span class="hljs-keyword">this</span>, uname, age);
      <span class="hljs-keyword">this</span>.score = score;
  &#125;
<span class="hljs-comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span>
  Son.prototype = <span class="hljs-keyword">new</span> Father();
  <span class="hljs-comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span>
  Son.prototype.constructor = Son;
  <span class="hljs-comment">// 这个是子构造函数专门的方法</span>
  Son.prototype.exam = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'孩子要考试'</span>);

  &#125;
  <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);
  <span class="hljs-built_in">console</span>.log(son);</code></pre></div><h2 id="5-方法-ES5"><a href="#5-方法-ES5" class="headerlink" title="5. 方法(ES5)"></a>5. 方法(ES5)</h2><h3 id="5-1数组方法"><a href="#5-1数组方法" class="headerlink" title="5.1数组方法"></a>5.1数组方法</h3><ul><li><p><strong>forEach()遍历数组</strong></p><p>array.forEach(function(currentValue, index, arr))</p><ul><li>currentValue：数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>相当于数组遍历的 for循环 <strong>没有返回值</strong></p></li><li><p>map()</p><p><code>map</code> 方法会给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数。<code>callback</code> 每次执行后的返回值（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>）组合起来形成一个新数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123;
 <span class="hljs-comment">// Return element for new_array </span>
&#125;[, thisArg])
<span class="hljs-comment">//callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</span>
<span class="hljs-comment">//thisArg可选  执行 callback 函数时值被用作this。</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>];
<span class="hljs-keyword">var</span> roots = numbers.map(<span class="hljs-built_in">Math</span>.sqrt);
<span class="hljs-comment">// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]</span></code></pre></div></li><li><p><strong>filter()过滤数组</strong></p><p>array.filter(function(currentValue, index, arr))</p><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中<strong>符合条件的所有元素</strong>,主要用于筛选数组</p><p>注意:它直接<strong>返回一个新数组</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">66</span>, <span class="hljs-number">4</span>, <span class="hljs-number">88</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];
  <span class="hljs-keyword">var</span> newArr = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index,array</span>) </span>&#123;
  	 <span class="hljs-comment">//参数一是:数组元素</span>
     <span class="hljs-comment">//参数二是:数组元素的索引</span>
     <span class="hljs-comment">//参数三是:当前的数组</span>
     <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">20</span>;
  &#125;);
  <span class="hljs-built_in">console</span>.log(newArr);<span class="hljs-comment">//[66,88] //返回值是一个新数组</span></code></pre></div></li><li><p><strong>some()</strong></p><p>array.some(function(currentValue, index, arr))</p><ul><li>some() 方法用于检测<strong>数组中的元素是否满足指定条件</strong>.</li><li>注意它<strong>返回值是布尔值</strong>, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.</li><li>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</li></ul><div class="hljs"><pre><code class="hljs js">some 查找数组中是否有满足条件的元素 
 <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>];
 <span class="hljs-keyword">var</span> flag = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,array</span>) </span>&#123;
     <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">3</span>;
  &#125;);
<span class="hljs-built_in">console</span>.log(flag);<span class="hljs-comment">//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环</span></code></pre></div><p><strong>some和forEach区别</strong></p><ul><li><p>如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高</p></li><li><p>在forEach 里面 return 不会终止迭代</p></li></ul></li></ul><h3 id="5-2字符串方法"><a href="#5-2字符串方法" class="headerlink" title="5.2字符串方法"></a>5.2字符串方法</h3><p>trim() 方法会从一个字符串的两端删除空白字符。<br><code>str.trim()</code><br>trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p><h3 id="5-3对象方法"><a href="#5-3对象方法" class="headerlink" title="5.3对象方法"></a>5.3对象方法</h3><ul><li><p>Object.keys() 方法</p><p>获取到当前对象中的属性名 ,返回一个所有元素为字符串的数组。<br>Object.keys(obj)<br>效果类似 for…in</p><div class="hljs"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> obj = &#123;
     id: <span class="hljs-number">1</span>,
     pname: <span class="hljs-string">'小米'</span>,
     price: <span class="hljs-number">1999</span>,
     num: <span class="hljs-number">2000</span>
&#125;;
<span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Object</span>.keys(obj)
<span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">//[id，pname,price,num]</span></code></pre></div></li><li><p>Object.defineProperty()</p><p>定义新属性或修改原有的属性。<br>Object.defineProperty(obj, prop, descriptor)</p><ul><li><p>obj：必需。目标对象</p></li><li><p>prop：必需。需定义或修改的属性的名字</p></li><li><p>descriptor：必需。目标属性所拥有的特性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(对象，修改或新增的属性名，&#123;
		value:修改或新增的属性的值,
		writable:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>,<span class="hljs-comment">//如果值为false 不允许修改这个属性值</span>
		enumerable: <span class="hljs-literal">false</span>,<span class="hljs-comment">//enumerable 如果值为false 则不允许遍历</span>
        configurable: <span class="hljs-literal">false</span>  <span class="hljs-comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span>
&#125;)</code></pre></div></li></ul></li></ul><h2 id="6-函数进阶"><a href="#6-函数进阶" class="headerlink" title="6.函数进阶"></a>6.函数进阶</h2><h3 id="6-1函数的定义和调用"><a href="#6-1函数的定义和调用" class="headerlink" title="6.1函数的定义和调用"></a>6.1函数的定义和调用</h3><ul><li>函数的定义方式</li></ul><ol><li>函数声明方式 function 关键字 (命名函数)</li><li>函数表达式 (匿名函数)</li><li>new Function()<br>var fn = new Function(‘参数1’,’参数2’…, ‘函数体’)<ul><li>Function 里面参数都必须是字符串格式</li><li>第三种方式执行效率低，也不方便书写，因此较少使用</li><li>所有函数都是 Function 的实例(对象)</li><li>函数也属于对象</li></ul></li></ol><ul><li>函数的调用方式</li></ul><ol><li><p>普通函数</p></li><li><p>对象的方法</p></li><li><p>构造函数</p></li><li><p>绑定事件函数</p></li><li><p>定时器函数</p></li><li><p>立即执行函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/* 1. 普通函数 */</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);
&#125;
 fn(); 
<span class="hljs-comment">/* 2. 对象的方法 */</span>
<span class="hljs-keyword">var</span> o = &#123;
  sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
  	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);
  &#125;
&#125;
o.sayHi();
<span class="hljs-comment">/* 3. 构造函数*/</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;
<span class="hljs-keyword">new</span> Star();
<span class="hljs-comment">/* 4. 绑定事件函数*/</span>
 btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;   <span class="hljs-comment">// 点击了按钮就可以调用这个函数</span>
<span class="hljs-comment">/* 5. 定时器函数*/</span>
setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">1000</span>);  这个函数是定时器自动<span class="hljs-number">1</span>秒钟调用一次
<span class="hljs-comment">/* 6. 立即执行函数(自调用函数)*/</span>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);
&#125;)();</code></pre></div></li></ol><h3 id="6-2-函数内部的this的指向"><a href="#6-2-函数内部的this的指向" class="headerlink" title="6.2 函数内部的this的指向"></a>6.2 函数内部的this的指向</h3><p>this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同,一般指向我们的调用者.</p><p><img src="https://img-blog.csdnimg.cn/20200613101447726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>改变函数内部 this 指向的三种方法</p><ul><li><p><strong>call 方法</strong><br>call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。<br><code>fun.call(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg：在 fun 函数运行时指定的 this 值</li><li>arg1，arg2：传递的其他参数</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call</li><li>应用场景: 经常做继承.</li></ul></li><li><p><strong>apply 方法</strong><br>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。<br><code>fun.apply(thisArg, [argsArray])</code></p><ul><li>thisArg：在fun函数运行时指定的 this 值</li><li>argsArray：传递的值，必须包含在数组里面</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li></ul></li><li><p><strong>bind 方法</strong><br>bind() 方法不会调用函数，但是能改变函数内部this 指向。返回的是原函数改变this之后产生的新函数<br><code>fun.bind(thisArg, arg1, arg2, ...)</code></p><ul><li><p>thisArg：在 fun 函数运行时指定的 this 值</p></li><li><p>arg1，arg2：传递的其他参数</p></li><li><p>返回由指定的 this 值和初始化参数改造的原函数拷贝</p></li><li><p>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123;
 name: <span class="hljs-string">'andy'</span>
 &#125;;

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;
	<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);
	<span class="hljs-built_in">console</span>.log(a + b);
&#125;;
<span class="hljs-keyword">var</span> f = fn.bind(o, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//此处的f是bind返回的新函数</span>
f();<span class="hljs-comment">//调用新函数  this指向的是对象o 参数使用逗号隔开</span></code></pre></div></li></ul></li></ul><p><strong>call、apply、bind三者的异同</strong></p><ul><li>共同点 : 都可以改变this指向</li><li>不同点:<ul><li>call 和 apply 会调用函数, 并且改变函数内部this指向.</li><li>call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</li><li>bind 不会调用函数, 可以改变函数内部this指向.</li></ul></li></ul><ul><li>应用场景<ol><li>call 经常做继承.</li><li>apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</li><li>bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</li></ol></li></ul><h2 id="7-严格模式"><a href="#7-严格模式" class="headerlink" title="7.严格模式"></a>7.严格模式</h2><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p><p>严格模式对正常的 JavaScript 语义做了一些更改：</p><p>1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</p><p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p><p>3.提高编译器效率，增加运行速度。</p><p>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p><ul><li><p>开启严格模式</p><ul><li><p>为脚本开启严格模式</p><p>有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他<br>script 脚本文件。为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。</p></li><li><p>为函数开启严格模式<br>要给某个函数开启严格模式，需要把“use strict”; (或 ‘use strict’; ) 声明放在函数体所有语句之前。</p></li></ul></li><li><p>严格模式中的变化</p><ul><li><p>变量规定<br>① 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。<br>② 严禁删除已经声明变量。</p></li><li><p>this 指向问题<br>① 以前在全局作用域函数中的 this 指向 window 对象。严格模式下全局作用域中函数中的 this 是 undefined。</p><p>②以前构造函数时不加new也可以调用,当普通函数，this指向全局对象。严格模式下,如果构造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错</p><p>③ new 实例化的构造函数指向创建的对象实例。<br>④ 定时器 this 还是指向 window 。</p><p>⑤ 事件、对象还是指向调用者。</p></li><li><p>函数变化<br>① 函数不能有重名的参数。</p><p>② 函数必须声明在顶层.新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。</p></li></ul></li></ul><h2 id="8-高阶函数"><a href="#8-高阶函数" class="headerlink" title="8.高阶函数"></a>8.高阶函数</h2><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><h2 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9.闭包"></a>9.闭包</h2><p>闭包（closure）是一个函数 （一个作用域可以访问另外一个函数内部的局部变量。 ）</p><p>作用：延伸变量的作用范围</p><div class="hljs"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;
   <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;
   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;
       <span class="hljs-built_in">console</span>.log(num);
 	&#125;
    <span class="hljs-keyword">return</span> fun;
 &#125;
<span class="hljs-keyword">var</span> f = fn();
f();</code></pre></div><h2 id="10-递归"><a href="#10-递归" class="headerlink" title="10.递归"></a>10.递归</h2><p>一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己<br><strong>注意：</strong>递归函数的作用和循环效果一样,由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n</span>
 <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;
     <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//结束条件</span>
       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
     &#125;
     <span class="hljs-keyword">return</span> n * fn(n - <span class="hljs-number">1</span>);
 &#125;
 <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">3</span>));</code></pre></div><h2 id="11-正则表达式"><a href="#11-正则表达式" class="headerlink" title="11.正则表达式"></a>11.正则表达式</h2><h3 id="11-1概述"><a href="#11-1概述" class="headerlink" title="11.1概述"></a>11.1概述</h3><p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(<strong>匹配</strong>)。此外，正则表达式还常用于过滤掉页面内容中的一 些敏感词(<strong>替换</strong>)，或从字符串中获取我们想要的特定部分(<strong>提取</strong>)等 。</p><p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p><h3 id="11-2基本使用"><a href="#11-2基本使用" class="headerlink" title="11.2基本使用"></a>11.2基本使用</h3><ul><li><p>创建正则表达式</p><p>在 JavaScript 中，可以通过两种方式创建一个正则表达式。</p><p>方式一：通过调用RegExp对象的构造函数创建</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);
<span class="hljs-built_in">console</span>.log(regexp);</code></pre></div><p>方式二：利用字面量创建 正则表达式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/123/</span>;</code></pre></div></li><li><p>测试正则表达式 test</p><p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。<br><code>regexObj.test(str)</code></p><ul><li>regexObj 是写的正则表达式</li><li>str 我们要测试的文本</li></ul></li></ul><h3 id="11-3特殊字符"><a href="#11-3特殊字符" class="headerlink" title="11.3特殊字符"></a>11.3特殊字符</h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ ,其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p><p>特殊字符非常多，可以参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">MDN</a></p><p>jQuery 手册：正则表达式部分 <a href="<http://tool.oschina.net/regex">正则测试工具</a></p><ul><li><p>边界符</p><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本（以谁开始）</td></tr><tr><td>$</td><td>表示匹配行尾的文本（以谁结束）</td></tr></tbody></table><p>如果 ^和 $ 在一起，表示必须是精确匹配。</p></li><li><p>字符类</p><p>表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p><ul><li><p>[] 方括号<br><code>/[abc]/.test(&#39;andy&#39;)</code><br>后面的字符串只要包含 abc 中任意一个字符，都返回 true 。</p></li><li><p>[-] 方括号内部范围符-</p><p><code>/^[a-z]$/.test(c&#39;)</code><br>方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。</p></li><li><p>[^] 方括号内部 取反符^<br><code>/[^abc]/.test(&#39;andy&#39;)</code><br>方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。</p></li><li><p>字符组合<br><code>/[a-z1-9]/.test(&#39;andy&#39;)</code><br>方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。</p></li></ul></li><li><p>量词符</p><p>量词符用来设定某个模式出现的次数。</p><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或更多次</td></tr><tr><td>+</td><td>重复1次或更多次</td></tr><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table></li><li><p>括号总结</p><ul><li>大括号量词符. 里面表示重复次数</li><li>中括号字符集合。匹配方括号中的任意字符.</li><li>小括号 表示优先级</li></ul></li><li><p>预定义类</p><p>预定义类指的是某些常见模式的简写方式。</p><p><img src="https://img-blog.csdnimg.cn/20200613110614915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="11-4正则替换replace"><a href="#11-4正则替换replace" class="headerlink" title="11.4正则替换replace"></a>11.4正则替换replace</h3><ul><li><p>replace 替换</p><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。<br><code>stringObject.replace(regexp/substr,replacement)</code></p><ul><li><p>第一个参数: 被替换的字符串 或者 正则表达式</p></li><li><p>第二个参数: 替换为的字符串</p><p>返回值是一个替换完毕的新字符串</p></li></ul></li><li><p>正则表达式参数</p><p><code>/表达式/[switch]</code><br>switch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：</p><ul><li>g：全局匹配</li><li>i：忽略大小写</li><li>gi：全局匹配 + 忽略大小写</li></ul></li></ul><h2 id="12-ES6"><a href="#12-ES6" class="headerlink" title="12.ES6"></a>12.ES6</h2><h3 id="12-1新增语法"><a href="#12-1新增语法" class="headerlink" title="12.1新增语法"></a>12.1新增语法</h3><ul><li><p><strong>let</strong></p><p>ES6中新增的用于声明变量的关键字。</p><ul><li><p><strong>let声明的变量只在所处于的块级有效</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
<span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>; &#125;
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span>
注意：使用<span class="hljs-keyword">let</span>关键字声明的变量才具有块级作用域，使用<span class="hljs-keyword">var</span>声明的变量不具备块级作用域特性。</code></pre></div></li><li><p><strong>不存在变量提升</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// a is not defined </span>
<span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;</code></pre></div></li><li><p><strong>暂时性死区</strong></p><p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;
<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123; 
    tmp = <span class="hljs-string">'abc'</span>;
    <span class="hljs-keyword">let</span> tmp; 
&#125;</code></pre></div></li></ul><p>经典面试题</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;
    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(i); 
    &#125;
&#125;
arr[<span class="hljs-number">0</span>]();<span class="hljs-comment">//2</span>
arr[<span class="hljs-number">1</span>]();<span class="hljs-comment">//2</span></code></pre></div><p>此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];
<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;
    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;
        <span class="hljs-built_in">console</span>.log(i); 
    &#125;
&#125;
arr[<span class="hljs-number">0</span>]();<span class="hljs-comment">//0</span>
arr[<span class="hljs-number">1</span>]();<span class="hljs-comment">//1</span></code></pre></div><p>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p><p><strong>小结</strong></p><ul><li>let关键字就是用来声明变量的</li><li>使用let关键字声明的变量具有块级作用域</li><li>防止循环变量变成全局变量</li><li>使用let关键字声明的变量没有变量提升</li><li>使用let关键字声明的变量具有暂时性死区特性</li></ul></li><li><p><strong>const</strong></p><p>作用：声明常量，常量就是值（内存地址）不能变化的量</p><ul><li><p>具有块级作用域</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;
<span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>; &#125;
<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span></code></pre></div></li><li><p>声明常量时必须赋值</p></li><li><p>常量赋值后，值不能修改。</p></li></ul><p><strong>小结</strong></p><ul><li>const声明的变量是一个常量</li><li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li><li>声明 const时候必须要给定值</li></ul></li><li><p><strong>let、const、var 的区别</strong></p><ul><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</li><li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</li><li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</li></ul></li></ul><h3 id="12-2解构赋值"><a href="#12-2解构赋值" class="headerlink" title="12.2解构赋值"></a>12.2解构赋值</h3><p>按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><div class="hljs"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
 <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//1</span>
 <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//2</span>
 <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//3</span>
<span class="hljs-comment">//如果解构不成功，变量的值为undefined</span></code></pre></div><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'zhangsan'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;; 
<span class="hljs-keyword">let</span> &#123; name, age &#125; = person;
<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 'zhangsan' </span>
<span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 20</span>

<span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span>
<span class="hljs-built_in">console</span>.log(myName); <span class="hljs-comment">// 'zhangsan' </span>
<span class="hljs-built_in">console</span>.log(myAge); <span class="hljs-comment">// 20</span></code></pre></div><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>解构赋值就是把数据结构分解，然后给变量进行赋值</li><li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li></ul><h3 id="12-3箭头函数"><a href="#12-3箭头函数" class="headerlink" title="12.3箭头函数"></a>12.3箭头函数</h3><p>ES6中新增的定义函数的方式。</p><div class="hljs"><pre><code class="hljs javascript">() =&gt; &#123;&#125; <span class="hljs-comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span>
<span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<span class="hljs-comment">//代表把一个函数赋值给fn</span></code></pre></div><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123; 
    <span class="hljs-keyword">return</span> num1 + num2; 
&#125;
<span class="hljs-comment">//es6写法</span>
<span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2;</code></pre></div><p>如果形参只有一个，可以省略小括号</p><div class="hljs"><pre><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;
     <span class="hljs-keyword">return</span> v;
 &#125; 
<span class="hljs-comment">//es6写法</span>
 <span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;</code></pre></div><p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>&#125; 
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123; 
     <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//this 指向 是obj对象</span>
     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; 
         <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span>
     &#125; 
 &#125; 
 <span class="hljs-keyword">const</span> resFn = fn.call(obj); 
 resFn();</code></pre></div><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li><li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;

<span class="hljs-keyword">var</span> obj = &#123;
	age: <span class="hljs-number">20</span>,
	say: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;
		alert(<span class="hljs-keyword">this</span>.age)
	&#125;
&#125;

obj.say();<span class="hljs-comment">//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域</span></code></pre></div><h3 id="12-4剩余参数"><a href="#12-4剩余参数" class="headerlink" title="12.4剩余参数"></a>12.4剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;
     <span class="hljs-built_in">console</span>.log(first); <span class="hljs-comment">// 10</span>
     <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">// [20, 30] </span>
 &#125;
 sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</code></pre></div><h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">'wangwu'</span>, <span class="hljs-string">'zhangsan'</span>, <span class="hljs-string">'lisi'</span>];
<span class="hljs-keyword">let</span> [s1, ...s2] = students; 
<span class="hljs-built_in">console</span>.log(s1);  <span class="hljs-comment">// 'wangwu' </span>
<span class="hljs-built_in">console</span>.log(s2);  <span class="hljs-comment">// ['zhangsan', 'lisi']</span></code></pre></div><h3 id="12-5ES6-的内置对象扩展"><a href="#12-5ES6-的内置对象扩展" class="headerlink" title="12.5ES6 的内置对象扩展"></a>12.5ES6 的内置对象扩展</h3><ul><li><p>Array 的扩展方法</p><ul><li><p><strong>扩展运算符（展开语法）</strong></p><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
...ary  <span class="hljs-comment">// 1, 2, 3</span>
<span class="hljs-built_in">console</span>.log(...ary);    <span class="hljs-comment">// 1 2 3,相当于下面的代码</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);</code></pre></div><p>扩展运算符可以应用于合并数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法一 </span>
 <span class="hljs-keyword">let</span> ary1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];
 <span class="hljs-keyword">let</span> ary2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];
 <span class="hljs-keyword">let</span> ary3 = [...ary1, ...ary2];
 <span class="hljs-comment">// 方法二 </span>
 ary1.push(...ary2);</code></pre></div><p>将类数组或可遍历对象转换为真正的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oDivs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'div'</span>); 
oDivs = [...oDivs];</code></pre></div></li><li><p><strong>构造函数方法：Array.from()</strong></p><p>将伪数组或可遍历对象转换为真正的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个集合</span>
<span class="hljs-keyword">let</span> arrayLike = &#123;
    <span class="hljs-string">'0'</span>: <span class="hljs-string">'a'</span>,
    <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span>,
    <span class="hljs-string">'2'</span>: <span class="hljs-string">'c'</span>,
    length: <span class="hljs-number">3</span>
&#125;; 
<span class="hljs-comment">//转成数组</span>
<span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// ['a', 'b', 'c']</span></code></pre></div><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123; 
    <span class="hljs-string">"0"</span>: <span class="hljs-number">1</span>,
    <span class="hljs-string">"1"</span>: <span class="hljs-number">2</span>,
    <span class="hljs-string">"length"</span>: <span class="hljs-number">2</span>
&#125;
<span class="hljs-keyword">let</span> newAry = <span class="hljs-built_in">Array</span>.from(arrayLike, item =&gt; item *<span class="hljs-number">2</span>)<span class="hljs-comment">//[2,4]</span></code></pre></div><p>注意：如果是对象，那么属性需要写对应的索引</p></li><li><p>实例方法：find()</p><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;
     id: <span class="hljs-number">1</span>,
     name: <span class="hljs-string">'张三'</span>
 &#125;, &#123; 
     id: <span class="hljs-number">2</span>,
     name: <span class="hljs-string">'李四'</span>
 &#125;]; 
 <span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>);<span class="hljs-comment">//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</span></code></pre></div></li><li><p>实例方法：findIndex()</p><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];
<span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>); 
<span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 2</span></code></pre></div></li><li><p>实例方法：includes()</p><p>判断某个数组是否包含给定的值，返回布尔值。</p><div class="hljs"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true </span>
[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span></code></pre></div></li></ul></li><li><p>String 的扩展方法</p><ul><li><p>模板字符串</p><p>ES6新增的创建字符串的方式，使用反引号定义</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;</code></pre></div><p>模板字符串中可以解析变量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'张三'</span>; 
<span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// hello, my name is zhangsan</span></code></pre></div><p>模板字符串中可以换行</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = &#123; 
    name: <span class="hljs-string">'zhangsan'</span>, 
    age: <span class="hljs-number">20</span>,
    sex: <span class="hljs-string">'男'</span> 
&#125; 
<span class="hljs-keyword">let</span> html = <span class="hljs-string">` &lt;div&gt;</span>
<span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span>
<span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span>
<span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span>
<span class="hljs-string">&lt;/div&gt; `</span>;</code></pre></div><p>在模板字符串中可以调用函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123; 
    <span class="hljs-keyword">return</span> <span class="hljs-string">'哈哈哈哈 追不到我吧 我就是这么强大'</span>;
 &#125;; 
 <span class="hljs-keyword">let</span> greet = <span class="hljs-string">`<span class="hljs-subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>;
 <span class="hljs-built_in">console</span>.log(greet); <span class="hljs-comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></code></pre></div></li><li><p>实例方法：startsWith() 和 endsWith()<br>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值<br>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p></li><li><p>实例方法：repeat()<br>repeat方法表示将原字符串重复n次，返回一个新字符串。</p></li></ul></li><li><p>Set 数据结构</p><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成 Set 数据结构</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</code></pre></div><p>Set函数可以接受一个数组作为参数，用来初始化。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">set</span> = new Set([1, 2, 3, 4, 4]);//&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</code></pre></div><p><strong>实例方法</strong></p><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();
s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向 set 结构中添加值 </span>
s.delete(<span class="hljs-number">2</span>)             <span class="hljs-comment">// 删除 set 结构中的2值   </span>
s.has(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 表示 set 结构中是否有1这个值 返回布尔值 </span>
s.clear()               <span class="hljs-comment">// 清除 set 结构中的所有值</span>
<span class="hljs-comment">//注意：删除的是元素的值，不是代表的索引</span></code></pre></div><p><strong>遍历</strong></p><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><div class="hljs"><pre><code class="hljs javascript">s.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value))</code></pre></div></li></ul></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/JS/">JS</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/JS/">JS</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/2020/06/16/Vue%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">Vue模块化开发——学习笔记三</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/2020/06/09/WebAPI%E2%80%94%E2%80%94%E7%BD%91%E9%A1%B5%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"><span class="hidden-mobile">WebAPI——网页、移动端特效和本地存储</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div>©2020 By TQ</div><div>Power by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><p id="hitokoto">获取中...</p></footer><style>#hitokoto{text-align:center;color:#fff;background-color:rgba(10,10,10,.8);margin-bottom:0;padding:10px 0}</style><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","JavaScript高级&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>!function(e,r,t){var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},function e(){for(var t=0;t<n.length;t++)n[t].alpha<=0?(r.body.removeChild(n[t].el),n.splice(t,1)):(n[t].y--,n[t].scale+=.004,n[t].alpha-=.013,n[t].el.style.cssText="left:"+n[t].x+"px;top:"+n[t].y+"px;opacity:"+n[t].alpha+";transform:scale("+n[t].scale+","+n[t].scale+") rotate(45deg);background:"+n[t].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script>var now = new Date();
  function createtime(){
      var grt= new Date("05/27/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  fetch('https://v1.hitokoto.cn/')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script></body></html>