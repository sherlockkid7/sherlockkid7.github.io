<!DOCTYPE html><html lang="zh-CN"><head><meta charset="UTF-8"><link rel="apple-touch-icon" sizes="76x76" href="/img/apple-touch-icon.png"><link rel="icon" type="image/png" href="/img/favicon.png"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,shrink-to-fit=no"><meta http-equiv="x-ua-compatible" content="ie=edge"><meta name="theme-color" content="rgba(10,10,10,.7)"><meta name="description" content=""><meta name="author" content="tq"><meta name="keywords" content=""><title>JavaScript基础语法 - TQ个人博客</title><link rel="stylesheet" href="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/css/bootstrap.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/github-markdown-css/4.0.0/github-markdown.min.css"><link rel="stylesheet" href="https://cdn.staticfile.org/highlight.js/10.0.0/styles/tomorrow-night.min.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_fmb4a04yx8h.css"><link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_pjno9b9zyxs.css"><link rel="stylesheet" href="/css/main.css"><meta name="generator" content="Hexo 4.2.1"></head><body><header style="height:70vh"><nav id="navbar" class="navbar fixed-top navbar-expand-lg navbar-dark scrolling-navbar"><div class="container"><a class="navbar-brand" href="/">&nbsp;<strong>TQ个人博客</strong>&nbsp;</a> <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse" data-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation"><div class="animated-icon"><span></span><span></span><span></span></div></button><div class="collapse navbar-collapse" id="navbarSupportedContent"><ul class="navbar-nav ml-auto text-center"><li class="nav-item"><a class="nav-link" href="/"><i class="iconfont icon-home-fill"></i> 首页</a></li><li class="nav-item"><a class="nav-link" href="/archives/"><i class="iconfont icon-archive-fill"></i> 归档</a></li><li class="nav-item"><a class="nav-link" href="/categories/"><i class="iconfont icon-category-fill"></i> 分类</a></li><li class="nav-item"><a class="nav-link" href="/tags/"><i class="iconfont icon-tags-fill"></i> 标签</a></li><li class="nav-item"><a class="nav-link" href="/about/"><i class="iconfont icon-user-fill"></i> 关于</a></li><li class="nav-item"><a class="nav-link" href="/links/"><i class="iconfont icon-link-fill"></i> 友链</a></li><li class="nav-item" id="search-btn"><a class="nav-link" data-toggle="modal" data-target="#modalSearch">&nbsp;&nbsp;<i class="iconfont icon-search"></i>&nbsp;&nbsp;</a></li></ul></div></div></nav><div class="view intro-2" id="background" parallax="true" style="background:url(/img/post.png) no-repeat center center;background-size:cover"><div class="full-bg-img"><div class="mask flex-center" style="background-color:rgba(0,0,0,.3)"><div class="container text-center white-text fadeInUp"><span class="h2" id="subtitle"></span><div class="mt-3 post-meta"><i class="iconfont icon-date-fill" aria-hidden="true"></i> <time datetime="2020-06-03 09:55">2020年6月3日 上午</time></div><div class="mt-1"><span class="post-meta mr-2"><i class="iconfont icon-chart"></i> 7.2k 字 </span><span class="post-meta mr-2"><i class="iconfont icon-clock-fill"></i> 78 分钟</span></div></div></div></div></div></header><main><div class="container-fluid"><div class="row"><div class="d-none d-lg-block col-lg-2"></div><div class="col-lg-8 nopadding-md"><div class="container nopadding-md" id="board-ctn"><div class="py-5" id="board"><div class="post-content mx-auto" id="post"><article class="markdown-body"><p><img src="https://img-blog.csdnimg.cn/20200602233705724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>JS 脚本语言–编程类语言</strong></p><p>一种运行在客户端的脚本语言 （Script 是脚本的意思）<br>作用：实现业务逻辑和页面控制( 决定功能 )</p><p><strong>浏览器怎么执行 JS</strong></p><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）<br><strong>渲染引擎</strong>：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit<br><strong>JS 引擎</strong>：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8<br>浏览器本身并不会执行JS代码，而是通过内置 JS 引擎来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行</p><h2 id="JS-的组成"><a href="#JS-的组成" class="headerlink" title="JS 的组成"></a>JS 的组成</h2><h3 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1.ECMAScript"></a>1.ECMAScript</h3><p>JS是 ECMAScript 语言的实现和扩展，ECMAScript 规定了JS的编程语法和基础核心知识</p><h3 id="2-DOM（页面文档对象模型）"><a href="#2-DOM（页面文档对象模型）" class="headerlink" title="2.DOM（页面文档对象模型）"></a>2.DOM（页面文档对象模型）</h3><p>是W3C组织推荐的处理可扩展标记语言的标准编程接口。<br>通过 DOM 提供的接口可以对页面上的各种元素进行操作</p><h3 id="3-BOM（浏览器对象模型）"><a href="#3-BOM（浏览器对象模型）" class="headerlink" title="3.BOM（浏览器对象模型）"></a>3.BOM（浏览器对象模型）</h3><p>它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。<br>通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>通俗：变量是用于存放数据的容器<br>本质：变量是程序在内存中申请的一块用来存放数据的空间</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>1.声明变量<br><code>var age; // 声明一个 名称为age 的变量</code><br><strong>var</strong> 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间<br><strong>age</strong> 是定义的变量名，我们要通过变量名来访问内存中分配的空间</p><p>2.赋值<br><code>age = 10; // 给 age 这个变量赋值为 10</code><br><strong>=</strong> 用来把右边的值赋给左边的变量空间中<br>变量值是保存到变量空间里的值<br>3.变量的初始化<br><code>var age = 18; // 声明变量同时赋值为 18</code><br><strong>声明一个变量并赋值， 我们称之为变量的初始化。</strong></p><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ol><li>必须以字母(A-Za-z)、下划线(_)、美元符号( $ )开头，后续的字符也可以是数字（0-9）。如：usrAge, num01, _name</li><li>严格区分大小写。var app; 和 var App; 是两个变量</li><li>不能以数字开头。 18age 是错误的</li><li>不能是关键字、保留字。例如：var、for、while</li><li>变量名必须有意义。</li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="8种数据类型"><a href="#8种数据类型" class="headerlink" title="8种数据类型"></a>8种数据类型</h3><ul><li><p>基本数据类型（值类型/简单数据类型）</p><p>在存储时变量中存储的是值本身,值类型变量的数据直接存放在变量（<strong>栈空间</strong>）中</p><p><strong>简单类型传参</strong><br>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><ul><li><p>Number</p><p>既可以用来保存整数值，也可以保存小数(浮点数）<br>数字型三个特殊值</p><div class="hljs"><pre><code class="hljs js">alert(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity </span>
alert(-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// -Infinity </span>
alert(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// NaN</span></code></pre></div><p>Infinity ，代表无穷大，大于任何数值<br>-Infinity ，代表无穷小，小于任何数值<br>NaN ，Not a number，代表一个非数值<br><strong>isNaN()</strong> 用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li><li><p>String</p><p>字符串型是一串表示文本值的字符序列，其语法为 双引号 “” 和 单引号’’</p><p>因为 <strong>HTML 标签</strong>里面的属性使用的是<strong>双引号</strong>，<strong>JS</strong> 这里我们更推荐使用<strong>单引号</strong>。</p><p>字符串引号嵌套<br>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)<br><strong>字符串转义符</strong><br>转义符都是 \ 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n 是 newline 的意思</td></tr><tr><td>\ \</td><td>斜杠 \</td></tr><tr><td>&#39;</td><td>‘ 单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b 是 blank 的意思</td></tr></tbody></table><p>字符串长度<br>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <strong>length</strong> 属性可以获取整个字符 串的长度。<br><strong>字符串拼接</strong><br>多个字符串之间可以使用 <strong>+</strong> 进行拼接，其拼接方式为 <strong>字符串 + 任何类型 = 拼接之后的新字符串</strong><br>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1.1 字符串 "相加" </span>
alert(<span class="hljs-string">'hello'</span> + <span class="hljs-string">' '</span> + <span class="hljs-string">'world'</span>); <span class="hljs-comment">// hello world </span>
<span class="hljs-comment">//1.2 数值字符串 "相加" </span>
alert(<span class="hljs-string">'100'</span> + <span class="hljs-string">'100'</span>); <span class="hljs-comment">// 100100 </span>
<span class="hljs-comment">//1.3 数值字符串 + 数值 </span>
alert(<span class="hljs-string">'11'</span> + <span class="hljs-number">12</span>); <span class="hljs-comment">// 1112</span></code></pre></div><p>口诀：数值相加 ，字符相连<br><strong>字符串拼接加强</strong><br>我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值<br><strong>变量是不能添加引号的，因为加引号的变量会变成字符串</strong><br>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</p></li><li><p>Boolean<br>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。<br>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2 </span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span></code></pre></div></li><li><p>Undefined</p><p>undefined表示“缺少值”，此处应该有一个值，只是声明后没有被赋值</p></li><li><p>Null</p><p>表示“没有对象”，即该处里面存的值为空</p></li><li><p>BigInt</p><p>是一种数字数据类型，可以以任意精度格式表示整数</p></li><li><p>Symbol</p><p>Symbol可以用来创建唯一常量</p></li></ul></li><li><p>引用类型/复杂数据类型：对象（Object）</p><p>在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型</p><p>通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</p><p><strong>引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</strong></p><p><strong>复杂类型传参</strong></p><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p></li></ul><h3 id="获取变量数据类型"><a href="#获取变量数据类型" class="headerlink" title="获取变量数据类型"></a>获取变量数据类型</h3><ul><li>typeof 检测变量的数据类型，返回一个字符串</li><li>字面量是脚本中按字面意思给出的固定的值，而不是变量。（译注：字面量是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false，3.1415</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。</p><ul><li><p>转换为字符串</p><p><strong>toString()</strong><br><code>var num= 1；num.toString()；</code><br>String() 强制转化<br><code>var num =1;String(num);</code><br><strong>加号拼接字符串</strong><br>和字符串拼接的结果都是字符串<br>三种转换方式，第三种加号拼接字符串转换方式也称之为<strong>隐式转换</strong>。</p></li><li><p>转换为数字型（重点）</p><p><strong>1.parseInt()</strong><br>将string类型转成<strong>整数数值型</strong><br><strong>2.parseFloat()</strong><br>将string类型转成<strong>浮点数数值型</strong><br>3.Number()强制转换函数<br>将string类型转成数值型<br>4.js隐式转化（- * /）<br>利用算术运算隐式转换成数值型<br>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</p></li><li><p>转换为布尔型</p><p>Boolean()函数 其它类型转换成布尔值<br>代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined ,其余值都会被转换为 true</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算使用的符号，用于执行两个变量或值的算术运算</p><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>前置递增运算符<br><strong>++num</strong> 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。<br>使用口诀：<strong>先自加，后返回值</strong><br>后置递增运算符<br><strong>num++</strong> 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。<br>使用口诀：<strong>先返回原值，后自加</strong></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值</p><ul><li><p>逻辑与 <strong>&amp;&amp;</strong><br>两边都是 true才返回 true，否则返回 false</p></li><li><p>逻辑或 <strong>||</strong><br>两边都为 false 才返回 false，否则都为true</p></li><li><p>逻辑非 <strong>！</strong><br>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p></li><li><p>短路运算（逻辑中断）<br>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p><ul><li><p>逻辑与<br> 语法： 表达式1 &amp;&amp; 表达式2<br> 如果第一个表达式的值为真，则返回表达式2<br> 如果第一个表达式的值为假，则返回表达式1</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 0 </span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>&amp;&amp; <span class="hljs-number">789</span> ); <span class="hljs-comment">// 789</span></code></pre></div></li><li><p>逻辑或<br> 语法： 表达式1 || 表达式2<br> 如果第一个表达式的值为真，则返回表达式1<br> 如果第一个表达式的值为假，则返回表达式2</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 123 </span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span>
<span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> || <span class="hljs-number">789</span> ); <span class="hljs-comment">// 123</span></code></pre></div></li></ul></li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>用来把数据赋值给变量的运算符。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制就是来控制我们的代码按照什么结构顺序来执行</p><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果<br><strong>if 语句</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立执行代码，否则什么也不做 </span>
<span class="hljs-keyword">if</span> (条件表达式) &#123; 
<span class="hljs-comment">// 条件成立执行的代码语句 </span>
&#125;</code></pre></div><p>语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，<br><strong>if else语句（双分支语句）</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立 执行 if 里面代码，否则执行else 里面的代码 </span>
<span class="hljs-keyword">if</span> (条件表达式) &#123; 
<span class="hljs-comment">// [如果] 条件成立执行的代码 </span>
&#125; <span class="hljs-keyword">else</span> &#123; 
<span class="hljs-comment">// [否则] 执行的代码 </span>
&#125;</code></pre></div><p><strong>if else if 语句(多分支语句)</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 适合于检查多重条件。 </span>
<span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123; 
语句<span class="hljs-number">1</span>； 
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123; 
语句<span class="hljs-number">2</span>； 
&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123; 
语句<span class="hljs-number">3</span>； 
.... 
&#125; <span class="hljs-keyword">else</span> &#123; 
<span class="hljs-comment">// 上述条件都不成立执行此处代码 </span>
&#125;</code></pre></div><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式</p><ol><li>语法结构<br>表达式1 ? 表达式2 : 表达式3;</li><li>执行思路<ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于 if else （双分支） 的简写</li></ul></li></ol><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句也是多分支语句，它用于基于<strong>不同的条件来执行不同的代码</strong>。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>( 表达式 )&#123; 
<span class="hljs-keyword">case</span> value1: 
<span class="hljs-comment">// 表达式 等于 value1 时要执行的代码 </span>
<span class="hljs-keyword">break</span>; 
<span class="hljs-keyword">case</span> value2: 
<span class="hljs-comment">// 表达式 等于 value2 时要执行的代码 </span>
<span class="hljs-keyword">break</span>; 
<span class="hljs-keyword">default</span>: 
<span class="hljs-comment">// 表达式 不等于任何一个 value 时要执行的代码 </span>
&#125;</code></pre></div><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3><h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">while</span>语句的语法结构如下：
<span class="hljs-keyword">while</span> (条件表达式) &#123;
  <span class="hljs-comment">// 循环体代码 </span>
&#125;</code></pre></div><p>执行思路：</p><ol><li><p>先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</p></li><li><p>执行循环体代码</p></li><li><p>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</p><p>注意：使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</p></li></ol><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3.do-while循环"></a>3.do-while循环</h3><p>do… while 语句的语法结构如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;
  <span class="hljs-comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span>
&#125; <span class="hljs-keyword">while</span>(条件表达式);</code></pre></div><p>执行思路:</p><ol><li>先执行一次循环体代码</li><li>再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码<br>注意：<strong>先再执行循环体，再判断</strong>，do…while循环语句至少会执行一次循环体代码</li></ol><h3 id="continue、break"><a href="#continue、break" class="headerlink" title="continue、break"></a>continue、break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。<br>break 关键字用于立即跳出整个循环（循环结束）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul><li><p>new 创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 数组名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() ； 
<span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">// 创建一个新的空数组</span></code></pre></div><p>注意 Array () ，A 要大写</p></li><li><p>数组字面量创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1. 使用数组字面量方式创建空的数组 </span>
<span class="hljs-keyword">var</span> 数组名 = []； 
<span class="hljs-comment">//2. 使用数组字面量方式创建带初始值的数组 </span>
<span class="hljs-keyword">var</span> 数组名 = [<span class="hljs-string">'小白'</span>,<span class="hljs-string">'小黑'</span>,<span class="hljs-string">'大黄'</span>,<span class="hljs-string">'瑞奇'</span>];</code></pre></div><p> 数组的字面量是方括号 [ ]<br> 声明数组并赋值称为数组的初始化</p></li></ul><h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><p>数组可以通过索引来访问、设置、修改对应的数组元素，我们可以通过“数组名[索引]”的形式来获取数组中的元素。</p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>我们可以通过 for 循环索引遍历数组中的每一项<br><strong>数组的长度</strong> 使用“数组名.length”可以访问数组元素的数量（数组长度）。</p><h3 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h3><p>1.通过修改 length 长度新增数组元素<br>2.通过修改数组索引新增数组元素</p><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]; 
arr[<span class="hljs-number">4</span>] = <span class="hljs-string">'hotpink'</span>; 
<span class="hljs-built_in">console</span>.log(arr);</code></pre></div><p>这种方式也是我们最常用的一种方式。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数：就是封装了一段可被重复调用执行的代码块</p><h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><ul><li><p>声明函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>&#123; 
<span class="hljs-comment">//函数体代码 </span>
&#125;</code></pre></div><p> function 是声明函数的关键字,必须小写<br> 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p></li><li><p>调用函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 调用函数 </span>
函数名(); <span class="hljs-comment">// 通过调用函数名来执行函数体代码</span></code></pre></div><p> 调用的时候千万不要忘记添加小括号<br> 口诀：函数不调用，自己不执行。<br>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p></li></ul><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p><strong>形参和实参</strong><br>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时,同样也需要传递相应的参数，这些参数被称为实参。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 带参数的函数声明 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2</span> , 形参<span class="hljs-number">3.</span>..</span>) </span>&#123; <span class="hljs-comment">// 可以定义任意多的参数，用逗号分隔 </span>
<span class="hljs-comment">// 函数体 </span>
&#125; 
<span class="hljs-comment">// 带参数的函数调用 </span>
函数名(实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2</span>, 实参<span class="hljs-number">3.</span>..);</code></pre></div><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ul><li><p>return 语句</p><p>函数将值返回给调用者，此时通过使用 return 语句就可以实现<br>return 语句的语法格式如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> 函数名（）</span>&#123; 
... 
<span class="hljs-keyword">return</span> 需要返回的值； 
&#125; 
<span class="hljs-comment">// 调用函数 </span>
函数名(); <span class="hljs-comment">// 此时调用函数就可以得到函数体内return 后面的值</span></code></pre></div><p>return 语句之后的代码不被执行<br>return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。</p><p><strong>break ,continue ,return 的区别</strong><br>break ：结束当前的循环体（如 for、while）<br>continue ：跳出本次循环，继续执行下次循环（如 for、while）<br>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</p></li></ul><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。</p><p>所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><p>arguments展示形式是一个<strong>伪数组</strong>，因此可以进行遍历。伪数组具有以下特点：<br> 具有 length 属性<br> 按索引方式储存数据<br> 不具有数组的 push , pop 等方法</p><h3 id="函数的声明方式"><a href="#函数的声明方式" class="headerlink" title="函数的声明方式"></a>函数的声明方式</h3><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明定义方式 </span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;...&#125; 
<span class="hljs-comment">// 调用 </span>
fn();</code></pre></div><p> 因为有名字，所以也被称为命名函数<br> 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</p></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 这是函数表达式写法，匿名函数后面跟分号结束 </span>
<span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;； 
<span class="hljs-comment">// 调用的方式，函数调用必须写到函数体下面 </span>
fn();</code></pre></div><p> 因为函数没有名字，所以也被称为匿名函数<br> 这个fn 里面存储的是一个函数<br> 函数表达式方式原理跟声明变量方式是一致的<br> <strong>函数调用的代码必须写到函数体后面</strong></p></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。</p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块作用域由 { } 包括（es6）</p><h3 id="变量作用域的分类"><a href="#变量作用域的分类" class="headerlink" title="变量作用域的分类"></a>变量作用域的分类</h3><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p><ul><li><p>全局变量</p><ul><li>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</li><li>全局变量在代码的任何位置都可以使用</li><li>特殊情况下，在函数内不使用全局变量（不建议使用）</li></ul></li><li><p>局部变量</p><ul><li>在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</li><li>局部变量只能在该函数内部使用</li><li>函数的形参实际上就是局部变量</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>采取就近原则的方式来查找变量最终的值。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。<br><strong>预解析</strong>：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和function 声明的变量在内存中进行提前声明或者定义。<br><strong>代码执行</strong>： 从上到下执行JS语句。</p><p>预解析也叫做变量（函数）提升。</p><h3 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h3><p>变量提升： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升</p><h3 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h3><p>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。<br><strong>对象是由属性和方法组成的</strong>。<br>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>字面量创建对象</p><p>对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>{ }</strong> 里面采取<strong>键值对</strong>的形式表示<br>键：相当于属性名<br>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p><strong>对象的调用</strong></p><ul><li>对象里面的属性调用 : <strong>对象.属性名</strong></li><li>对象里面属性的另一种调用方式 : <strong>对象[‘属性名’]</strong>，注意方括号里面的属性必须加引号</li><li>对象里面的<strong>方法调用</strong>：<strong>对象.方法名()</strong> ，注意这个方法名字后面一定加括号</li></ul></li><li><p>new Object创建对象</p><p>Object() ：第一个字母大写<br>new Object() ：需要 new 关键字<br>使用格式：对象.属性 = 值;</p></li><li><p>构造函数创建对象</p><p><strong>构造函数</strong> ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起 使用。我们可以把<strong>对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面</strong>。</p><p>在 js 中，使用构造函数要时要注意以下几点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li><li>构造函数中不需要 return 返回结果。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ul><p><strong>构造函数</strong>，如 Stars()，抽象了<strong>对象的公共部分</strong>，<strong>封装</strong>到了<strong>函数</strong>里面，它泛指<strong>某一大类</strong>（class）<br><strong>创建对象</strong>，如 new Stars()，特指<strong>某一个</strong>，通过 new 关键字创建对象的过程也称为<strong>对象实例化</strong></p></li></ul><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>new 在执行时会做四件事情：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要return）。</li></ol><h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p><p>for (变量 in 对象名字) {<br>// 在此执行代码<br>}</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="1-Math-对象"><a href="#1-Math-对象" class="headerlink" title="1.Math 对象"></a>1.Math 对象</h3><p><strong>随机数方法 random()</strong><br>random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1</p><p>案例：得到一个两数之间的随机整数，包括两个数在内</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">min, max</span>) </span>&#123; 
<span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min; 
&#125;</code></pre></div><p><strong>Math 对象不是构造函数</strong>，具有数学常数和函数的属性和方法<br>Math.PI // 圆周率<br><strong>Math.floor()</strong> // 向下取整<br>Math.ceil() // 向上取整<br>Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3<br><strong>Math.abs()</strong> // 绝对值<br><strong>Math.max()/Math.min()</strong> // 求最大和最小值</p><h3 id="2-日期对象"><a href="#2-日期对象" class="headerlink" title="2.日期对象"></a>2.日期对象</h3><ol><li>获取当前时间必须实例化<br>var now = new Date();<br>console.log(now);</li><li>Date() 构造函数的参数<br><strong>如果括号里面有时间，就返回参数里面的时间</strong>。例如日期格式字符串为‘2019-5-1’，可以写成new Date(‘2019-5-1’) 或者 new Date(‘2019/5/1’)<br>如果Date()不写参数，就返回当前时间</li><li>使用Date实例的方法和属性<br><img src="https://img-blog.csdnimg.cn/20200602234800746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>获取日期的总的毫秒形式<br>Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数</li></ol><p><strong>Date 对象</strong>和 Math 对象不一样，<strong>是一个构造函数</strong>，所以<strong>需要实例化</strong>后才能使用<br>Date 实例用来处理日期和时间</p><h3 id="3-数组对象"><a href="#3-数组对象" class="headerlink" title="3.数组对象"></a>3.数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li><p>字面量方式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>,<span class="hljs-literal">true</span>];</code></pre></div></li><li><p>new Array()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</code></pre></div><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li><p>如果只传入一个参数，则参数规定了数组的长度</p></li><li><p>如果传入了多个参数，则参数称为数组的元素</p></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li><p><strong>instanceof 运算符</strong>，可以判断一个对象是否属于某种类型</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];
<span class="hljs-keyword">var</span> obj = &#123;&#125;;
<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span></code></pre></div></li><li><p>Array.isArray()</p><p>用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];
<span class="hljs-keyword">var</span> obj = &#123;&#125;;
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr));   <span class="hljs-comment">// true</span>
<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(obj));   <span class="hljs-comment">// false</span></code></pre></div></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234205992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>数组中有对数组本身排序的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234332535.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：sort方法需要传入参数来设置升序、降序排序</p><ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234519153.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234554828.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><img src="https://img-blog.csdnimg.cn/20200602234613578.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="4-字符串对象"><a href="#4-字符串对象" class="headerlink" title="4.字符串对象"></a>4.字符串对象</h3><ul><li><p>基本包装类型</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><p>js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span>
<span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'andy'</span>);
<span class="hljs-comment">// 2. 赋值给我们声明的字符变量</span>
str = temp;
<span class="hljs-comment">// 3. 销毁临时变量</span>
temp = <span class="hljs-literal">null</span>;</code></pre></div></li><li><p>字符串的不可变</p><ul><li>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</li></ul></li><li><p>根据字符返回位置</p><p>字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235548446.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>根据位置返回字符</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235521853.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>字符串操作方法</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：<br><img src="https://img-blog.csdnimg.cn/20200602235609516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>replace()方法</p><ul><li>replace() 方法用于在字符串中用一些字符替换另一些字符。<br>其使用格式如下：<br><code>replace(被替换的字符串， 要替换为的字符串)；</code></li></ul></li><li><p>split()方法</p><ul><li>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。<br>例如下面代码：<br><code>var str = &#39;a,b,c,d&#39;;</code><br><code>console.log(str.split(&#39;,&#39;)); // 返回的是一个数组 [a, b, c, d]</code></li></ul></li></ul><h2 id="JavaScript-输入输出语句"><a href="#JavaScript-输入输出语句" class="headerlink" title="JavaScript 输入输出语句"></a>JavaScript 输入输出语句</h2><h3 id="alert-msg"><a href="#alert-msg" class="headerlink" title="alert(msg)"></a>alert(msg)</h3><p>浏览器弹出警示框</p><h3 id="console-log-msg"><a href="#console-log-msg" class="headerlink" title="console.log(msg)"></a>console.log(msg)</h3><p>浏览器控制台打印输出信息</p><h3 id="prompt-info"><a href="#prompt-info" class="headerlink" title="prompt(info)"></a>prompt(info)</h3><p>浏览器弹出输入框，用户可以输入</p></article><hr><div><div class="post-metas mb-3"><div class="post-meta mr-3"><i class="iconfont icon-category"></i> <a class="hover-with-bg" href="/categories/JS/">JS</a></div><div class="post-meta"><i class="iconfont icon-tags"></i> <a class="hover-with-bg" href="/tags/JavaScript%E5%9F%BA%E7%A1%80/">JavaScript基础</a></div></div><p class="note note-warning">本博客所有文章除特别声明外，均采用 <a href="https://zh.wikipedia.org/wiki/Wikipedia:CC_BY-SA_3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank" rel="nofollow noopener noopener">CC BY-SA 3.0协议</a> 。转载请注明出处！</p><div class="post-prevnext row"><div class="post-prev col-6"><a href="/2020/06/05/WebAPI/"><i class="iconfont icon-arrowleft"></i> <span class="hidden-mobile">WebAPI</span> <span class="visible-mobile">上一篇</span></a></div><div class="post-next col-6"><a href="/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87/"><span class="hidden-mobile">前端面试——CSS篇一</span> <span class="visible-mobile">下一篇</span> <i class="iconfont icon-arrowright"></i></a></div></div></div><div class="comments" id="comments"></div></div></div></div></div><div class="d-none d-lg-block col-lg-2 toc-container" id="toc-ctn"><div id="toc"><p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p><div id="tocbot"></div></div></div></div></div></main><a id="scroll-top-button" href="#" role="button"><i class="iconfont icon-arrowup" aria-hidden="true"></i></a><div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel" aria-hidden="true"><div class="modal-dialog modal-dialog-scrollable modal-lg" role="document"><div class="modal-content"><div class="modal-header text-center"><h4 class="modal-title w-100 font-weight-bold">搜索</h4><button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button></div><div class="modal-body mx-3"><div class="md-form mb-5"><input type="text" id="local-search-input" class="form-control validate"> <label data-error="x" data-success="v" for="local-search-input">关键词</label></div><div class="list-group" id="local-search-result"></div></div></div></div></div><footer class="mt-5"><div class="text-center py-3"><div>©2020 By TQ</div><div>Power by <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a></div><div><span id="timeDate">载入天数...</span> <span id="times">载入时分秒...</span></div></div><p id="hitokoto">获取中...</p></footer><style>#hitokoto{text-align:center;color:#fff;background-color:rgba(10,10,10,.8);margin-bottom:0;padding:10px 0}</style><script src="https://cdn.staticfile.org/jquery/3.4.1/jquery.min.js"></script><script src="https://cdn.staticfile.org/twitter-bootstrap/4.4.1/js/bootstrap.min.js"></script><script src="/js/main.js"></script><script src="/js/lazyload.js"></script><script src="https://cdn.staticfile.org/tocbot/4.11.1/tocbot.min.js"></script><script>$(document).ready(function(){var t=$("#board-ctn").offset().top;tocbot.init({tocSelector:"#tocbot",contentSelector:".post-content",headingSelector:"h1,h2,h3,h4,h5,h6",linkClass:"tocbot-link",activeLinkClass:"tocbot-active-link",listClass:"tocbot-list",isCollapsedClass:"tocbot-is-collapsed",collapsibleClass:"tocbot-is-collapsible",collapseDepth:0,scrollSmooth:!0,headingsOffset:-t}),0<$(".toc-list-item").length&&$("#toc").css("visibility","visible")})</script><script defer src="https://cdn.staticfile.org/clipboard.js/2.0.6/clipboard.min.js"></script><script src="/js/clipboard-use.js"></script><script src="https://cdn.staticfile.org/typed.js/2.0.11/typed.min.js"></script><script>var typed=new Typed("#subtitle",{strings:["  ","JavaScript基础语法&nbsp;"],cursorChar:"|",typeSpeed:70,loop:!1});typed.stop(),$(document).ready(function(){$(".typed-cursor").addClass("h2"),typed.start()})</script><script src="https://cdn.staticfile.org/anchor-js/4.2.2/anchor.min.js"></script><script>anchors.options = {
      placement: "right",
      visible: "hover",
      
    };
    var el = "h1,h2,h3,h4,h5,h6".split(",");
    var res = [];
    for (item of el) {
      res.push(".markdown-body > " + item)
    }
    anchors.add(res.join(", "))</script><script src="/js/local-search.js"></script><script>var path="/local-search.xml",inputArea=document.querySelector("#local-search-input");inputArea.onclick=function(){searchFunc(path,"local-search-input","local-search-result"),this.onclick=null}</script><script src="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.js"></script><link rel="stylesheet" href="https://cdn.staticfile.org/fancybox/3.5.7/jquery.fancybox.min.css"><script>$("#post img:not(.no-zoom img, img[no-zoom]), img[zoom]").each(function(){var t=document.createElement("a");$(t).attr("data-fancybox","images"),$(t).attr("href",$(this).attr("src")),$(this).wrap(t)})</script><script>!function(e,r,t){var o,n=[];e.requestAnimationFrame=e.requestAnimationFrame||e.webkitRequestAnimationFrame||e.mozRequestAnimationFrame||e.oRequestAnimationFrame||e.msRequestAnimationFrame||function(e){setTimeout(e,1e3/60)},function(t){var a=r.createElement("style");a.type="text/css";try{a.appendChild(r.createTextNode(t))}catch(e){a.styleSheet.cssText=t}r.getElementsByTagName("head")[0].appendChild(a)}(".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: fixed;}.heart:after{top: -5px;}.heart:before{left: -5px;}"),o="function"==typeof e.onclick&&e.onclick,e.onclick=function(e){var t,a;o&&o(),t=e,(a=r.createElement("div")).className="heart",n.push({el:a,x:t.clientX-5,y:t.clientY-5,scale:1,alpha:1,color:"rgb("+~~(255*Math.random())+","+~~(255*Math.random())+","+~~(255*Math.random())+")"}),r.body.appendChild(a)},function e(){for(var t=0;t<n.length;t++)n[t].alpha<=0?(r.body.removeChild(n[t].el),n.splice(t,1)):(n[t].y--,n[t].scale+=.004,n[t].alpha-=.013,n[t].el.style.cssText="left:"+n[t].x+"px;top:"+n[t].y+"px;opacity:"+n[t].alpha+";transform:scale("+n[t].scale+","+n[t].scale+") rotate(45deg);background:"+n[t].color+";z-index:99999");requestAnimationFrame(e)}()}(window,document)</script><script>var now = new Date();
  function createtime(){
      var grt= new Date("05/27/2020 00:00:00");//此处修改你的建站时间或者网站上线时间
      now.setTime(now.getTime()+250);
      days = (now - grt ) / 1000 / 60 / 60 / 24;
      dnum = Math.floor(days);
      hours = (now - grt ) / 1000 / 60 / 60 - (24 * dnum);
      hnum = Math.floor(hours);
      if(String(hnum).length ==1 ){
          hnum = "0" + hnum;
      }
      minutes = (now - grt ) / 1000 /60 - (24 * 60 * dnum) - (60 * hnum);
      mnum = Math.floor(minutes);
      if(String(mnum).length ==1 ){
                mnum = "0" + mnum;
      }
      seconds = (now - grt ) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
      snum = Math.round(seconds);
      if(String(snum).length ==1 ){
                snum = "0" + snum;
      }
      document.getElementById("timeDate").innerHTML = "本站安全运行&nbsp"+dnum+"&nbsp天";
      document.getElementById("times").innerHTML = hnum + "&nbsp小时&nbsp" + mnum + "&nbsp分&nbsp" + snum + "&nbsp秒";
  }
  setInterval("createtime()",250);
  fetch('https://v1.hitokoto.cn/')
    .then(response => response.json())
    .then(data => {
      const hitokoto = document.getElementById('hitokoto')
      hitokoto.innerText = data.hitokoto
      })
      .catch(console.error)</script></body></html>