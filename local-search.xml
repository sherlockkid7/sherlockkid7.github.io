<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端面试——Vue篇</title>
    <link href="/2020/07/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94Vue%E7%AF%87/"/>
    <url>/2020/07/14/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94Vue%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-单页应用（SPA）的理解，及优缺点"><a href="#1-单页应用（SPA）的理解，及优缺点" class="headerlink" title="1.单页应用（SPA）的理解，及优缺点"></a>1.单页应用（SPA）的理解，及优缺点</h4><p>通俗一点说就是指只有一个主页面的应用，浏览器一开始要加载所有必须的 html, js, css。利用路由机制（js）实现 HTML 内容的变换</p><p>优点：</p><p>1、用户体验好，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染。基于这一点spa对服务器压力较小</p><p>2、前后端分离，前端进行交互逻辑，后端负责数据处理</p><p>3、页面效果会比较炫酷（比如切换页面内容时的专场动画）</p><p>缺点：</p><p>1、初次加载时耗时多（可用路由懒加载解决）</p><p>2、前进后退功能路由管理（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理）</p><p>3、不利于seo(所有的内容都在一个页面中动态替换显示)</p><h4 id="2-MVVM"><a href="#2-MVVM" class="headerlink" title="2.MVVM"></a>2.MVVM</h4><p>MVVM由View、ViewModel、Model三部分组成</p><ul><li>View（视图层）：可以简单的理解为DOM层。主要用于给用户展示各种信息</li><li>ViewModel（视图模型层）：是Model和View之间的通信桥梁。</li><li>Model（模型/数据层）：负责处理业务逻辑以及和服务器端进行交互</li></ul><p>在MVVM的架构下，<strong>View层和Model层并没有直接联系，而是通过ViewModel层进行交互。</strong> 一方面它实现了数据绑定，将Model的改变实时的反应到View中；另一方面它实现了DOM监听，当DOM发生一些事件(点击、滚动、touch等)时可以监听到，并在需要的情况下改变对应的Data ，因此开发者只需关注业务逻辑，无需手动操作DOM</p><h4 id="3-Vue-是如何实现数据双向绑定的"><a href="#3-Vue-是如何实现数据双向绑定的" class="headerlink" title="3.Vue 是如何实现数据双向绑定的"></a>3.Vue 是如何实现数据双向绑定的</h4><p>Vue 数据双向绑定主要是指：数据变化更新视图，视图变化更新数据</p><p>采用<strong>数据劫持结合发布者-订阅者模式</strong>的方式，通过 <code>Object.defineProperty()</code> 来劫持各个属性的 setter、getter，在数据变化时发布消息给订阅者，触发相应的监听回调。</p><p>Vue 主要通过以下 4 个步骤来实现数据双向绑定的：</p><ol><li>实现一个监听器 Observer，对数据对象进行递归遍历，包括子属性对象的属性，利用 Object.defineProperty() 对属性都加上 setter 和 getter<br>这样的话，给这个对象的某个值赋值，就会触发 setter，那么就能监听到了数据变化</li><li>compile 解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li><li>Watcher 订阅者是 Observer 和 Compile 之间通信的桥梁，主要的任务是订阅 Observer 中的属性值变化的消息，当收到属性值变化的消息时，触发解析器 Compile 中对应的更新函数。</li><li>MVVM 作为数据绑定的入口，整合 Observer、Compile 和 Watcher 三者，<strong>通过Observer来监听自己的 model 数据变化，通过 Compile 来解析编译模板指令，最终利用 Watcher 搭起 Observer 和 Compile 之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据 model 变更的双向绑定效果。</strong></li></ol><p><img src="https://img-blog.csdnimg.cn/2020071415034244.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>响应式系统简述:</p><ul><li><p>任何一个 Vue Component 都有一个与之对应的 Watcher 实例</p></li><li><p>Vue 的 data 上的属性会被添加 getter 和 setter 属性</p></li><li><p>当 Vue Component render 函数被执行的时候, data 上会被 触碰(touch), 即被读, getter 方法会被调用, 此时 Vue 会去记录此 Vue component 所依赖的所有 data。(这一过程被称为依赖收集)</p></li><li><p>data 被改动时（主要是用户操作）, 即被写, setter 方法会被调用, 此时 Vue 会去通知所有依赖于此 data 的组件去调用他们的 render 函数进行更新</p></li></ul><h4 id="4-v-show-与-v-if-有什么区别"><a href="#4-v-show-与-v-if-有什么区别" class="headerlink" title="4.v-show 与 v-if 有什么区别"></a>4.v-show 与 v-if 有什么区别</h4><p>v-if和v-show都是用来<strong>控制元素/组件的渲染</strong>。<strong>v-if</strong> 是真正的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建，如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。<strong>v-show</strong> 不管初始条件是什么，元素总是会被渲染，通过设置DOM元素的display样式属性控制显隐</p><p>适用场景：如果需要非常频繁地切换，则使用 v-show 较好；如果在运行时条件很少改变，不需要频繁切换条件，则使用 v-if 较好。</p><h4 id="5-watch、methods-和-computed-的区别"><a href="#5-watch、methods-和-computed-的区别" class="headerlink" title="5.watch、methods 和 computed 的区别"></a>5.watch、methods 和 computed 的区别</h4><ul><li><p><strong>computed</strong></p><p><strong>计算属性</strong>，依赖其它属性值。自动<strong>监听依赖值</strong>的变化，从而<strong>动态返回内容</strong>。computed的值是会被缓存的。如果所依赖的数据发生改变时候, 就会重新计算。</p><p><strong>computed 应用场景</strong></p><p>当我们需要进行复杂逻辑的数据计算，需要的数据依赖于其他的数据的话，应该使用 computed。因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算</p></li><li><p><strong>methods</strong></p><p>是一个方法，它可以接受参数，用于<strong>存储监听事件回调函数</strong>。每次调用, 都会重新执行函数。</p><p>methods没有缓存，所以每次访问都要重新执行。当不需要缓存功能，就使用methods</p></li><li><p><strong>watch</strong> 是<strong>侦听属性</strong>，为了监听某个<strong>响应数据</strong>的变化。</p><p><strong>watch的使用场景</strong></p><p>需要在数据变化时执行异步或开销较大的操作时（一个数据影响多个数据），才用 watch。</p></li></ul><p>扩展：</p><p>计算属性的setter和getter,计算属性默认只有 getter</p><p><strong>watch 和 computed的区别是：</strong></p><p>相同点：他们两者都是观察页面数据变化的。</p><p>不同点：computed只有当依赖的数据变化时才会计算, 当数据没有变化时, 它会读取缓存数据。<br>watch每次都需要执行函数。watch更适用于数据变化时的异步操作。</p><h4 id="6-Vue单向数据流（有点难以理解）"><a href="#6-Vue单向数据流（有点难以理解）" class="headerlink" title="6.Vue单向数据流（有点难以理解）"></a>6.Vue单向数据流（有点难以理解）</h4><p>Vue 中，父子组件之间，prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是不会反过来。这是为了防止子组件无意修改了父组件的状态——这会让应用的数据流难以理解</p><p>另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值。这意味着你不应该在子组件内部改变 prop 。如果你这么做了，Vue 会在控制台给出警告</p><p>通常有两种改变 prop 的情况：</p><ol><li>prop 作为初始值传入，子组件之后只是将它的初始值作为本地数据的初始值使用；</li><li>prop 作为需要被转变的原始值传入。（定义一个 computed 属性，此属性从 prop 的值计算得出。）</li></ol><p>注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间。所以对于一个数组或对象类型的 prop 来说，在子组件中改变这个对象或数组本身将会影响到父组件的状态。</p><h4 id="7-Vue-生命周期"><a href="#7-Vue-生命周期" class="headerlink" title="7.Vue 生命周期"></a>7.Vue 生命周期</h4><p>Vue 实例从创建到销毁的过程，主要包括四个阶段：创建、挂载、更新、销毁</p><p><strong>beforeCreate（创建前）</strong></p><p><strong>created（创建后）</strong></p><p><strong>beforeMount（挂载前）</strong></p><p><strong>mounted（挂载后）</strong></p><p><strong>beforeUpdate（更新前）</strong></p><p><strong>updated（更新后）</strong></p><p><strong>beforeDestroy（销毁前）</strong></p><p><strong>destroyed（销毁后）</strong></p><p><strong>activited</strong>：keep-alive 专属，组件被激活时调用<br><strong>deactivated</strong>：keep-alive 专属，组件被销毁时调用</p><p>平时比较常用的是created和mounted。</p><p>created 钩子函数中调用异步请求,获取后台数据</p><p>mounted钩子函数中通过插件操作页面的DOM节点</p><h4 id="8-keep-alive-组件的理解"><a href="#8-keep-alive-组件的理解" class="headerlink" title="8.keep-alive 组件的理解"></a>8.keep-alive 组件的理解</h4><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，避免重新渲染 ，其有以下特性：</p><ul><li>一般结合路由和动态组件一起使用，用于缓存组件；</li><li>提供 include 和 exclude 属性，两者都支持字符串或正则表达式， include 表示只有名称匹配的组件会被缓存，exclude 表示任何名称匹配的组件都不会被缓存 ，其中 exclude 的优先级比 include 高；</li><li>对应两个钩子函数 activated 和 deactivated ，当组件被激活时，触发钩子函数 activated，当组件被移除时，触发钩子函数 deactivated。</li></ul><p>适用场景：</p><p>有两个页面，商品列表和商品详情页面，一般我们会经常执行打开详情=&gt;返回列表=&gt;打开详情这样的操作，那么就可以对列表组件使用keep-alive组件进行缓存，这样每次返回列表的时候，都是从缓存中快速渲染，而不是重新渲染</p><h4 id="9-组件中-data-为什么必须是一个函数？"><a href="#9-组件中-data-为什么必须是一个函数？" class="headerlink" title="9.组件中 data 为什么必须是一个函数？"></a>9.组件中 data 为什么必须是一个函数？</h4><p>Vue组件可能存在多个实例，如果使用对象形式定义data，则会导致它们共用一个data对象，那么状态变更将会影响所有组件实例；而采用函数形式定义，那么每个组件实例会返回一个全新的data对象，组件实例之间的 data 属性值不会互相影响。而在Vue根实例创建过程中则不存在该限制，因为根实例只能有一个，不需要担心这种情况</p><h4 id="10-v-model-的原理"><a href="#10-v-model-的原理" class="headerlink" title="10.v-model 的原理"></a>10.v-model 的原理</h4><p>实现表单元素和数据的双向绑定<br>v-model其实是一个语法糖，它本质上是包含两个操作：<br>1.v-bind绑定一个value属性<br>2.v-on指令给当前元素绑定input事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//子组件</span>&lt;template&gt;    &lt;div&gt;        &lt;input          v-on:input=<span class="hljs-string">"$emit('input', $event.target.value)"</span>          v-bind:value=<span class="hljs-string">"value"</span>&gt;    &lt;<span class="hljs-regexp">/div&gt;</span><span class="hljs-regexp">&lt;/</span>template&gt;&lt;script&gt;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name:<span class="hljs-string">'child'</span>,  props:&#123;    value:<span class="hljs-built_in">String</span>  &#125;&#125;&lt;<span class="hljs-regexp">/script&gt;</span><span class="hljs-regexp">-------------------------------------------------------------------</span><span class="hljs-regexp">/</span><span class="hljs-regexp">/父组件</span><span class="hljs-regexp">&lt;child :value="name"&gt;&lt;/</span>child&gt; &lt;input type=<span class="hljs-string">"text"</span> :value=<span class="hljs-string">"name"</span> @input=<span class="hljs-string">"name=$event.target.value"</span> &gt;&lt;p&gt;&#123;&#123;name&#125;&#125;&lt;<span class="hljs-regexp">/p&gt;</span><span class="hljs-regexp">&lt;button @click="change"&gt;按钮&lt;/</span>button&gt;&lt;script&gt;<span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">'./child.vue'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;data()&#123; <span class="hljs-keyword">return</span>&#123;   name:<span class="hljs-string">"你好"</span>, &#125;&#125;,components:&#123;   child,&#125;,methods:&#123;  change:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;     <span class="hljs-keyword">this</span>.name = <span class="hljs-string">"世界"</span>;&#125;&#125;,&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h4 id="11-Vue-组件间通信"><a href="#11-Vue-组件间通信" class="headerlink" title="11.Vue 组件间通信"></a>11.Vue 组件间通信</h4><ul><li><h5 id="父子组件间通信"><a href="#父子组件间通信" class="headerlink" title="父子组件间通信"></a>父子组件间通信</h5><ul><li><p>父传子<strong>（通过props）</strong></p><p>父组件通过import引入子组件，并注册，在子组件标签上添加需要传递的属性。在子组件中通过props接收。props的值有两种方式：</p><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p><p>方式二：对象，对象可以设置传递的类型，也可以设置默认值等</p></li><li><p>子传父（通过$emit）</p><p>子组件通过绑定事件触发函数，在函数中设置this.$emit(‘要派发的自定义事件’，传递的值)，在父组件中，通过v-on监听子组件派发的自定义事件</p></li></ul></li><li><h5 id="兄弟组件间通信"><a href="#兄弟组件间通信" class="headerlink" title="兄弟组件间通信"></a>兄弟组件间通信</h5><p>方法一：通过事件总线（event bus）实现</p><p>在vue的原型对象上初始化bus,作为全局的事件总线（即两个组件之间的桥梁）。在一个组件中通过this.bus.$emit(‘自定义事件’，值)发送数据，在另一个组件中通过this.bus.$on(‘自定义事件’，function(){})接收数据</p><p>方法二：通过Vuex实现</p></li></ul><h4 id="12-Vuex的理解"><a href="#12-Vuex的理解" class="headerlink" title="12.Vuex的理解"></a>12.Vuex的理解</h4><p>Vuex是一个状态管理工具，每个Vuex应用的核心就是store对象（仓库），包含着应用中所有需要共享的组件状态。主要用于解决大中型复杂项目数据共享问题。</p><p>五大核心属性：</p><ul><li><p>State（单一状态树）</p><p>存储数据、状态</p></li><li><p>Getter</p><p>可以认为是 store 的计算属性，从其中获取一些<strong>state变异后的状态</strong></p></li><li><p>Mutation</p><p>是唯一更改 store 中状态的方法，且必须是同步函数（方便devtools跟踪每一个状态的变化）</p></li><li><p>Action</p><p>可以包含任意异步操作，通过提交mutation间接更新状态</p></li><li><p>Module</p><p>将 store 分割成模块，每个模块都具有state、mutation、action、getter、甚至是嵌套子模块。</p></li></ul><p>vuex的数据传递流程：</p><p>当组件进行数据修改的时候，通过调用dispatch来触发actions，actions通过commit来触发mutations里面的方法进行数据的修改。mutations里面的每个函数都会有一个state参数，这样就可以在mutations里面进行state的数据修改，从而同步到组件，更新其数据状态</p><h4 id="13-vue-router-路由模式"><a href="#13-vue-router-路由模式" class="headerlink" title="13.vue-router 路由模式"></a>13.vue-router 路由模式</h4><ul><li><h5 id="history-模式"><a href="#history-模式" class="headerlink" title="history 模式"></a><strong>history 模式</strong></h5><p>利用 HTML5 History API 来实现 URL 的变化。</p><p>其中做最主要的 API 有以下两个：history.pushState() 和 history.repalceState()。这两个 API 可以在不进行刷新的情况下，操作浏览器的历史纪录。唯一不同的是，前者是新增一个历史记录，后者是直接替换当前的历史记录</p></li><li><h5 id="hash-模式"><a href="#hash-模式" class="headerlink" title="hash 模式"></a><strong>hash 模式</strong></h5><p>使用 URL hash 值来作路由。hash 值的改变，都会在浏览器的访问历史中增加一个记录。因此我们能通过浏览器的回退、前进按钮控制hash 的切换。可以使用 hashchange 事件来监听 hash 值的变化，从而对页面进行跳转（渲染）</p></li></ul><h4 id="14-虚拟-DOM"><a href="#14-虚拟-DOM" class="headerlink" title="14.虚拟 DOM"></a>14.虚拟 DOM</h4><p>虚拟DOM是为了解决浏览器性能问题而设计出来的</p><ul><li>虚拟DOM本质上是JavaScript对象,是对真实DOM的抽象</li><li>状态变更时，记录新树和旧树的差异</li><li>最后把差异更新到真正的dom中</li></ul><p>举例说明：一次操作中有10次更新dom的动作，虚拟dom不会立即操作dom，而是使用而是将这 10 次更新的 <code>diff</code> 内容保存到本地一个 JS 对象中，最终将这个 JS 对象一次性 <code>attch</code> 到 DOM 树上</p><p>优点：</p><ul><li>无需手动操作dom</li><li>跨平台</li></ul><h4 id="15-Vue-的-nextTick-的原理是什么？"><a href="#15-Vue-的-nextTick-的原理是什么？" class="headerlink" title="15.Vue 的 nextTick 的原理是什么？"></a>15.Vue 的 nextTick 的原理是什么？</h4><p>主要作用：为了处理数据动态变化后，dom未及时更新</p><p>nextTick 的原理正是 vue 通过异步队列控制 dom更新和 nextTick 回调函数先后执行的方式</p><h4 id="16-vue-首屏加载优化"><a href="#16-vue-首屏加载优化" class="headerlink" title="16.vue 首屏加载优化"></a>16.vue 首屏加载优化</h4><ol><li><p>vue 路由的懒加载</p><p><code>const home = () =&gt; import(&#39;./Home.vue&#39;)</code></p></li><li><p>把不常改变的库放到 index.html 中，通过 cdn 引入,然后在vue.config.js文件中，使用webpack的externals属性将不需要打包的库文件分离出去，减少打包文件后的大小</p><div class="hljs"><pre><code class="hljs js">externals: &#123;  <span class="hljs-string">'vue'</span>: <span class="hljs-string">'Vue'</span>,  <span class="hljs-string">'vue-router'</span>: <span class="hljs-string">'VueRouter'</span>,  <span class="hljs-string">'element-ui'</span>: <span class="hljs-string">'ELEMENT'</span>,&#125;,</code></pre></div></li></ol><h4 id="17-route-和-router-的区别是什么？"><a href="#17-route-和-router-的区别是什么？" class="headerlink" title="17. route 和 router 的区别是什么？"></a>17. <code>route</code> 和 <code>router</code> 的区别是什么？</h4><p><code>route</code>是“路由信息对象”，包括<code>path</code>,<code>params</code>,<code>hash</code>,<code>query</code>,<code>fullPath</code>,<code>matched</code>,<code>name</code>等路由信息参数。<br><code>router</code>是“路由实例对象”，包括了路由的跳转方法(<code>push</code>、<code>replace</code>)，钩子函数等。</p><h4 id="18-Vue中key的作用"><a href="#18-Vue中key的作用" class="headerlink" title="18.Vue中key的作用"></a>18.Vue中key的作用</h4><p><strong>key 的作用主要是为了高效的更新虚拟DOM</strong></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试——JavaScript篇</title>
    <link href="/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94JavaScript%E7%AF%87/"/>
    <url>/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94JavaScript%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h4 id="1-js-的数据类型有哪些-值（变量）是如何存储的"><a href="#1-js-的数据类型有哪些-值（变量）是如何存储的" class="headerlink" title="1.js 的数据类型有哪些,值（变量）是如何存储的"></a>1.js 的数据类型有哪些,值（变量）是如何存储的</h4><h5 id="基本数据类型（原始数据类型）【七种】："><a href="#基本数据类型（原始数据类型）【七种】：" class="headerlink" title="基本数据类型（原始数据类型）【七种】："></a><strong>基本数据类型</strong>（原始数据类型）【七种】：</h5><ul><li><p>Undefined</p></li><li><p>Null</p></li><li><p>Boolean</p></li><li><p>Number</p></li><li><p>String</p></li><li><p>Symbol</p><p>ES6新增的一种原始数据类型 ，表示为 <strong>独一无二 的值</strong>，用来定义独一无二的对象属性名。</p><p><strong>Symbol的定义</strong></p><ul><li><p>一种Symbol类型可以通过使用Symbol()函数来生成；</p></li><li><p>Symbol()函数可以接收一个字符串作为参数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> s1 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);<span class="hljs-keyword">let</span> s2 = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'web'</span>);<span class="hljs-built_in">console</span>.log(s1 === s2); <span class="hljs-comment">// false ,Symbol()函数接收的参数相同，其变量的值不同，s1和s2是Symbol类型的变量，因为变量的值不同，所以打印的结果为false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s1); <span class="hljs-comment">//symbol</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> s2); <span class="hljs-comment">//symbol</span></code></pre></div></li></ul></li><li><p>BigInt（es10新增,表示任意精度格式的整数）</p></li></ul><p>基本数据类型：直接存放在<strong>栈（stack）</strong>中，在内存中以固定的大小存储</p><h5 id="引用数据类型【一种】："><a href="#引用数据类型【一种】：" class="headerlink" title="引用数据类型【一种】："></a>引用数据类型【一种】：</h5><ul><li><p>Object</p><p>Object本质上是由一组无序的名值对组成的。里面包含 function、Array、Date等</p></li></ul><p>引用数据类型：在<strong>栈（stack）</strong>中存储指向其堆内存的地址（指针），值存放在<strong>堆（heap）</strong>中。当我们想要访问引用类型的值的时候，需要先从栈中获得对象的地址指针，然后通过地址指针找到其在堆中的数据。</p><h5 id="扩展：（将一个变量赋值给另一个变量）"><a href="#扩展：（将一个变量赋值给另一个变量）" class="headerlink" title="扩展：（将一个变量赋值给另一个变量）"></a><strong>扩展：</strong>（将一个变量赋值给另一个变量）</h5><ul><li><p>基本数据类型复制的是值，赋值完成，两个变量没有任何关系；</p></li><li><p>引用数据类型复制的是地址（指针），复制操作完成后，两个变量实际上将引用同一个对象，修改一个变量另一个变量也会跟着一起变化。</p></li></ul><h4 id="2-对于基本数据类型和引用数据类型的理解"><a href="#2-对于基本数据类型和引用数据类型的理解" class="headerlink" title="2.对于基本数据类型和引用数据类型的理解"></a>2.对于基本数据类型和引用数据类型的理解</h4><p>基本数据类型的值指的是简单的数据段，引用数据类型指的是可能有多个值构成的对象。可以从三个方面来理解：动态的属性、变量赋值、传递参数</p><ul><li><p>动态的属性</p><p>定义基本数据类型和引用数据类型的值，都是创建一个变量并为该变量赋值。两者的区别在于，引用数据类型的值，我们可以为其添加、改变和删除其属性和方法，而对于基本数据类型的值则不能</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>(); <span class="hljs-comment">//创建一个对象并将其保存在变量person中</span>person.name = <span class="hljs-string">"Song"</span>; <span class="hljs-comment">//为该对象添加一个名为name的属性，并赋值为Song</span><span class="hljs-built_in">console</span>.log(person.name); <span class="hljs-comment">//访问name这个属性 结果为Song</span></code></pre></div></li><li><p>变量赋值</p><p>一个变量向另一个变量复制（基本数据类型或引用数据类型的）值时，两则的区别：</p><ul><li><p>基本数据类型的值</p><p>基本数据类型的值存储在栈中，当变量赋值时，会重新创建一个新值将其复制到为新变量分配的位置上,此时两个变量各自拥有属于自己的独立的内存空间，因此两者可以参与任何操作而不会相互影响。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<span class="hljs-keyword">var</span> b = a;b = <span class="hljs-number">2</span>;<span class="hljs-built_in">console</span>.log(a);<span class="hljs-comment">//1</span><span class="hljs-built_in">console</span>.log(b);<span class="hljs-comment">//2</span></code></pre></div></li><li><p>引用数据类型的值</p><p>引用数据类型的值存储在堆中，同时在栈中会有相应的堆地址（指针），指向堆的位置。当复制引用数据类型的值时，复制的不是堆内存中的值，而是将栈内存中的地址复制过去，复制操作结束后，两个对象实际上都指向堆中的同一个地方。因此改变其中一个对象（堆中的值改变），那么会影响到另一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> obj1 = &#123;  name:<span class="hljs-string">"Song"</span>&#125;;<span class="hljs-keyword">var</span> obj2 = obj1;obj2.name = <span class="hljs-string">"D"</span>; <span class="hljs-comment">//改变obj2的name属性的值，则将obj1的也改变了</span><span class="hljs-built_in">console</span>.log(obj1.name);<span class="hljs-comment">// D</span></code></pre></div></li></ul></li><li><p>传递参数(函数的形参可以看做是一个变量)</p><ul><li><p><strong>基本数据类型传参</strong><br>当我们把一个基本类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p></li><li><p><strong>引用数据类型传参</strong></p><p>当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">person</span>)</span>&#123;person.age = <span class="hljs-number">26</span>;person = &#123;  <span class="hljs-comment">//重新开辟了一个内存空间，然后将此内存空间的地址赋给person，可以理解为将刚才指向p1的指针地址给覆盖了，所以改变了person的指向</span>　　name:<span class="hljs-string">'yyy'</span>,　　age:<span class="hljs-number">30</span>&#125;<span class="hljs-keyword">return</span> person&#125;<span class="hljs-keyword">const</span> p1 = &#123;　　name:<span class="hljs-string">'yck'</span>,　　age:<span class="hljs-number">25</span>&#125;;<span class="hljs-keyword">const</span> p2 = test(p1);<span class="hljs-comment">//将p1的内存地址指针复制给了形参person，两者引用的是同一个对象，这个时候在函数中改变变量，就会影响到外部。</span><span class="hljs-built_in">console</span>.log(p1);<span class="hljs-comment">//&#123;name: "yck", age: 26&#125;</span><span class="hljs-built_in">console</span>.log(p2);<span class="hljs-comment">//&#123;name: "yyy", age: 30&#125;</span></code></pre></div></li></ul></li></ul><h4 id="3-JS中数据类型的判断"><a href="#3-JS中数据类型的判断" class="headerlink" title="3.JS中数据类型的判断"></a>3.JS中数据类型的判断</h4><ul><li><h5 id="typeof"><a href="#typeof" class="headerlink" title="typeof"></a>typeof</h5><p>typeof 检测<strong>变量的数据类型</strong>，返回一个<strong>字符串</strong>。</p><p>对于基本类型，除了null都可以返回正确类型;对于对象来说，除了function都返回object。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-string">'str'</span>);           <span class="hljs-comment">// string</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object     null 的数据类型被 typeof 解释为 object</span>-----------------------------------------------------------------<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> []);              <span class="hljs-comment">// object     []数组的数据类型在 typeof 中被解释为 object</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);    <span class="hljs-comment">// function</span><span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span></code></pre></div></li><li><h5 id="instanceof"><a href="#instanceof" class="headerlink" title="instanceof"></a>instanceof</h5><p>instanceof 用来判断<strong>对象的类型</strong>，原理是检测构造函数的 <code>prototype</code> 属性是否出现在某个实例对象的原型链上。也就是判断对象是否是某一数据类型（如Array）的实例</p><div class="hljs"><pre><code class="hljs plain">object instanceof constructor&#x2F;&#x2F;object  某个实例对象&#x2F;&#x2F;constructor  某个构造函数</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//使用instanceof来判断基本类型，则始终返回false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Number</span>);                    <span class="hljs-comment">// false</span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Boolean</span>);                <span class="hljs-comment">// false </span><span class="hljs-built_in">console</span>.log(<span class="hljs-string">'str'</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">String</span>);                <span class="hljs-comment">// false  </span>----------------------------------------------------------------<span class="hljs-comment">//引用数据类型的值都是object的实例，在检测一个引用类型值和Object构造函数时，instanceof操作符始终返回true。</span><span class="hljs-built_in">console</span>.log([] <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>);                    <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Function</span>);       <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Object</span>);                   <span class="hljs-comment">// true</span></code></pre></div></li><li><h5 id="Object-prototype-toString"><a href="#Object-prototype-toString" class="headerlink" title="Object.prototype.toString()"></a><strong>Object.prototype.toString()</strong></h5><p>Object.prototype.toString()方法检测对象类型</p><p>使用 call 对基本数据类型进行包装，使用 Object 对象的原型方法 toString转成字符串 。传入基本类型也能够判断出结果</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//结果都为true</span><span class="hljs-built_in">Object</span>.prototype.toString.call(&#123;&#125;)  ===  <span class="hljs-string">'[object Object]'</span>   <span class="hljs-built_in">Object</span>.prototype.toString.call([])   ===  <span class="hljs-string">'[object Array]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;)  ===  <span class="hljs-string">'[object Function]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-string">'somestring'</span>)  ===  <span class="hljs-string">'[object String]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-number">1</span>)  ===  <span class="hljs-string">'[object Number]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">true</span>)  ===  <span class="hljs-string">'[object Boolean]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-built_in">Symbol</span>()) ===  <span class="hljs-string">'[object Symbol]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">null</span>)   ===  <span class="hljs-string">'[object Null]'</span>　　<span class="hljs-built_in">Object</span>.prototype.toString.call(<span class="hljs-literal">undefined</span>)  === <span class="hljs-string">'[object Undefined]'</span></code></pre></div></li><li><h5 id="constructor-NaN"><a href="#constructor-NaN" class="headerlink" title="constructor"></a><strong>constructor</strong></h5><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log((<span class="hljs-number">2</span>).constructor === <span class="hljs-built_in">Number</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log((<span class="hljs-literal">true</span>).constructor === <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log((<span class="hljs-string">'str'</span>).constructor === <span class="hljs-built_in">String</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(([]).constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log((<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;).constructor === <span class="hljs-built_in">Function</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log((&#123;&#125;).constructor === <span class="hljs-built_in">Object</span>); <span class="hljs-comment">// true</span>----------------------------------------------------------<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Fn</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;Fn.prototype=<span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();<span class="hljs-keyword">var</span> f=<span class="hljs-keyword">new</span> Fn();<span class="hljs-built_in">console</span>.log(f.constructor===Fn);    <span class="hljs-comment">// false，函数Fn的原型改变了，constructor也会发生改变</span><span class="hljs-built_in">console</span>.log(f.constructor===<span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span></code></pre></div></li></ul><h4 id="4-数据类型的转换"><a href="#4-数据类型的转换" class="headerlink" title="4.数据类型的转换"></a>4.数据类型的转换</h4><table><thead><tr><th>转换类型</th><th>方法</th></tr></thead><tbody><tr><td>转换为字符串</td><td><strong>toString()</strong>、String() 强制转化、<strong>加号拼接字符串</strong></td></tr><tr><td>转换为数字型</td><td><strong>parseInt()</strong>、<strong>parseFloat()</strong>、Number()强制转换、js隐式转换（- * /）</td></tr><tr><td>转换为布尔型</td><td>Boolean()方法</td></tr></tbody></table><p><strong>包装类型</strong></p><p>为了便于操作基本类型值，衍生出来了三个包装类型:Boolean,Number,String,每当读取一个基本类型值的时候，后台会创建一个对应的基本包装类型的对象，从而能够调用一些方法来操作这些基本类型。每个包装类型都映射到同名的基本类型。</p><p><strong>引用数据类型和包装类型的主要区别</strong>：就是对象的生存期。使用new操作符创建的引用类型的实例，在执行流离开当前作用域之前都一直保存在内存中。而自动创建的基本包装类型的对象，则只存在于一行代码的执行瞬间，然后立即被销毁，因此我们不能在运行时为基本类型值添加属性和方法。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> s1 = <span class="hljs-string">"stringtext"</span>;s1.color = <span class="hljs-string">"red"</span>; <span class="hljs-comment">//在这一句话执行完的瞬间，第二行创建的String就已经被销毁了。</span><span class="hljs-built_in">console</span>.log(s1.color);<span class="hljs-comment">//执行这一行代码时又创建了自己的String对象，而该对象没有color属性，结果为undefine</span></code></pre></div><p><strong>宽松相等“==”和严格相等“===”有什么区别？</strong>（“==”和“===”是隐式类型转换）</p><p>==在相等比较中会自动类型转换，而===不会自动类型转换，直接比较</p><p>扩展：<a href="https://zhuanlan.zhihu.com/p/31105614" target="_blank" rel="noopener">面试题</a></p><h4 id="5-作用域和作用域链"><a href="#5-作用域和作用域链" class="headerlink" title="5.作用域和作用域链"></a>5.作用域和作用域链</h4><ul><li><h5 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h5><p>作用域是定义变量（函数）时产生的，决定了代码执行区域对于变量，函数，对象的可访问性</p><p><strong>作用域最大的用处就是隔离变量，不同作用域下同名变量不会有冲突。</strong></p><ul><li><p>全局作用域</p><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件，在任何地方都可以访问.一般来说以下几种情形拥有全局作用域：</p><p>1.最外层函数和在最外层函数外面定义的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> outVariable = <span class="hljs-string">"我是最外层变量"</span>; <span class="hljs-comment">//最外层变量</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//最外层函数</span>    <span class="hljs-keyword">var</span> inVariable = <span class="hljs-string">"内层变量"</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">innerFun</span>(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//内层函数</span>        <span class="hljs-built_in">console</span>.log(inVariable);    &#125;    innerFun();&#125;<span class="hljs-built_in">console</span>.log(outVariable); <span class="hljs-comment">//我是最外层变量</span>outFun(); <span class="hljs-comment">//内层变量</span><span class="hljs-built_in">console</span>.log(inVariable); <span class="hljs-comment">//inVariable is not defined</span>innerFun(); <span class="hljs-comment">//innerFun is not defined</span></code></pre></div><p>2.所有末定义直接赋值的变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">outFun2</span>(<span class="hljs-params"></span>) </span>&#123;    variable = <span class="hljs-string">"未定义直接赋值的变量"</span>;    <span class="hljs-keyword">var</span> inVariable2 = <span class="hljs-string">"内层变量2"</span>;&#125;outFun2();<span class="hljs-comment">//要先执行这个函数，否则根本不知道里面是啥</span><span class="hljs-built_in">console</span>.log(variable); <span class="hljs-comment">//未定义直接赋值的变量</span><span class="hljs-built_in">console</span>.log(inVariable2); <span class="hljs-comment">//inVariable2 is not defined</span></code></pre></div><p>3.所有window对象的属性</p><p><strong>全局作用域的缺点</strong>：如果变量都定义全局作用域中，会污染全局命名空间, 容易引起命名冲突。</p></li><li><p>函数作用域</p><p>作用于函数内的代码环境，只能在函数内部访问</p><div class="hljs"><pre><code class="hljs plain">function doSomething()&#123;    var blogName&#x3D;&quot;blog&quot;;    function innerSay()&#123;        alert(blogName);    &#125;    innerSay();&#125;alert(blogName); &#x2F;&#x2F;blogName is not definedinnerSay(); &#x2F;&#x2F;innerSay is not defined</code></pre></div><p><strong>作用域是分层的，内层作用域可以访问外层作用域的变量，反之则不行</strong></p><p><strong>块语句，如 if 和 switch 条件语句或 for 和 while 循环语句，它们不会创建一个新的作用域</strong>。在块语句中定义的变量将保留在它们已经存在的作用域中。</p><div class="hljs"><pre><code class="hljs plain">if (true) &#123;    &#x2F;&#x2F; &#39;if&#39; 条件语句块不会创建一个新的作用域    var name &#x3D; &#39;Hammad&#39;; &#x2F;&#x2F; name 依然在全局作用域中&#125;console.log(name); &#x2F;&#x2F; logs &#39;Hammad&#39;</code></pre></div></li><li><p>块级作用域（<strong>ES6</strong>）</p><p>块级作用域在如下情况被创建：</p><ol><li>在一个函数内部</li><li>在一个代码块（由一对花括号包裹）内部</li></ol></li></ul></li><li><h5 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h5><p>当我们查找一个变量时，如果当前执行环境中没有找到，就向外层去找同名变量，这种作用域产生的“由内向外”的过程就是作用域链。</p></li></ul><p><a href="https://juejin.im/post/5c8290455188257e5d0ec64f" target="_blank" rel="noopener">关于作用域和作用域链的详细介绍</a></p><h4 id="6-原型和原型链"><a href="#6-原型和原型链" class="headerlink" title="6.原型和原型链"></a>6.原型和原型链</h4><p>使用构造函数创建某一类对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;    &#125;<span class="hljs-keyword">var</span> person = <span class="hljs-keyword">new</span> Star();<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Object</span>.getPrototypeOf( person)); person.name = <span class="hljs-string">'Kevin'</span>;<span class="hljs-comment">//Star 就是一个构造函数，我们使用 new 创建了一个实例对象 person。</span></code></pre></div><ul><li><h5 id="原型对象"><a href="#原型对象" class="headerlink" title="原型对象"></a>原型对象</h5><p>js作者在设计js的时候，希望是一门简单的编程语言，但js里面的所有数据类型都是对象（Object）,必须有一种机制，将所有对象联系起来，所以设计了“继承”。但是不想js变得复杂，没有引入“类”（Class）的概念，根据（java、c++语言的思想）引入了new命令，通过new构造函数实例化对象，同时为构造函数设置了 prototype 属性，这样所有的实例对象共享同一个prototype，从外界来看，prototype就好像是实例对象的原型对象</p><p>每一个构造函数的内部都有一个 prototype 属性(原型对象)，prototype是一个对<br>象，这个对象包含了所有实例共享的属性和方法。</p></li><li><h5 id="原型"><a href="#原型" class="headerlink" title="原型"></a>原型</h5><p>new的实例化对象都具有的一个<code>__proto__</code>属性(原型)，这个属性会指向构造函数的原型对象。</p><p><code>__proto__</code>的意义就在于为对象的查找机制提供一个方向，或者说一条路线。但是它是一个非标准属性，因此实际开发中，不可以使用这个属性。ES5 中新增了一个 Object.getPrototypeOf() 方法，我们可以通过这个方法来获取对象的原型。</p></li><li><h5 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h5><p>当我们访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型上查找，如果还没有就查找原型对象的原型，一直找到Object原型对象的原型（null）为止，这就是原型链</p><p><img src="https://img-blog.csdnimg.cn/20200613090128300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><p>构造函数、实例和原型对象三角关系：</p><p>1.构造函数的prototype属性指向了构造函数原型对象<br>2.实例对象是由构造函数创建的,实例对象的<code>__proto__</code>属性指向了构造函数的原型对象<br>3.原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数</p><h4 id="7-new对象是内部做了什么"><a href="#7-new对象是内部做了什么" class="headerlink" title="7.new对象是内部做了什么"></a>7.new对象是内部做了什么</h4><p>（1）<strong>创建一个新对象，并继承其构造函数的<code>prototype</code></strong>（继承构造函数原型对象上的属性和方法）</p><p>（2）<strong>执行构造函数，方法内的<code>this</code>指向该对象</strong>（执行构造函数内的赋值操作）</p><p>（3）<strong>返回新对象</strong></p><h4 id="8-闭包"><a href="#8-闭包" class="headerlink" title="8.闭包"></a>8.闭包</h4><p>闭包（closure）是指能够访问另一个函数内部变量的函数。</p><p>创建闭包：在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p><p>闭包的用途：</p><ul><li><p>创建私有变量</p><p>通过使用闭包，我们可以通过在函数外部调用闭包函数，从而在外部访问到函数内部的变量</p></li><li><p>延伸变量的作用域</p><p>闭包函数保留了变量对象的引用，让这个变量在函数执行完毕之后不会被回收</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">var</span> n = <span class="hljs-number">0</span>;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">add</span>(<span class="hljs-params"></span>)</span>&#123;       n++;       <span class="hljs-built_in">console</span>.log(n);    &#125;    <span class="hljs-keyword">return</span> add;&#125;<span class="hljs-keyword">var</span> f = fn(); <span class="hljs-comment">//注意，函数名只是一个标识（指向函数的指针），而（）才是执行函数；</span>f();    <span class="hljs-comment">//1</span>f();    <span class="hljs-comment">//2  第二次调用n变量还在内存中</span></code></pre></div></li><li><p>避免全局变量污染</p></li></ul><p>闭包的缺点：</p><ul><li>导致内存泄漏（不合理的使用闭包，从而导致某些变量一直被留在内存当中。）</li></ul><p>闭包应用场景：</p><ol><li><p>Ajax请求的成功回调</p></li><li><p>事件绑定的回调方法</p></li><li><p>setTimeout的延时回调</p></li><li><p>一个函数内部返回另一个匿名函数</p></li></ol><h4 id="9-DOM事件流"><a href="#9-DOM事件流" class="headerlink" title="9.DOM事件流"></a>9.DOM事件流</h4><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p>DOM 事件流会经历3个阶段：</p><ol><li><p>捕获阶段</p><p>由 DOM 最顶层节点（document）开始，然后逐级向下传播到最具体的元素接收的过程。</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段</p><p>事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点（document）的过程</p></li></ol><h4 id="10-事件委托"><a href="#10-事件委托" class="headerlink" title="10.事件委托"></a>10.事件委托</h4><p>事件委托也称为事件代理,利用事件冒泡机制，当子元素的事件触发，会冒泡到父元素，让父元素代替执行</p><p><strong>事件委托的好处</strong></p><ul><li>只绑定一次事件，无需频繁访问DOM，性能较高</li><li>当有新DOM生成时，无需重复绑定事件</li></ul><p><strong>事件委托的局限性</strong></p><p>比如 onblur、onfocus、onmouseenter、onmouseleave之类的事件本身没有事件冒泡机制，所以无法委托</p><p>事件委托的应用场景</p><p>1.实现事件的动态绑定，比如说新增了一个子节点，我们直接父元素中的监听函数处理这个子节点触发的事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> oUl = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">"ul"</span>);<span class="hljs-keyword">let</span> num = <span class="hljs-number">4</span>;oUl.addEventListener(<span class="hljs-string">'mouseover'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;  <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;  <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;  <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;     target.style.background=<span class="hljs-string">'red'</span>;  &#125;&#125;);　　oUl.addEventListener(<span class="hljs-string">'mouseout'</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>)</span>&#123;   <span class="hljs-keyword">let</span> evt = e || <span class="hljs-built_in">window</span>.event;   <span class="hljs-keyword">let</span> target = evt.target || evt.srcElement;   <span class="hljs-keyword">if</span>(target.nodeName.toLowerCase() == <span class="hljs-string">'li'</span>)&#123;       target.style.background=<span class="hljs-string">'orange'</span>;    &#125;                 &#125;); btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;   num++;   <span class="hljs-keyword">let</span> oLi = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'li'</span>);   oLi.innerHTML = <span class="hljs-number">111</span>*num;   oUl.appendChild(oLi);&#125;</code></pre></div><p>2.实现ul中的每个li的点击打印事件，直接在ul中的监听函数处理子节点触发的事件</p><div class="hljs"><pre><code class="hljs plain">&lt;script&gt;  const oUl &#x3D; document.getElementById(&quot;ul&quot;);  oUl.addEventListener(&#39;click&#39;,function(e)&#123;     let evt &#x3D; e || window.event;&#x2F;&#x2F;e指事件对象     let target &#x3D; evt.target || evt.srcElement;&#x2F;&#x2F;target是e对象的一个属性，可以返回事件的目标节点     &#x2F;&#x2F;nodeName获取具体的标签名，返回是大写的；toLowerCase()将其转换成小写     if(target.nodeName.toLowerCase() &#x3D;&#x3D; &#39;li&#39;)&#123;       console.log(&#39;事件委托实现li的点击事件&#39;);     &#125; &#125;)　 &#x2F;&#x2F;jq方式实现相对而言简单 $(“oul”).on(“click”,“li”,function()&#123;&#x2F;&#x2F;事件逻辑&#125;)  &#x2F;&#x2F;其中第二个参数指的是触发事件的具体目标，特别是给动态添加的元素绑定事件，这个特别起作用&lt;&#x2F;script&gt;</code></pre></div><p>参考资料：<a href="https://www.cnblogs.com/liugang-vip/p/5616484.html" target="_blank" rel="noopener">js中的事件委托或是事件代理详解</a></p><h4 id="11-DOM-操作——节点操作、获取元素"><a href="#11-DOM-操作——节点操作、获取元素" class="headerlink" title="11.DOM 操作——节点操作、获取元素"></a>11.DOM 操作——节点操作、获取元素</h4><table><thead><tr><th>操作类型</th><th>方法</th><th>方法的解释</th></tr></thead><tbody><tr><td>创建节点</td><td><strong>document.createElement(‘tagName’)</strong></td><td>创建由 tagName 指定的 HTML 元素</td></tr><tr><td>添加节点</td><td><strong>node.appendChild(child)</strong></td><td>将一个节点添加到指定父节点的子节点列表末尾</td></tr><tr><td>插入节点</td><td><strong>node.insertBefore(child, 指定元素)</strong></td><td>将一个节点添加到父节点的指定子节点前面</td></tr><tr><td>删除节点</td><td>node.removeChild()</td><td>从 DOM 中删除一个子节点</td></tr><tr><td>复制节点</td><td>node.cloneNode()</td><td>返回调用该方法的节点的一个副本</td></tr><tr><td>查找节点</td><td>getElementById(‘id’)<br>getElementsByTagName(‘标签名’)<br>getElementsByClassName(‘类名’)<br>querySelector(‘选择器’)<br>querySelectorAll(‘选择器’)</td><td>根据ID获取元素对象<br>根据标签名获取元素对象<br>根据类名返回元素对象集合<br>根据指定选择器返回第一个元素对象<br>根据指定选择器返回所有元素对象集合</td></tr></tbody></table><h4 id="12-数组和对象常见的原生方法"><a href="#12-数组和对象常见的原生方法" class="headerlink" title="12.数组和对象常见的原生方法"></a>12.数组和对象常见的原生方法</h4><p>下划线（_）：表示改变原数组的方法</p><table><thead><tr><th>数组方法</th><th>说明</th></tr></thead><tbody><tr><td><u>push()</u></td><td>数组末尾添加一个或多个元素</td></tr><tr><td><u>unshift()</u></td><td>数组首位添加一个或多个元素</td></tr><tr><td><u>shift()</u></td><td>删除数组的第一个元素，并返回该值</td></tr><tr><td><u>pop()</u></td><td>删除数组的最后一个元素，并返回该值</td></tr><tr><td><u>splice()</u></td><td>用于插入、删除、替换数组的元素</td></tr><tr><td><u>reverse()</u></td><td>颠倒数组中元素的位置</td></tr><tr><td><u>sort()</u></td><td>对数组元素进行排序（从小到大）</td></tr><tr><td>isArray()</td><td>用于确定传递的值是否是一个 Array，返回一个布尔值</td></tr><tr><td>toString()</td><td>把数组转换成字符串，并返回结果</td></tr><tr><td>join()</td><td>所有的数组元素被转换成字符串，再用一个分隔符将这些字符串连接起来</td></tr><tr><td>slice()</td><td>可从已有的数组中返回选定的元素</td></tr><tr><td>concat()</td><td>用于连接两个或多个数组</td></tr><tr><td>indexOf()</td><td>返回指定元素在数组中的第一个索引，如果不存在，则返回-1（用于查找一个元素的位置）</td></tr><tr><td>lastindexOf()</td><td>返回指定元素在数组中的最后一个的索引,如果不存在，则返回-1</td></tr><tr><td><code>forEach()</code></td><td>为每个数组元素执行一次 <code>callback</code> 函数</td></tr><tr><td><code>map()</code></td><td>给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数,该函数每次执行后的返回值组成一个新数组（映射函数）</td></tr><tr><td><code>every()</code></td><td>测试一个数组内的所有元素是否都能通过某个指定函数的测试。返回一个布尔值</td></tr><tr><td><code>some()</code></td><td>测试数组中是不是至少有1个元素通过了指定函数测试。返回一个布尔值</td></tr><tr><td><code>filter()</code></td><td>为数组中的每个元素调用一次 <code>callback</code> 函数，该函数每次执行后的结果返回 true 的元素形成一个新数组（过滤函数）</td></tr><tr><td><code>includes()</code></td><td>方法用来判断一个数组是否包含一个指定的值，返回一个布尔值(用于判断一个元素是否存在于数组中)</td></tr><tr><td><code>find()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>值</strong>。否则返回 undefined</td></tr><tr><td><code>findIndex()</code></td><td>返回数组中满足指定测试函数的第一个元素的<strong>索引</strong>。否则返回-1</td></tr></tbody></table><table><thead><tr><th>对象方法</th><th>说明</th></tr></thead><tbody><tr><td>charAt()</td><td>返回指定位置的字符</td></tr><tr><td>charCodeAt()</td><td>返回在指定位置字符的Unicode 编码</td></tr><tr><td>concat()</td><td>将一个或多个字符串与原字符串连接合并，形成一个新的字符串并返回(不推荐)</td></tr><tr><td><code>indexOf()</code></td><td>返回调用它的 String对象中第一次出现的指定值的索引，如果未找到该值，则返回 -1。</td></tr><tr><td><strong><code>substring()</code></strong></td><td>提取字符串中两个指定的索引之间的字符</td></tr><tr><td><code>slice()</code></td><td>提取某个字符串的一部分，并返回一个新的字符串</td></tr><tr><td><code>split()</code></td><td>使用指定的分隔符字符串将一个String对象分割成子字符串数组</td></tr><tr><td>toLocaleLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLowerCase()</td><td>字符串被转换为小写的格式</td></tr><tr><td>toLocaleUpperCase()</td><td>把字符串转换为大写格式</td></tr></tbody></table><h4 id="12-null、undefined-与-undeclared-的区别"><a href="#12-null、undefined-与-undeclared-的区别" class="headerlink" title="12.null、undefined 与 undeclared 的区别"></a>12.null、undefined 与 undeclared 的区别</h4><ul><li><h5 id="null"><a href="#null" class="headerlink" title="null"></a>null</h5><p>null表示“没有对象”，即该处不应该有值</p><p>典型用法：</p><ul><li>作为函数的参数，表示该函数的参数不是对象</li><li>作为对象原型链的终点</li></ul></li><li><h5 id="undefined"><a href="#undefined" class="headerlink" title="undefined"></a>undefined</h5><p>undefined表示“缺少值”，此处应该有一个值，只是没有定义</p><p>典型用法：</p><ul><li><p>变量被声明了，但没有赋值时，就等于undefined</p></li><li><p>调用函数时，应该提供的参数没有提供，该参数等于undefined</p></li><li><p>对象没有赋值的属性，该属性的值为undefined</p></li><li><p>函数没有返回值时，默认返回undefined</p></li></ul></li><li><h5 id="undeclared"><a href="#undeclared" class="headerlink" title="undeclared"></a>undeclared</h5><p>没有在作用域中声明过的变量，对其引用，浏览器会报引用错误，如 ReferenceError: b is not defined 。</p><p>扩展：我们可以使用 typeof 的安全防范机制来避免报错，因为对于 undeclared（或者 not defined ）变量，typeof 会返回 “undefined”。</p></li></ul><p>扩展：</p><p>null == undefined 为true，因为它们是类似的值；如果用全等于(===)，null === undefined会返回false ,因为它们是不同类型的值。</p><h4 id="13-call、apply和bind的理解"><a href="#13-call、apply和bind的理解" class="headerlink" title="13.call、apply和bind的理解"></a>13.call、apply和bind的理解</h4><blockquote><p><code>call</code> 和 <code>apply</code> 实现函数调用，并都可以改变 <code>this</code> 的指向。作用都是相同的，只是传参的方式不同。</p><p>除了第一个参数外，<code>call</code> 可以接收一个参数列表，<code>apply</code> 只接受一个参数数组。</p></blockquote><p>模拟实现call()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//变更函数调用者示例</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">foo</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name) &#125;             <span class="hljs-keyword">const</span> obj = &#123;    name: <span class="hljs-string">'写代码'</span> &#125; <span class="hljs-comment">//思路：  </span><span class="hljs-comment">// 改变了 this 指向，让新的对象可以执行该函数。</span><span class="hljs-comment">// 那么思路是否可以变成给新的对象添加一个函数，然后在执行完以后删除？      </span><span class="hljs-built_in">Function</span>.prototype.myCall = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,...args</span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);    <span class="hljs-comment">//this不是函数，抛出异常</span>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)    &#125;    <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>    <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>    param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>    <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>    <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>    <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>&#125;foo.myCall(obj);  <span class="hljs-comment">//输出写代码</span></code></pre></div><p>模拟实现apply()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Function</span>.prototype.myApply = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">thisArg,args</span>)</span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);      <span class="hljs-comment">//this不是函数，抛出异常</span>      <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> <span class="hljs-keyword">this</span> !== <span class="hljs-string">'function'</span>)&#123;          <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">TypeError</span>(<span class="hljs-string">'error'</span>)      &#125;      <span class="hljs-keyword">const</span> fn = <span class="hljs-built_in">Symbol</span>(<span class="hljs-string">'fn'</span>);<span class="hljs-comment">// 声明一个独有的Symbol属性, 防止fn覆盖已有属性</span>      <span class="hljs-keyword">const</span> param = thisArg || <span class="hljs-built_in">window</span>;<span class="hljs-comment">// 若没有传入第一个参数, 默认绑定window对象</span>      param[fn] = <span class="hljs-keyword">this</span>;<span class="hljs-comment">// 给 param 添加一个属性fn，并让this指向此对象</span>      <span class="hljs-keyword">const</span> result = param[fn](...args); <span class="hljs-comment">// // 将param后面的参数取出来，执行当前函数</span>      <span class="hljs-keyword">delete</span> param[fn];<span class="hljs-comment">// 删除我们声明的fn属性</span>      <span class="hljs-keyword">return</span> result; <span class="hljs-comment">// 返回函数执行结果</span>  &#125;  foo.myApply(obj,[]);  <span class="hljs-comment">//输出写代码</span></code></pre></div><blockquote><p><code>bind()</code> 方法创建一个新的函数，在 bind() 被调用时，这个新函数的 this 被指定为 bind() 的第一个参数，而其余参数将作为新函数的参数，供调用时使用。<br>语法: function.bind(thisArg, arg1, arg2, …)</p></blockquote><h4 id="14-Ajax-是什么-如何创建一个-Ajax？"><a href="#14-Ajax-是什么-如何创建一个-Ajax？" class="headerlink" title="14.Ajax 是什么? 如何创建一个 Ajax？"></a>14.Ajax 是什么? 如何创建一个 Ajax？</h4><p>Ajax是一种异步通信的方法，通过 js 脚本向服务器发起 http 通信，然后根据服务器返回的数据，更新网页的相应部分，而不用刷新整个页面的一种方法。（异步局部刷新技术）</p><p>创建步骤：</p><p>创建对象 =&gt; 配置Ajax请求地址 =&gt; 发送请求 =&gt; 监听请求，接受响应</p><p>原生写法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1：创建Ajax对象</span><span class="hljs-keyword">var</span> xhr = <span class="hljs-built_in">window</span>.XMLHttpRequest?<span class="hljs-keyword">new</span> XMLHttpRequest():<span class="hljs-keyword">new</span> ActiveXObject(<span class="hljs-string">'Microsoft.XMLHTTP'</span>);<span class="hljs-comment">// 兼容IE6及以下版本</span><span class="hljs-comment">//2：配置 Ajax请求地址</span>xhr.open(<span class="hljs-string">'get'</span>,<span class="hljs-string">'url'</span>,<span class="hljs-literal">true</span>);<span class="hljs-comment">//3：发送请求</span>xhr.send(<span class="hljs-literal">null</span>); <span class="hljs-comment">// 严谨写法</span><span class="hljs-comment">//4:监听请求，接受响应</span>xhr.onreadysatechange=<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-comment">//readystate是当前的状态值</span><span class="hljs-comment">//status是Http的状态码 200表示ok  </span>   <span class="hljs-keyword">if</span>(xhr.readySate==<span class="hljs-number">4</span>&amp;&amp;xhr.status==<span class="hljs-number">200</span>)      <span class="hljs-built_in">console</span>.log(xhr.responseText)&#125;</code></pre></div><p>jQuery写法</p><div class="hljs"><pre><code class="hljs js">$.ajax(&#123; type:<span class="hljs-string">'post'</span>, url:<span class="hljs-string">''</span>, <span class="hljs-keyword">async</span>:ture,<span class="hljs-comment">//async 异步  sync同步</span> data:data,<span class="hljs-comment">//针对post请求</span> dataType:<span class="hljs-string">'json'</span>, success:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">msg</span>) </span>&#123;&#125;, error:<span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">error</span>) </span>&#123;&#125;&#125;)</code></pre></div><p>promise 封装实现</p><div class="hljs"><pre><code class="hljs plain">function getJSON(url) &#123;  &#x2F;&#x2F; 创建一个 promise 对象  let promise &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;      let xhr &#x3D; new XMLHttpRequest();      &#x2F;&#x2F; 新建一个 http 请求      xhr.open(&quot;GET&quot;, url, true);      &#x2F;&#x2F; 设置状态的监听函数      xhr.onreadystatechange &#x3D; function() &#123;          if (this.readyState !&#x3D;&#x3D; 4) return;      &#x2F;&#x2F; 当请求成功或失败时，改变 promise 的状态      if (this.status &#x3D;&#x3D;&#x3D; 200) &#123;        resolve(this.response);      &#125; else &#123;        reject(new Error(this.statusText));      &#125;    &#125;;    &#x2F;&#x2F; 设置错误监听函数    xhr.onerror &#x3D; function() &#123;      reject(new Error(this.statusText));    &#125;;    &#x2F;&#x2F; 设置响应的数据类型    xhr.responseType &#x3D; &quot;json&quot;;    &#x2F;&#x2F; 设置请求头信息    xhr.setRequestHeader(&quot;Accept&quot;, &quot;application&#x2F;json&quot;);    &#x2F;&#x2F; 发送 http 请求    xhr.send(null);  &#125;);  return promise;&#125;</code></pre></div><h4 id="15-如何实现继承"><a href="#15-如何实现继承" class="headerlink" title="15.如何实现继承"></a>15.如何实现继承</h4><h5 id="一-原型链继承"><a href="#一-原型链继承" class="headerlink" title="一. 原型链继承"></a>一. 原型链继承</h5><p>原型链继承的原理很简单，直接让<strong>子类的原型对象指向父类实例</strong>，当子类实例找不到对应的属性和方法时，就会往它的原型对象，也就是父类实例上找，从而<strong>实现对父类的属性和方法的继承</strong></p><p>原型继承的缺点:</p><p>1.由于子类实例原型对象指向父类实例, 因此子类实例继承的引用类型如果被修改，会影响到所有的实例对象</p><p>2.创建子类实例无法向父类构造函数传参, 即没有实现<code>super()</code>的功能</p><h5 id="二-构造函数继承"><a href="#二-构造函数继承" class="headerlink" title="二. 构造函数继承"></a>二. 构造函数继承</h5><p>构造函数继承，即在<strong>子类的构造函数中执行父类的构造函数</strong>（使用call或者apply方法），并为其绑定子类的<code>this</code>，让父类的构造函数把成员属性和方法都挂到<code>子类的this</code>上去，这样既能<strong>避免实例之间共享一个原型实例</strong>，又能向<strong>父类构造方法传参</strong></p><p>构造函数继承的缺点:</p><p>1.继承不到父类原型上的属性和方法</p><h5 id="三-组合式继承"><a href="#三-组合式继承" class="headerlink" title="三. 组合式继承"></a>三. 组合式继承</h5><p>原型链继承和构造函数继承组合起来使用</p><p>组合式继承的缺点:</p><p>1.每次创建子类实例都执行了两次构造函数(<code>Parent.call()</code>和<code>new Parent()</code>)，虽然这并不影响对父类的继承，但子类创建实例时，原型中会存在两份相同的属性和方法，这并不优雅</p><h5 id="四-寄生式组合继承"><a href="#四-寄生式组合继承" class="headerlink" title="四. 寄生式组合继承"></a>四. 寄生式组合继承</h5><p>为了解决构造函数被执行两次的问题, 我们将<code>指向父类实例</code>改为<code>指向父类原型</code>, 减去一次构造函数的执行</p><p>寄生式组合继承的缺点:</p><p>1.由于子类原型和父类原型指向同一个对象，我们对子类原型的操作会影响到父类原型，例如给<code>Child.prototype</code>增加一个getName()方法，那么会导致<code>Parent.prototype</code>也增加或被覆盖一个getName()方法，为了解决这个问题，我们给<code>Parent.prototype</code>做一个浅拷贝 <code>Object.create(Parent.prototype)</code></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 父类初始化实例属性和原型属性</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Parent</span>(<span class="hljs-params">name</span>)</span>&#123;<span class="hljs-keyword">this</span>.name = name<span class="hljs-keyword">this</span>.hobby = [<span class="hljs-string">"吃饭"</span>, <span class="hljs-string">"睡觉"</span>];&#125;Parent.prototype.getName = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Child</span>(<span class="hljs-params">name,age</span>) </span>&#123;    <span class="hljs-comment">// 构造函数继承</span>    Parent.call(<span class="hljs-keyword">this</span>, name)     <span class="hljs-keyword">this</span>.age = age&#125;<span class="hljs-comment">//原型链继承</span><span class="hljs-comment">// Child.prototype = new Parent()</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">inheritPrototype</span>(<span class="hljs-params">Child,Parent</span>)</span>&#123; <span class="hljs-keyword">let</span> parentProto = <span class="hljs-built_in">Object</span>.create(Parent.prototype)<span class="hljs-comment">//创建父类原型的一个副本</span> parentProto.constructor = Child Child.prototype = parentProto <span class="hljs-comment">//子类原型指向父类原型</span>&#125;<span class="hljs-comment">// 将父类原型指向子类</span>inheritPrototype(Child, Parent);<span class="hljs-comment">// 新增子类原型属性</span>Child.prototype.sayAge = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.age);&#125;;<span class="hljs-keyword">let</span> instance1 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"儿子1"</span>, <span class="hljs-number">23</span>);<span class="hljs-keyword">let</span> instance2 = <span class="hljs-keyword">new</span> Child(<span class="hljs-string">"儿子2"</span>, <span class="hljs-number">23</span>);instance1.hobby.push(<span class="hljs-string">"打豆豆"</span>);<span class="hljs-built_in">console</span>.log(instance1.hobby);<span class="hljs-comment">// ["吃饭", "睡觉"，"打豆豆"]</span><span class="hljs-built_in">console</span>.log(instance2.hobby);<span class="hljs-comment">// ["吃饭", "睡觉"]</span></code></pre></div><blockquote><p>以上四种继承方式是在ES5环境下继承的实现，具体实现过程：</p><p>一开始最容易想到的是<code>原型链继承</code>，通过把子类实例的原型指向父类实例来继承父类的属性和方法，但原型链继承的缺陷在于<code>对子类实例继承的引用类型的修改会影响到所有的实例对象</code>以及<code>无法向父类的构造方法传参</code>。<br>因此我们引入了<code>构造函数继承</code>, 通过在子类构造函数中调用父类构造函数，并传入子类this来获取父类的属性和方法，但构造函数继承也存在缺陷，构造函数继承<code>不能继承到父类原型链上的属性和方法</code>。<br>所以我们综合了两种继承的优点，提出了<code>组合式继承</code>，但组合式继承也引入了新的问题，它<code>每次创建子类实例都执行了两次父类构造方法</code>，我们通过将<code>子类原型指向父类实例</code>改为<code>子类原型指向父类原型的浅拷贝</code>来解决这一问题，也就是最终实现 —— <code>寄生组合式继承</code></p></blockquote><h5 id="五-ES6中的继承方式"><a href="#五-ES6中的继承方式" class="headerlink" title="五.ES6中的继承方式"></a>五.ES6中的继承方式</h5><p>用class定义类，用extends继承类，用super()表示父类</p><div class="hljs"><pre><code class="hljs js">创建父类<span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">Father</span></span>&#123;  <span class="hljs-keyword">constructor</span>(name) &#123;   <span class="hljs-comment">//构造器代码，new时自动执行</span>      <span class="hljs-keyword">this</span>.name = name;  &#125;  work()&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name+<span class="hljs-string">'刷碗'</span>);    &#125;&#125; 创建子类并继承父类<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123;  <span class="hljs-keyword">constructor</span>() &#123;   <span class="hljs-keyword">super</span>()  <span class="hljs-comment">//表示父类</span>  &#125;&#125;<span class="hljs-keyword">var</span> son=<span class="hljs-keyword">new</span> Son( )son.work()</code></pre></div><h4 id="16-ES6新增特性"><a href="#16-ES6新增特性" class="headerlink" title="16.ES6新增特性"></a>16.ES6新增特性</h4><p>常用的主要有</p><ul><li><h5 id="let-const"><a href="#let-const" class="headerlink" title="let/const"></a>let/const</h5><ul><li><p>let</p><p>1.用于声明变量的关键字</p><p>2.let声明的变量有一个块级作用域范围</p></li><li><p>const</p><p>1.用于声明一个只读的常量</p><p>2.一旦声明必须赋值,并且声明后不能再修改<br>3.如果声明的是复合类型数据，可以修改其属性</p></li></ul><p><code>var</code>,<code>let</code>和<code>const</code>的区别是什么？</p><p>1.var声明变量存在变量提升，let和const不存在变量提升</p><p>2.let和const声明形成块作用域</p><p>3.同一作用域下let和const不能声明同名变量，而var可以</p></li><li><h5 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h5><p>ES6中使用箭头函数(=&gt;)来定义函数，有以下特点：</p><ul><li><p>当函数体中只有一个表达式或值需要返回，不需要 return 语句，箭头函数就会有一个隐式的返回。</p></li><li><p>箭头函数中有一个参数，则可以省略括号</p></li><li><p>箭头函数不能访问arguments对象，可以使用rest参数来获得在箭头函数中传递的所有参数</p></li></ul></li><li><h5 id="模板字符串"><a href="#模板字符串" class="headerlink" title="模板字符串"></a>模板字符串</h5><p>反引号和使用<code>${express}</code>嵌入一个表达式组成</p></li><li><h5 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h5><p>在ES6中可以从数组和对象中提取值，对变量进行赋值，称为解构赋值。</p><p>解构赋值就是只要等号两边的模式相同，左边的变量就会被对应赋值。</p><p>解构赋值允许指定默认值。应该注意undefined，因为undefined是不能赋值的</p></li><li><h5 id="模块的导入-import-和导出-export-default-export"><a href="#模块的导入-import-和导出-export-default-export" class="headerlink" title="模块的导入(import)和导出(export default/export)"></a>模块的导入(import)和导出(export default/export)</h5></li><li><h5 id="Promise"><a href="#Promise" class="headerlink" title="Promise"></a>Promise</h5><p>Promise 是异步编程的一种解决方案。以同步的方式写异步的代码，避免了多层回调函数嵌套(回调地狱)问题。</p><p>一个Promise有几种状态：</p><ol><li>pending初始状态，既不是成功状态，也不是失败状态。</li><li>fulfilled表示操作成功完成。</li><li>rejected表示操作失败。</li></ol><p>pending 状态的 Promise 对象会触发 fulfilled/rejected 状态，一旦状态改变，Promise 对象的 then 方法就会被调用；否则就会触发 catch()方法</p><p><strong>Promise.all()</strong></p><p><code>Promise.all(iterable)</code>用于将多个Promise 实例包装成一个新的 Promise实例，参数为一组 Promise 实例组成的数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>);<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>);<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">3</span>);<span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1,p2,p3]);p.then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;  <span class="hljs-built_in">console</span>.log(data) <span class="hljs-comment">// [1,2,3]</span>&#125;------------------------------------------------<span class="hljs-keyword">let</span> p1 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">1</span>)<span class="hljs-keyword">let</span> p2 = <span class="hljs-built_in">Promise</span>.resolve(<span class="hljs-number">2</span>)<span class="hljs-keyword">let</span> p3 = <span class="hljs-built_in">Promise</span>.reject(<span class="hljs-number">3</span>)<span class="hljs-keyword">let</span> p = <span class="hljs-built_in">Promise</span>.all([p1, p2, p3])p.then(<span class="hljs-function"><span class="hljs-params">data</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(data)&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"err:"</span> + err) <span class="hljs-comment">// 3</span>&#125;)</code></pre></div><p>当 p1, p2, p3 状态都 Resolved 的时候，p 的状态才会 Resolved;</p><p>只要有一个实例 Rejected ，此时第一个被 Rejected 的实例返回值就会传递给 P 的回调函数(只要有一个失败了就直接失败)</p><p><strong>Promise.race()</strong></p><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br><code>const p = Promise.race([p1, p2, p3]);</code></p><p>说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态</p></li><li><h5 id="async-await"><a href="#async-await" class="headerlink" title="async/await"></a>async/await</h5><p><code>async</code> 是异步的意思，而 <code>await</code> 是 <code>async wait</code>的简写，即异步等待</p><p>从语义上理解 <code>async</code> 用于声明一个 <code>function</code> 是异步的，<code>await</code> 用于等待一个异步方法执行完成</p><p>另外 <code>await</code> 只能出现在 <code>async</code> 函数中</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">return</span> <span class="hljs-string">"this is async"</span>&#125;<span class="hljs-keyword">const</span> res = test()<span class="hljs-built_in">console</span>.log(res)<span class="hljs-comment">// Promise &#123;&lt;resolved&gt;: "this is async"&#125;</span></code></pre></div><p><code>async</code> 函数返回的是一个 Promise 对象</p><p>实现一个业务需求：多个请求，每个请求依赖于上一个请求的结果</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">takeTime</span>(<span class="hljs-params">n</span>)</span>&#123;<span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(n+<span class="hljs-number">200</span>),n)&#125;)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step1</span>(<span class="hljs-params">n</span>)</span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)<span class="hljs-keyword">return</span> takeTime(n)&#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step2</span>(<span class="hljs-params">n</span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)  <span class="hljs-keyword">return</span> takeTime(n) &#125;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">step3</span>(<span class="hljs-params">n</span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>)    <span class="hljs-keyword">return</span> takeTime(n)&#125;-----------------------------------<span class="hljs-comment">//使用Promise</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">200</span>;    step1(time1)    .then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))    .then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))    .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>)    &#125;)&#125;doIt();-------------------------------------<span class="hljs-comment">//使用async/await</span><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">doIt</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> step1(time1);    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> step2(time2);    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> step3(time3);    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);&#125;doIt();</code></pre></div><p>优点：</p><ul><li><p>内置执行器</p><p><code>async</code> 函数自带执行器，也就是说，<code>async</code> 函数的执行，与普通函数一模一样，只要一行</p></li><li><p>更好的语义</p><p><code>async</code> 和 <code>await</code>，比起 <code>*</code> 和 <code>yield</code>，语义更清楚了，<code>async</code> 表示函数里有异步操作，<code>await</code> 表示紧跟在后面的表达式需要等待结果</p></li></ul><p>缺点：</p><p>滥用 <code>await</code> 可能会导致性能问题，因为 <code>await</code> 会阻塞代码，也许之后的异步代码并不依赖于前者，但仍然需要等待前者完成，导致代码失去了并发性</p></li><li><p>数组字符串的新方法</p></li></ul><h4 id="17-从输入URL到页面加载完中间发生了什么"><a href="#17-从输入URL到页面加载完中间发生了什么" class="headerlink" title="17.从输入URL到页面加载完中间发生了什么"></a>17.从输入URL到页面加载完中间发生了什么</h4><p>大致过程：</p><ol><li><p>DNS解析</p></li><li><p>TCP连接</p></li><li><p>发送HTTP请求</p></li><li><p>服务器处理请求并返回需要的数据</p></li><li><p>浏览器解析渲染页面</p></li><li><p>连接结束</p></li></ol><p>输入了一个域名,域名通过DNS解析,找到这个域名对应的ip地址,通过TCP连接,发送HTTP请求，WEB服务器处理请求并返回数据,浏览器根据返回数据构建DOM树,通过渲染引擎及js解析引擎将页面渲染出来,关闭tcp连接</p><h4 id="18-git相关"><a href="#18-git相关" class="headerlink" title="18.git相关"></a>18.git相关</h4><p>（1） 你的项目是如何管理的？</p><p>答：主要通过git来进行项目版本控制的</p><p>（2） 说几个git常用命令？</p><p>答：我工作中常用的有git add ,git status,git commit –m,git push,git pull等</p><p>（3） 说一下多人操作同一个文件，如果出现冲突该如何解决？</p><p>答：当遇到多人协作修改同一个文件时出现冲突，我先将远程文件先git pull下来，手动修改冲突代码后，再git add ,git commit,git push再上传到远程仓库。如果pull也pull不下来提示冲突的话，可以先通过git stash暂存下来，然后再pull拉取，然后git stash pop，取出原来写的，手动修改，然后提交</p><h4 id="19-浅拷贝、深拷贝"><a href="#19-浅拷贝、深拷贝" class="headerlink" title="19.浅拷贝、深拷贝"></a>19.浅拷贝、深拷贝</h4><ul><li><p><strong>浅拷贝：</strong> 创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。</p><blockquote><p><strong>浅拷贝的实现方式：</strong></p><p><strong>Object.assign() 方法</strong>：用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。它将返回目标对象。</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;    name: <span class="hljs-string">"tom"</span>,    book: &#123;        title: <span class="hljs-string">"You Don't Know JS"</span>,        price: <span class="hljs-string">"25"</span>    &#125;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">Object</span>.assign(&#123;&#125;,a);<span class="hljs-built_in">console</span>.log(b);a.name = <span class="hljs-string">"change"</span>;a.book.price = <span class="hljs-string">"55"</span>;<span class="hljs-built_in">console</span>.log(a);<span class="hljs-built_in">console</span>.log(b);</code></pre></div><blockquote><p><strong>Array.prototype.slice()：</strong>slice() 方法返回一个新的数组对象，这一对象是一个由 begin和end（不包括end）决定的原数组的浅拷贝。原始数组不会被改变。</p><p>展开语法（…）</p></blockquote><p>应用场景：寄生式组合继承</p></li><li><p><strong>深拷贝：</strong> 将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象。</p><blockquote><p><strong>深拷贝的实现方式：</strong></p><p>JSON.parse(JSON.stringify(object)): 缺点诸多（会忽略undefined、symbol、函数；不能解决循环引用；不能处理正则、new Date()）</p></blockquote><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> a = &#123;    name: <span class="hljs-string">"tom"</span>,    book: &#123;        title: <span class="hljs-string">"You Don't Know JS"</span>,        price: <span class="hljs-string">"45"</span>    &#125;&#125;<span class="hljs-keyword">let</span> b = <span class="hljs-built_in">JSON</span>.parse(<span class="hljs-built_in">JSON</span>.stringify(a));<span class="hljs-built_in">console</span>.log(b);</code></pre></div><p>浅拷贝+递归 （只考虑了普通的 object和 array两种数据类型）</p></li></ul><h4 id="20-跨域的解决方案"><a href="#20-跨域的解决方案" class="headerlink" title="20.跨域的解决方案"></a>20.跨域的解决方案</h4><p>产生跨域的情况有：不同协议，不同域名，不同端口的域名和ip地址的访问都会产生跨域。</p><ul><li>代理（前端代理和后端代理）</li></ul><p>前端代理,在vue中主要是通过vue.config.js文件来配置的，其中有个proxyTable来配置跨域的</p><ul><li>CORS</li></ul><p>CORS全称叫跨域资源共享，主要是后台工程师设置后端代码来达到前端跨域请求的</p><p>​ 注：现在主流框架都是用代理和CORS跨域实现的</p><h4 id="21-JavaScript执行机制"><a href="#21-JavaScript执行机制" class="headerlink" title="21.JavaScript执行机制"></a>21.JavaScript执行机制</h4><p>JavaScript是一门单线程语言</p><p><strong>JS执行步骤</strong></p><ol><li><strong>先执行</strong>执行栈中的<strong>同步任务</strong>。</li><li><strong>异步任务</strong>（回调函数）放入<strong>任务队列</strong>中。</li><li>一旦执行栈中的所有<strong>同步任务执行完毕</strong>，系统就会按次序<strong>读取</strong>任务队列中的<strong>异步任务</strong>，于是被读取的异步任务结束等待状态，<strong>进入执行栈</strong>，开始<strong>执行</strong>。</li></ol><p>事件循环(Event Loop)是js实现异步的一种方法，也是js的执行机制。</p><p>除了广义的同步任务和异步任务，我们对任务有更精细的定义：</p><ul><li><p>macro-task(宏任务)：包括整体js代码，setTimeout，setInterval</p></li><li><p>micro-task(微任务)：Promise.then,process.nextTick</p><p>注：</p><p>1.一般js代码是同步的，promise也是同步执行的</p><p>2.setTimeout，setInterval是异步的</p><p>3.promise需要resolve或者reject才会执行then或者catch里面的内容</p></li></ul><p>事件循环，宏任务，微任务的关系</p><ol><li>同步的代码会按照执行顺序执行，其它代码属于宏任务的放到宏队列，微任务放到微队列</li><li>执行顺序是宏任务-微任务-宏任务……，进入整体代码(宏任务)后，开始第一次循环，接着执行所有的微任务。然后再次从宏任务开始，找到任务队列里的第一个宏任务执行完毕，再执行所有微任务。再进入任务队列里的下一个宏任务</li></ol><h5 id="总结：（面试回答）"><a href="#总结：（面试回答）" class="headerlink" title="总结：（面试回答）"></a>总结：（面试回答）</h5><p>js是一门单线程语言。整体js代码作为第一个宏任务进入主线程中，同步代码按照执行顺序执行，其它代码划分为宏任务和微任务，放入任务队列中。一旦同步任务执行完毕，就按照宏任务=&gt;微任务=&gt;宏任务的执行顺序执行，因为整体js代码为宏任务，所以接着执行所有的微任务。然后再从宏任务开始，找到任务队列中第一个宏任务执行完毕，再执行所有微任务。再进入任务队列里的下一个宏任务。直到全部代码执行完毕</p><h4 id="22-垃圾回收机制"><a href="#22-垃圾回收机制" class="headerlink" title="22.垃圾回收机制"></a>22.垃圾回收机制</h4><p>JavaScript垃圾回收机制的原理：找出不再使用的变量，然后释放掉其占用的内存，但是这个过程不是时时的，为此垃圾回收器会按照固定的时间间隔周期性的执行</p><ul><li><p><strong>标记清除</strong></p><p>垃圾收集器先给内存中所有对象加上标记，然后从根节点开始遍历，去掉被引用的对象和运行环境中对象的标记，剩下的被标记的对象就是无法访问的等待回收的对象。</p></li><li><p>引用计数</p><p>给一个变量赋引用类型值，则该值的引用次数就是1。如果又把该值赋给另一个变量，则该值引用次数加1；相反，如果包含该值的变量又取得另外一个值，则该值的引用次数减1；垃圾回收器会回收引用次数为0的值所占用的内存空间。但是当对象循环引用时，会导致引用次数永远无法归零，造成内存无法释放。</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网页、移动端特效和本地存储</title>
    <link href="/2020/07/06/%E7%BD%91%E9%A1%B5%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/"/>
    <url>/2020/07/06/%E7%BD%91%E9%A1%B5%E3%80%81%E7%A7%BB%E5%8A%A8%E7%AB%AF%E7%89%B9%E6%95%88%E5%92%8C%E6%9C%AC%E5%9C%B0%E5%AD%98%E5%82%A8/</url>
    
    <content type="html"><![CDATA[<p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly91c2VyLWdvbGQtY2RuLnhpdHUuaW8vMjAyMC82LzgvMTcyOTQxZWY4MzYyZjVkNA?x-oss-process=image/format,png" srcset="/img/loading.gif" alt=""></p><h2 id="元素偏移量-offset-系列"><a href="#元素偏移量-offset-系列" class="headerlink" title="元素偏移量 offset 系列"></a>元素偏移量 offset 系列</h2><h3 id="1-offset-概述"><a href="#1-offset-概述" class="headerlink" title="1.offset 概述"></a>1.offset 概述</h3><p>offset系列相关属性可以动态的得到该元素的位置（偏移）、大小等。</p><ol><li>获得元素距离带有定位父元素的位置</li><li>获得元素自身的大小（宽度高度）<br>注意：返回的数值都不带单位</li></ol><p>offset 系列常用属性：<br><img src="https://img-blog.csdnimg.cn/20200608221513354.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200608221433199.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="2-offset-与-style-区别"><a href="#2-offset-与-style-区别" class="headerlink" title="2.offset 与 style 区别"></a>2.offset 与 style 区别</h3><h4 id="offset"><a href="#offset" class="headerlink" title="offset"></a>offset</h4><ul><li><p>offset 可以得到任意样式表中的样式值</p></li><li><p>offset 系列获得的数值是没有单位的</p></li><li><p>offsetWidth 包含padding+border+width</p></li><li><p>offsetWidth 等属性是只读属性，只能获取不能赋值</p></li></ul><blockquote><p>所以，我们想要获取元素大小位置，用offset更合适</p></blockquote><h4 id="style"><a href="#style" class="headerlink" title="style"></a>style</h4><ul><li><p>style 只能得到行内样式表中的样式值</p></li><li><p>style.width 获得的是带有单位的字符串</p></li><li><p>style.width 获得不包含padding和border 的值</p></li><li><p>style.width 是可读写属性，可以获取也可以赋值</p></li></ul><blockquote><p>所以，我们想要给元素更改值，则需要用style改变</p></blockquote><h2 id="元素可视区-client-系列"><a href="#元素可视区-client-系列" class="headerlink" title="元素可视区 client 系列"></a>元素可视区 client 系列</h2><p>使用 client 系列的相关属性来获取元素可视区的相关信息,可以动态的得到该元素的边框大小、元素大小等。<br><img src="https://img-blog.csdnimg.cn/20200608221613791.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200608221635263.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>补充的知识点：</p><ul><li><p>立即执行函数 (function() {})() 或者 (function(){}())<br>主要作用： 创建一个独立的作用域。 避免了命名冲突问题</p></li><li><p>mouseenter 和mouseover的区别<br>mouseenter 鼠标事件：当鼠标移动到元素上时就会触发 mouseenter 事件<br>1.mouseover 鼠标经过自身盒子会触发，经过子盒子还会触发。 mouseenter 只会经过自身盒子触发，因为mouseenter不会冒泡<br>2.跟mouseenter搭配 ，鼠标离开 mouseleave 同样不会冒泡</p></li><li><p><strong>淘宝 flexible.js 源码分析</strong></p><p>下面三种情况都会刷新页面都会触发 load 事件。<br>1.a标签的超链接<br>2.F5或者刷新按钮（强制刷新）<br>3.前进后退按钮<br>但是 火狐中，有个“往返缓存”，这个缓存中不仅保存着页面数据，还保存了DOM和JavaScript的状态；实际上是将整个页面都保存在了内存里。所以此时后退按钮不能刷新页面。<br>此时可以使用 pageshow事件来触发，这个事件在页面显示时触发，无论页面是否来自缓存。在重新加载页面中，pageshow会在load事件触发后触发；根据事件对象中的persisted来判断是否是缓存中的页面触发的pageshow事件,<code>注意这个事件给window添加。</code></p><div class="hljs"><pre><code class="hljs js">(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">flexible</span>(<span class="hljs-params">window, document</span>) </span>&#123;    <span class="hljs-comment">// 获取的html 的根元素</span>    <span class="hljs-keyword">var</span> docEl = <span class="hljs-built_in">document</span>.documentElement        <span class="hljs-comment">// dpr 物理像素比</span>    <span class="hljs-keyword">var</span> dpr = <span class="hljs-built_in">window</span>.devicePixelRatio || <span class="hljs-number">1</span>    <span class="hljs-comment">// adjust body font size  设置我们body 的字体大小</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setBodyFontSize</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-comment">// 如果页面中有body 这个元素 就设置body的字体大小</span>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">document</span>.body) &#123;            <span class="hljs-built_in">document</span>.body.style.fontSize = (<span class="hljs-number">12</span> * dpr) + <span class="hljs-string">'px'</span>        &#125; <span class="hljs-keyword">else</span> &#123;            <span class="hljs-comment">// 如果页面中没有body 这个元素，则等着 我们页面主要的DOM元素加载完毕再去设置body</span>            <span class="hljs-comment">// 的字体大小</span>            <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'DOMContentLoaded'</span>, setBodyFontSize)        &#125;    &#125;    setBodyFontSize();    <span class="hljs-comment">// set 1rem = viewWidth / 10    设置我们html 元素的文字大小,让网页根据html元素的文字大小实现适配</span>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">setRemUnit</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> rem = docEl.clientWidth / <span class="hljs-number">10</span>        docEl.style.fontSize = rem + <span class="hljs-string">'px'</span>    &#125;    setRemUnit()    <span class="hljs-comment">// reset rem unit on page resize  当我们页面尺寸大小发生变化的时候，要重新设置下rem 的大小</span>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'resize'</span>, setRemUnit)        <span class="hljs-comment">// pageshow 是我们重新加载页面触发的事件</span>    <span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">'pageshow'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// e.persisted 返回的是true 就是说如果这个页面是从缓存取过来的页面，也需要从新计算一下rem 的大小</span>        <span class="hljs-keyword">if</span> (e.persisted) &#123;            setRemUnit()        &#125;    &#125;)    <span class="hljs-comment">// detect 0.5px supports  有些移动端的浏览器不支持0.5像素的写法</span>    <span class="hljs-keyword">if</span> (dpr &gt;= <span class="hljs-number">2</span>) &#123;        <span class="hljs-keyword">var</span> fakeBody = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'body'</span>)        <span class="hljs-keyword">var</span> testElement = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>)        testElement.style.border = <span class="hljs-string">'.5px solid transparent'</span>        fakeBody.appendChild(testElement)        docEl.appendChild(fakeBody)        <span class="hljs-keyword">if</span> (testElement.offsetHeight === <span class="hljs-number">1</span>) &#123;            docEl.classList.add(<span class="hljs-string">'hairlines'</span>)        &#125;        docEl.removeChild(fakeBody)    &#125;&#125;(<span class="hljs-built_in">window</span>, <span class="hljs-built_in">document</span>))</code></pre></div></li></ul><h2 id="元素滚动-scroll-系列"><a href="#元素滚动-scroll-系列" class="headerlink" title="元素滚动 scroll 系列"></a><strong>元素滚动 scroll 系列</strong></h2><p>使用 scroll 系列的相关属性可以动态的得到该元素的大小、滚动距离等<br><img src="https://img-blog.csdnimg.cn/20200608221713881.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>注意事项：</p><ol><li>页面滚动事件 scroll 因为是页面滚动，所以事件源是document</li><li><strong>页面被卷去的头部</strong>：可以通过<strong>window.pageYOffset</strong> 获得 ，如果是被卷去的左侧：可以通过window.pageXOffset获得</li><li><strong>元素</strong>被卷去的头部是<strong>element.scrollTop</strong></li></ol><p><strong>页面被卷去的头部兼容性解决方案</strong><br>通常有如下几种写法：</p><ol><li>声明了 DTD，使用 document.documentElement.scrollTop</li><li>未声明 DTD，使用 document.body.scrollTop</li><li>新方法 window.pageYOffset和 window.pageXOffset，IE9 开始支持</li></ol><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getScroll</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123;      left: <span class="hljs-built_in">window</span>.pageXOffset || <span class="hljs-built_in">document</span>.documentElement.scrollLeft || <span class="hljs-built_in">document</span>.body.scrollLeft||<span class="hljs-number">0</span>,      top: <span class="hljs-built_in">window</span>.pageYOffset || <span class="hljs-built_in">document</span>.documentElement.scrollTop || <span class="hljs-built_in">document</span>.body.scrollTop || <span class="hljs-number">0</span>    &#125;; &#125; 使用的时候  getScroll().left</code></pre></div><h2 id="三大系列总结"><a href="#三大系列总结" class="headerlink" title="三大系列总结"></a>三大系列总结</h2><p><img src="https://img-blog.csdnimg.cn/20200608222716986.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>主要用法：<br>1.<strong>offset</strong> 经常用于获得<strong>元素位置</strong> offsetLeft offsetTop<br>2.<strong>client</strong> 经常用于获取<strong>元素大小</strong> clientWidth clientHeight<br>3.<strong>scroll</strong> 经常用于获取<strong>滚动距离</strong> scrollTop scrollLeft<br>4.<strong>页面</strong>滚动的距离通过 <strong>window.pageYOffset</strong>、window.pageXOffset 获得<br><img src="https://img-blog.csdnimg.cn/20200608223520818.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="触屏事件"><a href="#触屏事件" class="headerlink" title="触屏事件"></a>触屏事件</h2><p>常见的触屏事件如下：<br><img src="https://img-blog.csdnimg.cn/20200608223801789.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><strong>触摸事件对象（TouchEvent）</strong><br>是一类描述手指在触摸平面（触摸屏、触摸板等）的状态变化的事件<br>重点触摸事件对象列表：<br><img src="https://img-blog.csdnimg.cn/20200608223937929.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>因为平时我们都是给元素注册触摸事件，所以重点记住 <strong>targetTocuhes</strong><br><strong>移动端拖动元素</strong></p><ol><li>touchstart、touchmove、touchend 可以实现拖动元素</li><li>但是拖动元素需要当前手指的坐标值 我们可以使用 <strong>targetTouches[0]</strong> 里面的<strong>pageX</strong> 和 <strong>pageY</strong></li><li>移动端拖动的原理： 手指移动中，计算出手指移动的距离。然后用盒子原来的位置 + 手指移动的距离</li><li>手指移动的距离： 手指滑动中的位置 减去 手指刚开始触摸的位置<br>拖动元素三步曲：<br>（1） 触摸元素 touchstart： 获取手指初始坐标，同时获得盒子原来的位置<br>（2） 移动手指 touchmove： 计算手指的滑动距离，并且移动盒子<br>（3） 离开手指 touchend:<br><strong>注意： 手指移动也会触发滚动屏幕所以这里要阻止默认的屏幕滚动 e.preventDefault();</strong></li></ol><p><strong>补充知识点</strong>：<br><strong>classList 属性</strong><br>classList属性是HTML5新增的一个属性，返回元素的类名。ie10以上版本支持。<br>该属性用于在元素中添加、移除及切换 CSS 类。</p><ul><li><strong>添加类：</strong><br>element.classList.add（’类名’）；</li></ul><div class="hljs"><pre><code class="hljs javascript">focus.classList.add(<span class="hljs-string">'current'</span>);</code></pre></div><ul><li><strong>移除类：</strong><br>element.classList.remove（’类名’）;</li></ul><div class="hljs"><pre><code class="hljs javascript">focus.classList.remove(<span class="hljs-string">'current'</span>);</code></pre></div><ul><li><strong>切换类：</strong><br>element.classList.toggle（’类名’）;</li></ul><div class="hljs"><pre><code class="hljs javascript">focus.classList.toggle(<span class="hljs-string">'current'</span>);</code></pre></div><p><code>注意:以上方法里面，所有类名都不带点</code></p><p><strong>click 延时解决方案</strong><br>移动端 click 事件会有 300ms 的延时，原因是移动端屏幕双击会缩放(double tap to zoom) 页面。<br>解决方案：<br>1.禁用缩放。 浏览器禁用默认的双击缩放行为并且去掉 300ms 的点击延迟。</p><div class="hljs"><pre><code class="hljs plain">&lt;meta name&#x3D;&quot;viewport&quot; content&#x3D;&quot;user-scalable&#x3D;no&quot;&gt;</code></pre></div><p>2.使用插件。 fastclick 插件解决 300ms 延迟。</p><div class="hljs"><pre><code class="hljs plain">document.addEventListener(&#39;DOMContentLoaded&#39;,function () &#123;&#x2F;*等页面文档加载完成 不需要等所有的资源*&#x2F;FastClick.attach(document.body);&#125;);</code></pre></div><h2 id="本地存储"><a href="#本地存储" class="headerlink" title="本地存储"></a>本地存储</h2><h3 id="1-特点"><a href="#1-特点" class="headerlink" title="1.特点"></a>1.特点</h3><p>1、数据存储在用户浏览器中<br>2、设置、读取方便、甚至页面刷新不丢失数据<br>3、容量较大，sessionStorage约5M、localStorage约20M<br>4、只能存储字符串，可以将对象JSON.stringify() 编码后存储</p><h3 id="2-window-sessionStorage"><a href="#2-window-sessionStorage" class="headerlink" title="2.window.sessionStorage"></a>2.window.sessionStorage</h3><p>1、生命周期为关闭浏览器窗口<br>2、在同一个窗口(页面)下数据可以共享<br>3、以键值对的形式存储使用</p><p>存储数据：</p><div class="hljs"><pre><code class="hljs javascript">sessionStorage.setItem(key, value)</code></pre></div><p>获取数据：</p><div class="hljs"><pre><code class="hljs javascript">sessionStorage.getItem(key)</code></pre></div><p>删除数据：</p><div class="hljs"><pre><code class="hljs javascript">sessionStorage.removeItem(key)</code></pre></div><p>清空数据：(所有都清除掉)</p><div class="hljs"><pre><code class="hljs javascript">sessionStorage.clear()</code></pre></div><h3 id="3-window-localStorage"><a href="#3-window-localStorage" class="headerlink" title="3.window.localStorage"></a>3.window.localStorage</h3><p>1、声明周期永久生效，除非手动删除 否则关闭页面也会存在<br>2、可以多窗口（页面）共享（同一浏览器可以共享）</p><p>3、以键值对的形式存储使用</p><p>存储数据：</p><div class="hljs"><pre><code class="hljs javascript">localStorage.setItem(key, value)</code></pre></div><p>获取数据：</p><div class="hljs"><pre><code class="hljs javascript">localStorage.getItem(key)</code></pre></div><p>删除数据：</p><div class="hljs"><pre><code class="hljs javascript">localStorage.removeItem(key)</code></pre></div><p>清空数据：(所有都清除掉)</p><div class="hljs"><pre><code class="hljs javascript">localStorage.clear()</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试——CSS篇</title>
    <link href="/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87/"/>
    <url>/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="1-盒子水平垂直居中的五大方案"><a href="#1-盒子水平垂直居中的五大方案" class="headerlink" title="1.盒子水平垂直居中的五大方案"></a>1.盒子水平垂直居中的五大方案</h3><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span> auto;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;    &#125;<span class="hljs-selector-class">.box</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><p>定位（三种） 前提条件：盒子的父元素设置相对定位</p><blockquote><p>1.box盒子设置绝对定位，<code>left：50%;top:50%;</code>,再使用margin移动自身宽高的一半（已知box盒子的宽高）</p></blockquote><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">position</span>: relative;   &#125;   <span class="hljs-selector-class">.box</span>&#123;       <span class="hljs-attribute">position</span>: absolute;       <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;     &#125;</code></pre></div><blockquote><p>2.box盒子设置绝对定位，并且left,right,top,bottom设置为0,margin:auto（未知box盒子的宽高）</p></blockquote><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>:auto; &#125;</code></pre></div><blockquote><p>3.box盒子设置绝对定位，<code>left：50%;top:50%;</code>，再使用css3的transform属性，设置为<code>translate（-50%,-50%）;</code>移动自身宽高的一半，有兼容性问题（未知box盒子的宽高）</p></blockquote><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);&#125;</code></pre></div><blockquote><p>4.给居中盒子的父元素使用display:flex，再设置水平居中<code>justify-content:center；</code>垂直居中<code>align-items:center;</code>（可以不用设置box盒子的宽高，让盒子内容撑开宽高，有兼容性问题）</p></blockquote><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">display</span>: flex;       <span class="hljs-attribute">justify-content</span>: center;       <span class="hljs-attribute">align-items</span>: center;   &#125;</code></pre></div><p>5.使用js,需要给container设置相对定位，并且给container和box设置id(js可以根据id获取该元素)</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;        <span class="hljs-keyword">let</span> cWidth = container.offsetWidth,            cHeight = container.offsetHeight,            bWidth = box.offsetWidth,            bHeight = box.offsetHeight;        box.style.position = <span class="hljs-string">"absolute"</span>;        box.style.left = (cWidth-bWidth)/<span class="hljs-number">2</span> + <span class="hljs-string">'px'</span>;        box.style.top = (cHeight-bHeight)/<span class="hljs-number">2</span> +<span class="hljs-string">'px'</span>;    &lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h3 id="2-盒模型"><a href="#2-盒模型" class="headerlink" title="2.盒模型"></a>2.盒模型</h3><p>盒模型是元素在网页中的实际占位，浏览器把元素（标签）看成一个形象的盒子，每个盒子（即标签）都会有内容(width,height)，边框(border)，以及内容和边框之间的缝隙（即内间距padding），还有盒子与盒子之间的间距（即外边距margin）,</p><p>盒模型包括两种：IE盒模型和标准(W3C)盒模型</p><h4 id="标准-W3C-盒模型"><a href="#标准-W3C-盒模型" class="headerlink" title="标准(W3C)盒模型"></a><strong>标准(W3C)</strong>盒模型</h4><p><img src="https://img-blog.csdnimg.cn/20200531130423268.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p><strong>标准(W3C)盒子模型：</strong>内容content+内边距padding+边框border+外边距margin</p><p>在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。<br>CSS如何设置标准盒模型 box-sizing:content-box;</p></blockquote><p>写页面时经常遇到，当增加内边距、边框和外边距时，不会影响内容区域的尺寸，但是会增加元素框的总尺寸。<br>解决方法：box-sizing:border-box;</p><h4 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h4><p><img src="https://img-blog.csdnimg.cn/20200531130514396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><blockquote><p><strong>IE盒子模型：</strong>内容（content+padding+border）+ 外边距margin</p><p>IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。<br>CSS如何设置IE盒子模型 box-sizing:border-box;</p></blockquote><h3 id="3-清除浮动的方法"><a href="#3-清除浮动的方法" class="headerlink" title="3.清除浮动的方法"></a>3.清除浮动的方法</h3><blockquote><p>清除浮动是为了解决子元素浮动而导致父元素高度塌陷的问题</p></blockquote><p>清除浮动的常用方法：</p><ol><li><p>父元素定义<code>height</code></p></li><li><p>额外标签法</p><p>在有浮动的子元素末尾插入一个没有内容的块级元素， 并添加样式<code>clear:both</code></p></li><li><p>给父级元素使用伪元素</p><p><code>.clearfix::after { content:&quot;&quot;;display: block;clear:both;}</code></p></li><li><p>触发父元素BFC</p><p>给父元素添加样式<code>overflow</code>为<code>hidden</code>或<code>auto</code>，通过触发BFC方式，实现清除浮动</p></li></ol><h3 id="4-BFC"><a href="#4-BFC" class="headerlink" title="4.BFC"></a>4.BFC</h3><p>BFC（ Block Formatting Context ）即<code>块级格式上下文</code>，简单的说，BFC是页面上的一个隔离的独立容器，其内部元素和外部元素不会相互影响</p><p><strong>如何触发BFC？</strong></p><ul><li>根元素(<code>&lt;html&gt;</code>)</li><li>浮动元素（元素的 float 不是 none）</li><li>绝对定位/固定定位元素（元素的 position 为 absolute 或 fixed）</li><li>overflow 值不为 visible 的块元素</li><li>元素<code>display</code>的值为 inline-block 或 table-cell 或 table-caption 或 grid</li></ul><p>BFC的应用场景</p><ul><li><p><strong>清除浮动</strong>：BFC内部的浮动元素会参与高度计算</p></li><li><p><strong>避免某元素被浮动元素覆盖</strong>：BFC的区域不会与浮动元素的区域重叠</p></li><li><p><strong>阻止外边距重叠</strong>：属于同一个BFC的两个相邻Box的margin会发生折叠，不同BFC不会发生折叠</p></li></ul><h3 id="5-position属性"><a href="#5-position属性" class="headerlink" title="5.position属性"></a>5.position属性</h3><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>relative</td><td>生成相对定位的元素，相对于其正常位置进行定位，不脱离文档流。</td></tr><tr><td>absolute</td><td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。</td></tr><tr><td>fixed</td><td>生成固定定位的元素，相对于浏览器窗口进行定位。</td></tr><tr><td>static</td><td>默认值。没有定位，元素出现在正常的文档流中</td></tr><tr><td>sticky</td><td>粘性定位,元素在跨越特定阈值前为相对定位，之后为固定定位</td></tr></tbody></table><h3 id="6-CSS选择器"><a href="#6-CSS选择器" class="headerlink" title="6.CSS选择器"></a>6.CSS选择器</h3><ul><li>通用选择器(*)</li><li>类选择器(.wrap)</li><li>id选择器（#wrap）</li><li>标签选择器（div, h1, p）</li><li>相邻选择器(h1 + p)</li><li>子选择器（ul &gt; li）</li><li>后代选择器（li a）</li><li>伪类选择器（li:first-child，a:hover）</li></ul><blockquote><p>优先级（同权重情况下样式定义最近者为准）：!important &gt; [ id &gt; class &gt; tag ]<br>!important 比内联优先级高</p><p>元素选择符的权值：元素标签（派生选择器）：1，class选择符：10，id选择符：100，内联样式权值最大，为1000</p></blockquote><h3 id="7-rem和em"><a href="#7-rem和em" class="headerlink" title="7.rem和em"></a>7.rem和em</h3><p>rem和em都是相对单位，主要参考的标签不同：</p><ul><li>rem是相对于根节点<code>&lt;html&gt;</code>的字体大小<code>font-size</code>实现的，浏览器默认字号是font-size:16px</li><li>em是相对于父元素的<code>font-size</code>，和百分比%类似，%也是相对于父级的，只不过是%相对于父级宽高，而em相对于父级字号</li></ul><h3 id="8-vw和vh"><a href="#8-vw和vh" class="headerlink" title="8.vw和vh"></a>8.vw和vh</h3><p>vw：viewpoint width，视窗宽度，1vw相当于视窗宽度的1%</p><p>vh：viewpoint height，视窗高度，1vh等于视窗高度的1%。</p><p>vw、vh 与 % 百分比的区别：</p><ul><li>% 是相对于父元素的大小设定的比率，vw、vh 是视窗大小决定的。</li><li>vw、vh 优势在于能够直接获取高度，而用 % 在没有设置 body 高度的情况下，无法正确获得可视区域的高度</li></ul><h3 id="9-手机端如何做适配的"><a href="#9-手机端如何做适配的" class="headerlink" title="9.手机端如何做适配的"></a>9.手机端如何做适配的</h3><p>目前前端主要做适配的方法有：百分比，em,rem,媒体查询(即media query),flex布局（即弹性盒），vw,vh等</p><p>我在项目中主要用的是rem，flex布局，有时会用到媒体查询</p><p>主要操作：</p><p>1.在页面头部设置meta声明的viewport属性。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">meta</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"viewport"</span> <span class="hljs-attr">content</span>=<span class="hljs-string">"width=device-width, initial-scale=1, maximum-scale=1, minimum-scale=1, user-scalable=no"</span>&gt;</span>//width、height、initial-scale、maximum-scale、minimum-scale、user-scalable这些属性，分别表示宽度、高度、初始缩放比例、最大缩放比例、最小缩放比例、是否允许用户缩放</code></pre></div><p>2.主要使用了一个手淘的js库<a href="http://caibaojian.com/t/flexible-js" target="_blank" rel="noopener">flexible.js</a>，在页面变化时,动态获取当前视口宽度width,除以一个固定的数n,得到rem的值,赋值给font-size</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//设置根元素字体大小。此时为宽的100等分</span><span class="hljs-built_in">document</span>.documentElement.style.fontSize = ocument.documentElement.clientWidth / <span class="hljs-number">100</span> + <span class="hljs-string">'px'</span>;</code></pre></div><p>但是如果每次都要手动去计算(px=&gt;rem)有点太过麻烦了，我们可以通过cssrem插件（在VScode中）在编辑的时候直接计算转成rem。所以在开发的时候直接按照设计稿的尺寸写px，编译后会直接转化成rem</p><h3 id="10-display-none和-visibility-hidden的区别"><a href="#10-display-none和-visibility-hidden的区别" class="headerlink" title="10.display: none和 visibility:hidden的区别"></a>10.display: none和 visibility:hidden的区别</h3><p>都是隐藏对应的元素，不同点：</p><ul><li><p>display: none</p><p>不占据空间，会触发reflow（回流），进行渲染。元素及其子元素都会消失。</p></li><li><p>visibility:hidden</p><p>占据空间，只会触发repaint（重绘），因为没有发现位置变化，不进行渲染。</p><p>visibility是继承属性，若子元素使用了visibility:visible，则不继承，这个子孙元素又会显现出来。</p></li></ul><h3 id="11-CSS预处理器"><a href="#11-CSS预处理器" class="headerlink" title="11.CSS预处理器"></a>11.CSS预处理器</h3><p>平时写css用过less、stylus，可以定义变量，嵌套，混入等功能，方便开发人员快速高效写css</p><p>最流行的CSS预处理器</p><ul><li>less</li><li>sass</li><li>stylus</li><li>postcss</li></ul><h3 id="12-CSS-页面常用布局"><a href="#12-CSS-页面常用布局" class="headerlink" title="12.CSS 页面常用布局"></a>12.CSS 页面常用布局</h3><p>中间自适应，两边定宽</p><h4 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h4><ul><li>三者都设置向左浮动</li><li>设置中间部分宽度为100%;</li><li>设置负边距， left设置负左边距为100%, right设置负左边距为负的自身宽度</li><li>设置container的padding值给左右两个子面板留出空间</li><li>设置两个子面板为相对定位，<code>left面板</code>的left值为负的<code>left面板</code>宽度，<code>right面板</code>的right值为负的<code>right面板</code>的值</li></ul><p>但是圣杯布局有个问题：<strong>当面板的部分比两边的子面板宽度小的时候，布局就会乱掉</strong>。因此也就有了双飞翼布局来克服这个问题。如果不增加任何标签，想实现更完美的布局非常困难，因此双飞翼布局在主面板上选择了加一个标签</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 解决浮动引起的高度塌陷 */</span><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;       <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;       <span class="hljs-attribute">clear</span>: both;       <span class="hljs-attribute">display</span>: block;   &#125;<span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">padding</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">float</span>: left;   &#125;   <span class="hljs-comment">/* 中间部分宽度自适应 */</span>   <span class="hljs-selector-class">.center</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;   &#125;   <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-comment">/* 左边栏使用margin-left移动中间部分的宽度，再使用相对定位向左移动自身的宽度 */</span>   <span class="hljs-selector-class">.left</span>&#123;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;       <span class="hljs-attribute">position</span>: relative;       <span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;       <span class="hljs-attribute">position</span>: relative;       <span class="hljs-attribute">right</span>:-<span class="hljs-number">200px</span>;   &#125;</code></pre></div><h4 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h4><ul><li>left、container、right都设置左浮动</li><li>设置container宽度为100%</li><li>设置负边距，left设置margin-left为-100%，right设置margin-left为负的自身宽度</li><li>设置center的margin值为left和right宽度，为左右两个侧栏留出空间</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">" clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;        <span class="hljs-attribute">clear</span>: both;        <span class="hljs-attribute">display</span>: block;    &#125;    <span class="hljs-selector-class">.container</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">float</span>: left;    &#125;    <span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    &#125;        <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;         <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;     &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;    &#125;    <span class="hljs-selector-class">.left</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;    &#125;    <span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;    &#125;</code></pre></div><p>双飞翼布局与圣杯布局的主要差别在于：</p><ul><li><p>双飞翼布局给主面板（中间元素）添加了一个父标签,用来通过margin给子面板腾出空间</p></li><li><p>圣杯布局采用的是padding,而双飞翼布局采用的margin, 解决了圣杯布局的问题</p></li><li><p>双飞翼布局不用设置相对定位，以及对应的left和right值</p></li></ul><h4 id="Flex弹性布局"><a href="#Flex弹性布局" class="headerlink" title="Flex弹性布局"></a>Flex弹性布局</h4><p>缺点：仅支持 IE9 以上浏览器</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: flex;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;    &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        /* flex: 0 0 200px; */ 与使用宽度能够实现同样的效果    &#125;    <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><h4 id="Grid-布局-网格布局"><a href="#Grid-布局-网格布局" class="headerlink" title="Grid 布局(网格布局)"></a>Grid 布局(网格布局)</h4><p>grid-template-columns属性定义每一列的列宽<br>grid-template-rows属性定义每一行的行高</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: grid;        <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span>;<span class="hljs-comment">/* 设置列宽，也可使用百分比 */</span>    &#125;     <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;      &#125;</code></pre></div><h3 id="13-CSS3动画"><a href="#13-CSS3动画" class="headerlink" title="13.CSS3动画"></a>13.CSS3动画</h3><p>CSS3动画大致上包括两种：</p><ul><li>过渡动画：主要通过<code>transition</code>来实现，通过设置过渡属性，运动时间，延迟时间和运动速度实现。</li><li>关键帧动画：主要通过<code>animation</code>配合<code>@keyframes</code>实现</li></ul><p>transition动画和animation动画的主要区别：</p><ul><li>transition动画需要有触发条件，animation不需要</li><li>transition只有开始结束两种状态，而animation可以实现多种状态，并且animation是可以做循环运动甚至是无限运动</li></ul><h3 id="14-CSS3新增特性有哪些"><a href="#14-CSS3新增特性有哪些" class="headerlink" title="14.CSS3新增特性有哪些"></a>14.CSS3新增特性有哪些</h3><p>边框 =&gt; 圆角：border-radius, 盒阴影：box-shadow</p><p>动画 =&gt; transition(过渡动画),animation（关键帧动画）</p><p>背景 =&gt; background-clip（背景图的绘制区域）, background-size(背景图的尺寸),background-origin(背景图的定位区域)</p><p>2D(3D)转换 =&gt; transform（是指变换、变形，是 css3 的一个属性，和 width，height 属性一样）,其属性值有scale | translate（是指元素进行 2D(3D)维度上位移或范围变换）|rotate| perspective（3D转换）</p><p>线性渐变 =&gt; linear-gradient</p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试——HTML篇</title>
    <link href="/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTML%E7%AF%87/"/>
    <url>/2020/07/06/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94HTML%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="HTML5的新特性"><a href="#HTML5的新特性" class="headerlink" title="HTML5的新特性"></a>HTML5的新特性</h3><ul><li><p>标签</p><p>新增语义化标签（<code>header / footer / nav/ aside / section /</code>等）</p><p>增加多媒体标签<code>video</code>和<code>audio</code></p><p>语义化标签有具体的含义，使得样式和结构更加分离</p></li><li><p>属性</p><p>增强表单，主要是增强了<code>input</code>的type属性；<code>meta</code>增加charset以设置字符集；<code>script</code>增加async以异步加载脚本</p></li><li><p>存储</p><p>增加<code>localStorage</code>、<code>sessionStorage</code>和<code>indexedDB</code>，引入了<code>application cache</code>对web和应用进行缓存</p></li><li><p>API</p><p>增加<code>拖放API</code>、<code>地理定位</code>、<code>SVG绘图</code>、<code>canvas绘图</code>、<code>Web Worker</code>、<code>WebSocket</code></p></li></ul><h3 id="doctype的作用是什么？"><a href="#doctype的作用是什么？" class="headerlink" title="doctype的作用是什么？"></a>doctype的作用是什么？</h3><p>声明文档类型，告知浏览器用什么文档标准解析</p><ul><li>怪异模式：浏览器使用自己的模式解析文档，不加doctype时默认为怪异模式</li><li>标准模式：浏览器以W3C的标准解析文档</li></ul><h3 id="cookie-localStorage和sessionStorage"><a href="#cookie-localStorage和sessionStorage" class="headerlink" title="cookie,localStorage和sessionStorage"></a>cookie,localStorage和sessionStorage</h3><ul><li><p><strong>cookies</strong></p><p>一般由服务器生成，可以设置失效时间，大小只有4K左右，HTTP请求头会自动带上cookie，需要存取时封装</p></li><li><p><strong>localStorage</strong></p><p>持久性存储，即使页面关闭也不会被清除，以名值对的方式存储，大小为5M</p><p>localStorage 注意点：</p><ol><li>localStorage 只能存字符串，存取 JSON 数据需配合 JSON.stringify() 和 JSON.parse()</li><li>遇上禁用 setItem 的浏览器，需要使用 try…catch 捕获异常</li></ol></li><li><p><strong>sessionStorage</strong></p><p>仅在当前会话下有效，关闭页面或浏览器后被清除，操作及大小同localStorage</p></li></ul><p>localStorage和sessionStorage有自己存取的方法,<code>存储setItem(),获取getItem(),删除removeItem(),清空clear()</code> ，如：localStorage.setItem(‘属性’，值)</p><h3 id="浏览器渲染的步骤"><a href="#浏览器渲染的步骤" class="headerlink" title="浏览器渲染的步骤"></a>浏览器渲染的步骤</h3><ol><li>HTML 解析，生成 DOM Tree</li><li>CSS 解析，生成 Style Rules</li><li>两者关联生成 Render Tree（渲染树）</li><li>根据渲染树进行Layout（布局）</li><li>根据计算好的信息进行绘制，渲染整个页面</li></ol><blockquote><p>浏览器解析文档的过程中，如果遇到 script 标签，会立即解析脚本，停止解析文档（因为 JS 可能会改变 DOM 和 CSS,如果继续解析会造成浪费）。<br>如果是外部 script, 会等待脚本下载完成之后在继续解析文档。现在 script 标签增加了 defer 和 async 属性，脚本解析会将脚本中改变 DOM 和CSS 的地方解析出来，追加到 DOM Tree 和 Style Rules 上</p></blockquote><h5 id="如何根据浏览器渲染机制加快首屏速度"><a href="#如何根据浏览器渲染机制加快首屏速度" class="headerlink" title="如何根据浏览器渲染机制加快首屏速度"></a>如何根据浏览器渲染机制加快首屏速度</h5><p>1.<strong>优化文件大小</strong>：HTML和CSS的加载和解析都会阻塞渲染树的生成，从而影响首屏展示速度，因此我们可以通过优化文件大小、减少CSS文件层级的方法来加快首屏速度</p><p>2.<strong>避免资源下载阻塞文档解析</strong>：浏览器解析到<code>&lt;script&gt;</code>标签时，会阻塞文档解析，直到脚本执行完成，因此我们通常把<code>&lt;script&gt;</code>标签放在底部，或者加上<code>defer、async</code></p><h3 id="回流（重排）和重绘的理解"><a href="#回流（重排）和重绘的理解" class="headerlink" title="回流（重排）和重绘的理解"></a>回流（重排）和重绘的理解</h3><ul><li><p>回流</p><p>当元素的尺寸或者位置发生了变化，浏览器需要重新计算元素的几何属性，然后再将计算的结果绘制出来。这个过程就是回流（也叫重排）</p><p>触发回流的情况：</p><p>1.DOM元素的几何属性(<code>width/height/padding/margin/border</code>)发生变化</p><p>2.DOM元素移动或增加</p><p>3.计算 <code>offset/scroll/client</code>等属性</p><p>4.调用<code>window.getComputedStyle</code></p></li><li><p>重绘</p><p>DOM样式发生了变化，但没有影响DOM的几何属性（比如修改了颜色或背景色）时</p><p>浏览器不需重新计算元素的几何属性、直接为该元素绘制新的样式会触发重绘</p></li></ul><h3 id="常见HTTP状态码有哪些"><a href="#常见HTTP状态码有哪些" class="headerlink" title="常见HTTP状态码有哪些"></a>常见HTTP状态码有哪些</h3><blockquote><p>2xx 开头（请求成功）</p></blockquote><p><code>200 OK</code>：客户端发送给服务器的请求被正常处理并返回</p><blockquote><p>3xx 开头（重定向）</p></blockquote><p><code>301 Moved Permanently</code>：永久重定向，请求的网页已永久移动到新位置。服务器返回此响应时，会自动将请求者转到新位置</p><p><code>302 Moved Permanently</code>：临时重定向，请求的网页已临时移动到新位置。服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来进行以后的请求</p><p><code>304 Not Modified</code>：未修改，自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容</p><blockquote><p>4xx 开头（客户端错误）</p></blockquote><p><code>400 Bad Request</code>：错误请求，服务器不理解请求的语法，常见于客户端传参错误</p><p><code>401 Unauthorized</code>：未授权，表示发送的请求需要有通过 HTTP 认证的认证信息，常见于客户端未登录</p><p><code>403 Forbidden</code>：禁止，服务器拒绝请求，常见于客户端权限不足</p><p><code>404 Not Found</code>：未找到，服务器找不到对应资源</p><blockquote><p>5xx 开头（服务端错误）</p></blockquote><p><code>500 Inter Server Error</code>：服务器内部错误，服务器遇到错误，无法完成请求</p><p><code>501 Not Implemented</code>：尚未实施，服务器不具备完成请求的功能</p><p><code>502 Bad Gateway</code>：作为网关或者代理工作的服务器尝试执行请求时，从上游服务器接收到无效的响应。</p><p><code>503 service unavailable</code>：服务不可用，服务器目前无法使用（处于超载或停机维护状态）。通常是暂时状态。</p><h3 id="常见的兼容性问题"><a href="#常见的兼容性问题" class="headerlink" title="常见的兼容性问题"></a>常见的兼容性问题</h3><p>pc端：</p><ul><li><p>一般是css兼容的问题，例如：利用css hack来解决 , 如* , _ ,等</p></li><li><p>JS有特性匹配来解决某个JS方法是否存在</p></li><li><p>input设置type= number,pc端出现上下箭头</p><div class="hljs"><pre><code class="hljs plain">input::-webkit-outer-spin-button,input::-webkit-inner-spin-button&#123;-webkit-appearance: none !important;margin:0;&#125;</code></pre></div></li></ul><p>手机端：</p><ul><li><p>主要遇到过移动端300ms延迟问题，可以通过fastclick插件解决</p></li><li><p>ios下取消input在输入的时候,英文首字母的默认大写</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">autocapitalize</span>=<span class="hljs-string">"off"</span> <span class="hljs-attr">autocorrect</span>=<span class="hljs-string">"off"</span> /&gt;</span></code></pre></div></li><li><p>页面有一个input输入框，需要输入手机号码，手机端输入时会弹出数字键盘，需要设置<code>type属性为tel</code></p></li><li><p>拍照功能 添加图片 =&gt; 拍照功能</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">a</span> <span class="hljs-attr">href</span>=<span class="hljs-string">"javascript:;"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"u-choose-btn"</span> <span class="hljs-attr">data-use</span>=<span class="hljs-string">"shuidian"</span> <span class="hljs-attr">data-useid</span>=<span class="hljs-string">"2"</span> <span class="hljs-attr">onclick</span>=<span class="hljs-string">"document.getElementById('myfile').click()"</span>&gt;</span>添加图片<span class="hljs-tag">&lt;/<span class="hljs-name">a</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"file"</span> <span class="hljs-attr">accept</span>=<span class="hljs-string">"image/*"</span> <span class="hljs-attr">capture</span>=<span class="hljs-string">"camera"</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"myfile"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"display:none"</span>&gt;</span>  files[]</code></pre></div></li><li><p><strong>H5开发的时候在IOS设备上的一些兼容性问题的解决方法</strong><br>1.设置overflow-y时滚动区域不流畅问题</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-tag">-webkit-overflow-scrolling</span>: <span class="hljs-selector-tag">touch</span>;</code></pre></div></li></ul><h4 id="IE8如何支持语义化标签"><a href="#IE8如何支持语义化标签" class="headerlink" title="IE8如何支持语义化标签"></a>IE8如何支持语义化标签</h4><p>直接引入一个库 html5shiv.js,原理就是把语义化标签在低版本浏览器转化成了块级元素,让浏览器可以解析</p><h4 id="谷歌浏览器如何显示12px以下的字号"><a href="#谷歌浏览器如何显示12px以下的字号" class="headerlink" title="谷歌浏览器如何显示12px以下的字号"></a>谷歌浏览器如何显示12px以下的字号</h4><p>中文版的chrome有个12px字体限制的问题，就是当字体小于12px时候,都以12px来显示。这个问题在中文网站中并不突出，因为中文字体为了显示清晰一般都定义为大于或等于12px，但如果是一些英文网站那就不好说了，这时12px的限制就会破坏页面的美感，甚至因为文字变大而导致页面变形。</p><p>我们可以通过<strong>css3的缩放</strong>来实现这个问题,比方说我要展示10px的文字,可以通过设置字体20px,然后scale(0.5)。</p><h3 id="性能优化相关问题"><a href="#性能优化相关问题" class="headerlink" title="性能优化相关问题"></a>性能优化相关问题</h3><ul><li><h4 id="减少http请求"><a href="#减少http请求" class="headerlink" title="减少http请求"></a><strong>减少http请求</strong></h4><p>合并文件</p><p>不使用CSS @import</p><p><strong>图片处理</strong></p><ul><li>雪碧图</li><li>Base64</li><li>使用字体图标来代替图片</li><li>图片懒加载</li></ul></li><li><h4 id="减少重绘回流"><a href="#减少重绘回流" class="headerlink" title="减少重绘回流"></a><strong>减少重绘回流</strong></h4><p>DOM优化</p><ul><li>缓存DOM</li><li>减少DOM深度及DOM数量</li><li>事件代理</li><li>防抖和节流</li></ul></li><li><h4 id="webpack优化"><a href="#webpack优化" class="headerlink" title="webpack优化"></a><strong>webpack优化</strong></h4><p>扩展：webpack的理解</p><p>webpack是一个前端模块化打包构建工具，webpack本身需要的入口文件通过entry来指定，出口通过output来指定，默认只支持js文件，其它文件类型需要对应的loader来转换。例如，css =&gt; style-loader,css-loader</p><p>当然本身还有一些内置插件来对文件进行压缩、合并等操作</p></li></ul><p>详细资料：<a href="https://www.cnblogs.com/xiaohuochai/p/9178390.html" target="_blank" rel="noopener">前端性能优化的七大手段</a></p><p>参考资料：<a href="https://mp.weixin.qq.com/s/anrtDgzYhEAmaQ3kXzcqkw" target="_blank" rel="noopener">2万字！90个前端开发面试必问基础大总结</a></p>]]></content>
    
    
    <categories>
      
      <category>面试</category>
      
    </categories>
    
    
    <tags>
      
      <tag>html</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目——购物APP</title>
    <link href="/2020/06/27/vue%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9APP/"/>
    <url>/2020/06/27/vue%E9%A1%B9%E7%9B%AE%E2%80%94%E2%80%94%E8%B4%AD%E7%89%A9APP/</url>
    
    <content type="html"><![CDATA[<h3 id="项目基本搭建工作"><a href="#项目基本搭建工作" class="headerlink" title="项目基本搭建工作"></a>项目基本搭建工作</h3><p>使用vue-cli v4.3.1脚手架搭建项目<br><code>vue create my-project</code></p><h4 id="1-1目录结构"><a href="#1-1目录结构" class="headerlink" title="1.1目录结构"></a>1.1目录结构</h4><p>src目录下新建的文件</p><ul><li>assets 引入的css和img文件</li><li>common 一些单独的模块，如封装的防抖函数</li><li>network 网络请求</li><li>components -&gt; common/content 子组件（封装的单独组件）</li><li>store vuex组件状态管理</li><li>router 路由模块</li><li>views 主要的四大模块</li></ul><p>​ .editorconfig 该文件是src的同级目录，代码书写风格（规范）</p><div class="hljs"><pre><code class="hljs js">root = <span class="hljs-literal">true</span>[*]charset = utf<span class="hljs-number">-8</span>indent_style = spaceindent_size = <span class="hljs-number">2</span>end_of_line = lfinsert_final_newline = <span class="hljs-literal">true</span>trim_trailing_whitespace = <span class="hljs-literal">true</span></code></pre></div><h4 id="1-2配置主要目录的别名"><a href="#1-2配置主要目录的别名" class="headerlink" title="1.2配置主要目录的别名"></a>1.2配置主要目录的别名</h4><p>在vue.config.js中配置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  configureWebpack:&#123;    resolve:&#123;      <span class="hljs-comment">// 配置别名</span>      alias:&#123;      <span class="hljs-comment">//@是src目录的别名</span>        <span class="hljs-string">'assets'</span>:<span class="hljs-string">'@/assets'</span>,        <span class="hljs-string">'common'</span>:<span class="hljs-string">'@/common'</span>,        <span class="hljs-string">'components'</span>:<span class="hljs-string">'@/components'</span>,        <span class="hljs-string">'network'</span>:<span class="hljs-string">'@/network'</span>,        <span class="hljs-string">'views'</span>:<span class="hljs-string">'@/views'</span>      &#125;    &#125;  &#125; &#125;</code></pre></div><h4 id="1-3设置CSS初始化和全局样式"><a href="#1-3设置CSS初始化和全局样式" class="headerlink" title="1.3设置CSS初始化和全局样式"></a>1.3设置CSS初始化和全局样式</h4><ul><li><a href="https://github.com/necolas/normalize.css/blob/master/normalize.css" target="_blank" rel="noopener">initialize.css</a></li><li>base.css</li></ul><h4 id="1-4-创建主要的四个模块-路由组件"><a href="#1-4-创建主要的四个模块-路由组件" class="headerlink" title="1.4 创建主要的四个模块(路由组件)"></a>1.4 创建主要的四个模块(路由组件)</h4><p>home category cart profile</p><h5 id="安装、使用vue-router（创建项目的时候没有选择自动创建路由模块）"><a href="#安装、使用vue-router（创建项目的时候没有选择自动创建路由模块）" class="headerlink" title="安装、使用vue-router（创建项目的时候没有选择自动创建路由模块）"></a>安装、使用vue-router（创建项目的时候没有选择自动创建路由模块）</h5><p><code>npm install vue-router --save</code></p><p>创建路由实例</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span><span class="hljs-keyword">const</span> Home = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'views/home/Home'</span>) <span class="hljs-keyword">const</span> Category = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'views/category/Category'</span>)<span class="hljs-keyword">const</span> Cart = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'views/cart/Cart'</span>)<span class="hljs-keyword">const</span> Profile = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">'views/profile/Profile'</span>)<span class="hljs-comment">// 1.注入插件</span>Vue.use(VueRouter)<span class="hljs-comment">// 2.定义路由</span><span class="hljs-keyword">const</span> routes = [  &#123;    path:<span class="hljs-string">'/'</span>,    redirect:<span class="hljs-string">'/home'</span>  &#125;,  &#123;    path: <span class="hljs-string">'/home'</span>,    name: <span class="hljs-string">'Home'</span>,    component: Home  &#125;,  &#123;    path:<span class="hljs-string">'/category'</span>,    name:<span class="hljs-string">'Category'</span>,    component: Category  &#125;,  &#123;    path:<span class="hljs-string">'/cart'</span>,    name:<span class="hljs-string">'Cart'</span>,    component: Cart  &#125;,  &#123;    path:<span class="hljs-string">'/profile'</span>,    name:<span class="hljs-string">'Profile'</span>,    component: Profile  &#125;,]<span class="hljs-comment">// 3.创建router实例</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;   routes,   mode:<span class="hljs-string">'history'</span>&#125;)<span class="hljs-comment">// 4.导出router实例</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>挂载到Vue实例中(main.js入口文件)</p><p>在App.vue文件中使用</p><h4 id="1-4-底部tabbar的封装"><a href="#1-4-底部tabbar的封装" class="headerlink" title="1.4 底部tabbar的封装"></a>1.4 底部tabbar的封装</h4><ul><li><p>封装Tabbar为单独的模块</p><ul><li><p>外部框架封装成一个组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tab-bar"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div></li><li><p>每一个底部切换按钮封装成组件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"tab-item"</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">"itemClick"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">"!isActive"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"item-icon"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-else</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"item-icon-active"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">:style</span>=<span class="hljs-string">"styleColor"</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">"item-text"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div></li></ul></li><li><p><strong>响应点击切换的设计</strong></p></li><li><p>封装完成后，该项目使用时对Tabbar重新包装</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main-tab"</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">tab-bar</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tab-bar-item</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/home"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/home.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon-active"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/home_active.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-text"</span>&gt;</span>首页<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">tab-bar-item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tab-bar-item</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/category"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/category.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon-active"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/category_active.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-text"</span>&gt;</span>分类<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">tab-bar-item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tab-bar-item</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/cart"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/shopcart.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon-active"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/shopcart_active.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-text"</span>&gt;</span>购物车<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">tab-bar-item</span>&gt;</span>      <span class="hljs-tag">&lt;<span class="hljs-name">tab-bar-item</span> <span class="hljs-attr">path</span>=<span class="hljs-string">"/profile"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/profile.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-icon-active"</span> <span class="hljs-attr">src</span>=<span class="hljs-string">"~assets/img/tabbar/profile_active.svg"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"item-text"</span>&gt;</span>我的<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>      <span class="hljs-tag">&lt;/<span class="hljs-name">tab-bar-item</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">tab-bar</span>&gt;</span>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></code></pre></div></li></ul><h4 id="1-5-axios的封装"><a href="#1-5-axios的封装" class="headerlink" title="1.5 axios的封装"></a>1.5 axios的封装</h4><p>该项目使用了三个api接口的数据，因此封装了三个请求模块，其中一个因为有跨域问题，在开发环境下使用了反向代理（在vue.config.js中配置）</p><ul><li>创建axios实例</li><li>拦截响应（需要返回拦截的data数据）</li><li>根据传入的options发送请求，并且调用对应resolve和reject</li></ul><h3 id="首页开发"><a href="#首页开发" class="headerlink" title="首页开发"></a>首页开发</h3><h4 id="2-1-navbar的封装和使用"><a href="#2-1-navbar的封装和使用" class="headerlink" title="2.1 navbar的封装和使用"></a>2.1 navbar的封装和使用</h4><ul><li>封装navbar包含三个插槽：left、center、right</li><li>设置navbar相关的样式</li><li>使用navbar实现首页的导航栏</li></ul><h4 id="2-2-请求首页数据"><a href="#2-2-请求首页数据" class="headerlink" title="2.2 请求首页数据"></a>2.2 请求首页数据</h4><p>封装首页的数据请求</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;request,requestone,requesttwo&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'network/request'</span><span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHomeMultidata</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> request(&#123;    url:<span class="hljs-string">'/home/multidata'</span>  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHomeFloordata</span>(<span class="hljs-params"></span>)</span>&#123;  <span class="hljs-keyword">return</span> requestone(&#123;    url:<span class="hljs-string">'/api/public/v1/home/floordata'</span>  &#125;)&#125;<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getHomeImagedata</span>(<span class="hljs-params">params</span>)</span>&#123;  <span class="hljs-keyword">return</span> requesttwo(&#123;    url:<span class="hljs-string">'/ip/image/v3/homepage/vertical'</span>,    params:params  &#125;)&#125;</code></pre></div><h4 id="2-3-根据Vant封装HomeSwiper"><a href="#2-3-根据Vant封装HomeSwiper" class="headerlink" title="2.3 根据Vant封装HomeSwiper"></a>2.3 根据Vant封装HomeSwiper</h4><p>注意：</p><p>1.需要安装插件babel-plugin-import</p><div class="hljs"><pre><code class="hljs bash">npm i babel-plugin-import -D</code></pre></div><p>2.在 babel.config.js 中配置</p><div class="hljs"><pre><code class="hljs js">plugins: [    [<span class="hljs-string">'import'</span>, &#123;      libraryName: <span class="hljs-string">'vant'</span>,      libraryDirectory: <span class="hljs-string">'es'</span>,      style: <span class="hljs-literal">true</span>    &#125;, <span class="hljs-string">'vant'</span>]  ]</code></pre></div><p>以上当时没有安装使用，导致轮播图一直有问题</p><p>3.该轮播图触摸滑动时，会自动跳转到图片的链接地址，在van-swipe标签中使用API（<code>:stop-propagation=&quot;false&quot;</code>）,就可以阻止滑动事件触发</p><h4 id="2-4-封装HomeRecommend"><a href="#2-4-封装HomeRecommend" class="headerlink" title="2.4 封装HomeRecommend"></a>2.4 封装HomeRecommend</h4><p>传入recommends数据，进行展示</p><h4 id="2-5-封装HomeFeature"><a href="#2-5-封装HomeFeature" class="headerlink" title="2.5 封装HomeFeature"></a>2.5 封装HomeFeature</h4><p>展示本地的一张图片</p><h4 id="2-6-封装HomeFloor"><a href="#2-6-封装HomeFloor" class="headerlink" title="2.6 封装HomeFloor"></a>2.6 封装HomeFloor</h4><p>传入messages数据，进行展示</p><h4 id="2-7-封装PageImage"><a href="#2-7-封装PageImage" class="headerlink" title="2.7 封装PageImage"></a>2.7 封装PageImage</h4><p>传入vertical数据，进行展示</p><h4 id="2-8-滚动模块的封装（Scroll）"><a href="#2-8-滚动模块的封装（Scroll）" class="headerlink" title="2.8 滚动模块的封装（Scroll）"></a>2.8 滚动模块的封装（Scroll）</h4><ul><li><p>安装better-scroll（使用html的模板： wrapper -&gt; content -&gt; 很多内容）</p></li><li><p>封装一个独立的组件，用于作为滚动组件：Scroll</p></li><li><p>组件内代码的封装：</p><ul><li><p>创建BetterScroll对象，并且传入DOM和选项</p><ul><li><p>监听滚动</p><p>probeType: 0/1/2(手指滚动)/3(只要是滚动)</p></li><li><p>click：false</p><p>content里面div不可以监听点击，所以一般需要设置为true</p></li><li><p>上拉加载 pullUpLoad: true</p></li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1.better-scroll的初始化</span><span class="hljs-keyword">this</span>.scroll = <span class="hljs-keyword">new</span> BScroll(<span class="hljs-keyword">this</span>.$refs.wrapper, &#123;    click:<span class="hljs-literal">true</span>,    probeType:<span class="hljs-keyword">this</span>.probetype,    pullUpLoad: <span class="hljs-keyword">this</span>.pullUpLoad,    mouseWheel: <span class="hljs-literal">true</span>,<span class="hljs-comment">//开启鼠标滚轮</span>    <span class="hljs-comment">// disableMouse: false,//启用鼠标拖动</span>    <span class="hljs-comment">// disableTouch: false//启用手指触摸</span>&#125;)</code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1.better-scroll的初始化</span><span class="hljs-keyword">this</span>.scroll = <span class="hljs-keyword">new</span> BScroll(<span class="hljs-keyword">this</span>.$refs.wrapper, &#123;    click:<span class="hljs-literal">true</span>,    probeType:<span class="hljs-keyword">this</span>.probetype,    pullUpLoad: <span class="hljs-keyword">this</span>.pullUpLoad,    mouseWheel: <span class="hljs-literal">true</span>,<span class="hljs-comment">//开启鼠标滚轮</span>    <span class="hljs-comment">// disableMouse: false,//启用鼠标拖动</span>    <span class="hljs-comment">// disableTouch: false//启用手指触摸</span>&#125;)</code></pre></div></li><li><p>监听scroll事件，该事件会返回一个position</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 2.监听滚动的位置</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.probetype === <span class="hljs-number">2</span> || <span class="hljs-keyword">this</span>.probetype === <span class="hljs-number">3</span>)&#123;   <span class="hljs-keyword">this</span>.scroll.on(<span class="hljs-string">'scroll'</span>,(position) =&gt; &#123;   <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'scroll'</span>,position)&#125;)&#125;</code></pre></div></li><li><p>监听pullingUp事件，监听到该事件进行上拉加载更多</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 3.监听上拉事件</span><span class="hljs-keyword">if</span>(<span class="hljs-keyword">this</span>.pullUpLoad)&#123;  <span class="hljs-keyword">this</span>.scroll.on(<span class="hljs-string">'pullingUp'</span>,() =&gt; &#123;  <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'pullingUp'</span>)    &#125;)&#125;</code></pre></div></li><li><p>封装刷新的方法：this.scroll.refresh()</p></li><li><p>封装滚动的方法：this.scroll.scrollTo(x, y, time)</p></li><li><p>封装完成刷新的方法：this.scroll.finishedPullUp</p></li></ul></li></ul><h4 id="2-9-返回顶部"><a href="#2-9-返回顶部" class="headerlink" title="2.9 返回顶部"></a>2.9 返回顶部</h4><ul><li>封装BackTop组件</li><li>监听滚动，决定BackTop组件在什么数值下的显示和隐藏</li><li>监听BackTop的点击，点击时，调用scrollTo返回顶部</li></ul><h4 id="2-10-首页开发中遇到的问题"><a href="#2-10-首页开发中遇到的问题" class="headerlink" title="2.10 首页开发中遇到的问题"></a>2.10 首页开发中遇到的问题</h4><p>1.home组件直接监听back-top组件的点击, 不可以直接监听，必须添加修饰.native</p><p>使用 <code>v-on</code> 的 <code>.native</code> 修饰符：可以在一个组件的根元素上直接监听一个原生事件</p><p>2.首页中可滚动区域的问题</p><p>Better-Scroll在决定有多少区域可以滚动时, 是根据scrollerHeight属性决定</p><ul><li>scrollerHeight属性是根据放Better-Scroll的content中的子组件的高度</li><li>但是我们的首页中, 刚开始在计算scrollerHeight属性时, 是没有将图片计算在内的</li><li>后来图片加载进来之后有了新的高度, 但是scrollerHeight属性并没有进行更新.</li><li>所以滚动出现了问题</li></ul><p>解决方法</p><ul><li>监听每一张图片是否加载完成, 只要有一张图片加载完成了, 执行一次refresh()</li><li>如何监听图片加载完成了?<ul><li>原生的js监听图片: img.onload = function() {}</li><li>Vue中监听: @load=’方法’</li></ul></li><li>调用scroll的refresh()</li></ul><p>解决过程中的难点</p><ul><li><p>PageImage.vue组件中监听图片加载的事件传入到Home.vue中</p><p>因为涉及到非父子组件的通信, 所以这里我们选择了<strong>事件总线</strong></p><ul><li>在main.js中初始化 <code>bus</code></li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//注意，这种方式初始化的 bus 是一个 全局的事件总线 </span>Vue.prototype.$bus = <span class="hljs-keyword">new</span> Vue()</code></pre></div><ul><li><p>发送消息</p><p>this.$bus.$emit(‘事件名称’, 参数)</p></li><li><p>接收事件</p><p>this.$bus.$on(‘事件名称’, 回调函数(参数))</p></li></ul></li></ul><ul><li><p>refresh找不到的问题</p><ul><li>在Scroll.vue中, 调用this.scroll的方法之前, 判断this.scroll对象是否有值</li><li>在mounted生命周期函数中使用 this.$refs.scroll而不是created中</li></ul></li><li><p>对于refresh非常频繁的问题, 进行防抖操作</p><ul><li>防抖debounce/节流throttle</li><li>防抖函数起作用的过程:<ul><li>如果我们直接执行refresh, 那么refresh函数会被执行30次.</li><li>可以将refresh函数传入到debounce函数中, 生成一个新的函数.</li><li>之后在调用非常频繁的时候, 就使用新生成的函数.</li><li>而新生成的函数, 并不会非常频繁的调用, 如果下一次执行来的非常快, 那么会将上一次取消掉</li></ul></li></ul></li></ul><div class="hljs"><pre><code class="hljs js">debounce(func, delay) &#123;  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>  <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">...args</span>) </span>&#123;    <span class="hljs-keyword">if</span> (timer) clearTimeout(timer)    timer = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;      func.apply(<span class="hljs-keyword">this</span>, args)    &#125;, delay)  &#125;&#125;,</code></pre></div><p>3.使用better-scroll遇到的问题</p><p>页面初始化以后滑动事件失效，需要从新刷新页面才能启动功能</p><p>在网上查了好久，有博客指出是新版谷歌与better-scroll自身的兼容问题，并不影响项目的正常运转，只是在谷歌进行移动端测试时才会出现，还有在创建BetterScroll对象时，添加<code>mouseWheel: true,//开启鼠标滚轮</code>可以使用鼠标滚动</p><h3 id="商品分类开发"><a href="#商品分类开发" class="headerlink" title="商品分类开发"></a>商品分类开发</h3><h4 id="3-1封装导航栏CateHeader"><a href="#3-1封装导航栏CateHeader" class="headerlink" title="3.1封装导航栏CateHeader"></a>3.1封装导航栏CateHeader</h4><p>使用封装过的navbar组件，并使用vant的搜索组件，重新包装</p><h4 id="3-2-封装左侧菜单栏MenuList"><a href="#3-2-封装左侧菜单栏MenuList" class="headerlink" title="3.2 封装左侧菜单栏MenuList"></a>3.2 封装左侧菜单栏MenuList</h4><h4 id="3-3-封装右侧内容区域CateContent"><a href="#3-3-封装右侧内容区域CateContent" class="headerlink" title="3.3 封装右侧内容区域CateContent"></a>3.3 封装右侧内容区域CateContent</h4><h4 id="3-4分类开发遇到的问题"><a href="#3-4分类开发遇到的问题" class="headerlink" title="3.4分类开发遇到的问题"></a>3.4分类开发遇到的问题</h4><ul><li><p>MenuList和CateContent组件在分类主模块中使用时，需要使用scroll组件包裹，并在scroll组件中传入滚动需要的条件</p></li><li><p>点击左侧菜单列表，右侧显示对应的内容模块</p><ul><li><p>在MenuList组件点击菜单列表事件中，使用$emit将每一个列表的index传到分类主模块中</p><div class="hljs"><pre><code class="hljs js">changeColor(index)&#123;      <span class="hljs-keyword">this</span>.currentIndex= index  <span class="hljs-comment">//在data数据中定义的当前索引与菜单栏每一列的索引相等时，改变当前项的样式</span>      <span class="hljs-keyword">this</span>.$emit(<span class="hljs-string">'menuClick'</span>,index)&#125;</code></pre></div></li><li><p>在主模块绑定的菜单点击事件中，将index传入CateContent组件的数据，作为索引值,改变内容区相应的数据</p><div class="hljs"><pre><code class="hljs js">menuClick(index)&#123;      <span class="hljs-keyword">this</span>.rightContent = <span class="hljs-keyword">this</span>.messages[index].children      <span class="hljs-keyword">this</span>.$refs.scroll.scrollTo(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">//点击菜单栏每一项列表时，让右侧内容区域都重新滚回顶部</span>    &#125;</code></pre></div></li></ul></li><li><p>分类主模块的数据使用本地存储</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1.把获取的接口数据存储到本地</span><span class="hljs-keyword">const</span> parsedCates = <span class="hljs-built_in">JSON</span>.stringify(<span class="hljs-keyword">this</span>.messages)ocalStorage.setItem(<span class="hljs-string">'cates'</span>,parsedCates)<span class="hljs-comment">//以上时获取数据时的操作</span>--------------------------------------------------------------------------created()&#123;    <span class="hljs-comment">// 2.获取本地存储的数据</span>    <span class="hljs-keyword">const</span> Cates = <span class="hljs-built_in">JSON</span>.parse(localStorage.getItem(<span class="hljs-string">'cates'</span>))    <span class="hljs-keyword">if</span>(!Cates)&#123;      <span class="hljs-comment">// 没有本地的数据，则发送请求获取数据</span>      <span class="hljs-keyword">this</span>.getCateData()    &#125;<span class="hljs-keyword">else</span>&#123;      <span class="hljs-comment">// 有本地数据</span>      <span class="hljs-keyword">this</span>.messages = Cates      <span class="hljs-keyword">this</span>.rightContent = <span class="hljs-keyword">this</span>.messages[<span class="hljs-number">0</span>].children    &#125;    <span class="hljs-comment">// this.getCateData()</span>  &#125;,</code></pre></div></li></ul><h3 id="商品列表开发"><a href="#商品列表开发" class="headerlink" title="商品列表开发"></a>商品列表开发</h3><h4 id="4-1使用封装过的navbar组件，作为导航栏"><a href="#4-1使用封装过的navbar组件，作为导航栏" class="headerlink" title="4.1使用封装过的navbar组件，作为导航栏"></a>4.1使用封装过的navbar组件，作为导航栏</h4><h4 id="4-2利用动态路由传值-获取页面数据"><a href="#4-2利用动态路由传值-获取页面数据" class="headerlink" title="4.2利用动态路由传值,获取页面数据"></a>4.2利用动态路由传值,获取页面数据</h4><p>根据接口请求参数，从商品分类页面中的右侧内容区域，得到当前点击商品的id获取数据</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//router(index.js)</span>&#123;    path:<span class="hljs-string">'/shoplist/:cat_id'</span>,    name:<span class="hljs-string">'ShopList'</span>,    component: ShopList  &#125;,</code></pre></div><div class="hljs"><pre><code class="hljs html">//商品分类页面中的右侧内容区域<span class="hljs-tag">&lt;<span class="hljs-name">router-link</span> <span class="hljs-attr">:to</span>=<span class="hljs-string">"&#123;path:'/shoplist/'+ goods.cat_id&#125;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-link</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//商品列表获得传过来的id</span><span class="hljs-keyword">this</span>.queryparams.cat_id = <span class="hljs-keyword">this</span>.$route.params.cat_id</code></pre></div><h4 id="4-3使用封装的scroll组件，包裹内容区域"><a href="#4-3使用封装的scroll组件，包裹内容区域" class="headerlink" title="4.3使用封装的scroll组件，包裹内容区域"></a>4.3使用封装的scroll组件，包裹内容区域</h4><h4 id="4-4使用BackTop组件"><a href="#4-4使用BackTop组件" class="headerlink" title="4.4使用BackTop组件"></a>4.4使用BackTop组件</h4><h4 id="4-5列表开发遇到的问题"><a href="#4-5列表开发遇到的问题" class="headerlink" title="4.5列表开发遇到的问题"></a>4.5列表开发遇到的问题</h4><p>1.获取到的内容都是一样的（可能请求的api数据有问题，没有请求参数也可以得到数据，改变了商品id获取的数据也是一样的，哎，弄了好久···)</p><p>2.加载下一页</p><ul><li><p>计算获取数据的总页数</p><p>总的商品条数[获取的数据有显示] / 每页的数量[在请求参数中设定的pagesize:10]</p></li><li><p>让当前页数与总页数比较大小，小于就加载下一页</p></li></ul><p>3.获取的商品没有图片，需要判断，但是需要引用线上的图片地址，引入本地的图片不起作用</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"good.goods_small_logo?good.goods_small_logo:'https://img-blog.csdnimg.cn/20200628145700763.jpg'"</span> <span class="hljs-attr">alt</span>=<span class="hljs-string">""</span>&gt;</span></code></pre></div><h3 id="商品详情开发"><a href="#商品详情开发" class="headerlink" title="商品详情开发"></a>商品详情开发</h3><h4 id="5-1-根据Vant封装ShopSwiper"><a href="#5-1-根据Vant封装ShopSwiper" class="headerlink" title="5.1 根据Vant封装ShopSwiper"></a>5.1 根据Vant封装ShopSwiper</h4><h4 id="5-2利用动态路由传值-获取页面数据"><a href="#5-2利用动态路由传值-获取页面数据" class="headerlink" title="5.2利用动态路由传值,获取页面数据"></a>5.2利用动态路由传值,获取页面数据</h4><p>根据商品列表页面每个商品传递的id,获取当前商品详细信息</p><h4 id="5-3详情开发遇到的问题"><a href="#5-3详情开发遇到的问题" class="headerlink" title="5.3详情开发遇到的问题"></a>5.3详情开发遇到的问题</h4><p>1.从详情页返回列表页面，列表页面不停留在一开始离开页面时的位置，始终会滚动到顶部（一直没有解决）？</p><p>2.加入购物车事件</p><div class="hljs"><pre><code class="hljs js">addShopCart()&#123;          <span class="hljs-comment">// let goods_image</span>      <span class="hljs-comment">// if(this.banners[0].pics_sma)&#123;</span>      <span class="hljs-comment">//   goods_image = this.banners[0].pics_sma</span>      <span class="hljs-comment">// &#125;else&#123;</span>      <span class="hljs-comment">//   goods_image = "https://img-blog.csdnimg.cn/20200628145700763.jpg"</span>      <span class="hljs-comment">// &#125;</span>      <span class="hljs-comment">// 1.获取购物车需要展示的信息</span>      <span class="hljs-keyword">const</span> product = &#123;&#125;      <span class="hljs-comment">// 没有图片的会报错，自己想的方法解决不了</span>      product.image = <span class="hljs-keyword">this</span>.banners[<span class="hljs-number">0</span>].pics_sma       product.title = <span class="hljs-keyword">this</span>.message.goods_name      product.price = <span class="hljs-keyword">this</span>.message.goods_price      product.goods_id = <span class="hljs-keyword">this</span>.goods_id      <span class="hljs-comment">// 2.将商品添加到购物车(promise、mapActins)</span>      <span class="hljs-comment">// this.$store.dispatch('addCart',product).then(res =&gt;&#123;</span>      <span class="hljs-comment">//   console.log(res)</span>      <span class="hljs-comment">// &#125;)</span>      <span class="hljs-keyword">this</span>.addCart(product).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;         <span class="hljs-keyword">this</span>.$toast.show(res,<span class="hljs-number">2000</span>)      &#125;)          &#125;</code></pre></div><h3 id="购物车页面开发"><a href="#购物车页面开发" class="headerlink" title="购物车页面开发"></a>购物车页面开发</h3><h4 id="6-1封装CartList组件（购物车里的每一项商品）"><a href="#6-1封装CartList组件（购物车里的每一项商品）" class="headerlink" title="6.1封装CartList组件（购物车里的每一项商品）"></a>6.1封装CartList组件（购物车里的每一项商品）</h4><p>使用scroll组件包裹，购物车的数据使用vuex管理</p><h4 id="6-2封装CartItem组件（每一项商品的详细信息）"><a href="#6-2封装CartItem组件（每一项商品的详细信息）" class="headerlink" title="6.2封装CartItem组件（每一项商品的详细信息）"></a>6.2封装CartItem组件（每一项商品的详细信息）</h4><h4 id="6-3封装CartTool组件（底部工具栏）"><a href="#6-3封装CartTool组件（底部工具栏）" class="headerlink" title="6.3封装CartTool组件（底部工具栏）"></a>6.3封装CartTool组件（底部工具栏）</h4><ul><li><p>全选按钮</p><p>显示状态：判断商品是否有没有被选中的，如果有就显示不选中，反之显示选中；</p><p>点击事件：</p><ul><li>如果原来都是选中的，点击一次，全部不选中</li><li>如果原来都是没选中（某些没选中），点击，全部选中</li></ul></li><li><p>计算总价格</p></li><li><p>去计算</p></li></ul><h4 id="6-4使用vuex管理购物车的数据"><a href="#6-4使用vuex管理购物车的数据" class="headerlink" title="6.4使用vuex管理购物车的数据"></a>6.4使用vuex管理购物车的数据</h4><p>1.下载vuex插件</p><p><code>npm i vuex -S</code></p><p>2.创建store对象,保存在购物车组件中共享的状态：cartList</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//store目录下新建的index.js文件</span><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">import</span> mutations <span class="hljs-keyword">from</span> <span class="hljs-string">'./mutations'</span><span class="hljs-keyword">import</span> actions <span class="hljs-keyword">from</span> <span class="hljs-string">'./action'</span><span class="hljs-keyword">import</span> getters <span class="hljs-keyword">from</span> <span class="hljs-string">'./getters'</span><span class="hljs-comment">//  1.安装插件</span>Vue.use(Vuex)<span class="hljs-keyword">const</span> state = &#123;  cartList:[] <span class="hljs-comment">//存储购物车里面的商品</span>&#125;<span class="hljs-comment">// 2.创建Store对象</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;  state,  mutations,  actions,  getters&#125;)<span class="hljs-comment">// 3.导出store,挂载到Vue实例上</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> store</code></pre></div><p>3.新建mutation-types.js, 并且在其中定义我们需要的常量.</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_COUNTER = <span class="hljs-string">'add_counter'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> ADD_TO_CART = <span class="hljs-string">'add_to_cart'</span></code></pre></div><p>4.新建mutation.js,修改state中的状态</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// mutations唯一的目的就是修改state中的状态</span><span class="hljs-comment">// mutations中的每个方法尽量完成的事件单一</span><span class="hljs-keyword">import</span> &#123;  ADD_COUNTER,  ADD_TO_CART&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./mutation-types'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  [ADD_COUNTER](state,payload)&#123;    payload.count++  &#125;,  [ADD_TO_CART](state,payload)&#123;    payload.isChecked = <span class="hljs-literal">true</span>    state.cartList.push(payload)  &#125;&#125;</code></pre></div><p>5.新建action.js,代替Mutation进行异步操作</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;  ADD_COUNTER,  ADD_TO_CART&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./mutation-types'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// context 上下文</span>  addCart(context,payload)&#123;    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;      <span class="hljs-comment">// payload 新添加的商品</span>      <span class="hljs-comment">//1. 查找state定义的数组（cartlist)中是否有payload</span>      <span class="hljs-comment">// 将购物车商品遍历,判断payload是否已经添加过购物车</span>      <span class="hljs-comment">// let oldProduct = null</span>      <span class="hljs-comment">// for(let item of state.cartList)&#123;</span>      <span class="hljs-comment">//   if(item.goods_id === payload.goods_id)&#123;</span>      <span class="hljs-comment">//     oldProduct = item</span>      <span class="hljs-comment">//   &#125;</span>      <span class="hljs-comment">// &#125;</span>      <span class="hljs-comment">// 感觉oldProduct这个变量有点影响理解，相当于一个中间变量</span>      <span class="hljs-keyword">let</span> oldProduct = context.state.cartList.find(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> item.goods_id === payload.goods_id)      <span class="hljs-comment">// 2.判断oldProduct</span>      <span class="hljs-keyword">if</span>(oldProduct)&#123;        <span class="hljs-comment">// oldProduct.count += 1 //有值加一</span>        context.commit(ADD_COUNTER,oldProduct)        resolve(<span class="hljs-string">'当前商品数量加一'</span>)      &#125;<span class="hljs-keyword">else</span>&#123;        payload.count = <span class="hljs-number">1</span>        <span class="hljs-comment">// state.cartList.push(payload)</span>        context.commit(ADD_TO_CART,payload)        resolve(<span class="hljs-string">'添加了新商品'</span>)      &#125;        &#125;)  &#125;  &#125;</code></pre></div><p>6.新建getters.js,从store中获取一些<strong>state变异后的状态</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;  cartLength(state)&#123;    <span class="hljs-keyword">return</span> state.cartList.length  &#125;,  cartList(state)&#123;    <span class="hljs-keyword">return</span> state.cartList  &#125;&#125;</code></pre></div><h3 id="个人页面开发"><a href="#个人页面开发" class="headerlink" title="个人页面开发"></a>个人页面开发</h3><p>静态页面</p><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><h4 id="1-单位转换"><a href="#1-单位转换" class="headerlink" title="1.单位转换"></a>1.单位转换</h4><p>px转换为vw,依赖插件postcss-px-to-viewport</p><p>需要在src目录下新建postcss.config.js文件，配置单位转换规则</p><h4 id="2-提示框的实现（封装成插件）"><a href="#2-提示框的实现（封装成插件）" class="headerlink" title="2.提示框的实现（封装成插件）"></a>2.提示框的实现（封装成插件）</h4><p>1.先封装一个提示组件，实现具体提示效果</p><div class="hljs"><pre><code class="hljs vue">&lt;template&gt;  &lt;div class&#x3D;&quot;toast&quot; v-show&#x3D;&quot;isShow&quot;&gt;    &#123;&#123;message&#125;&#125;  &lt;&#x2F;div&gt;&lt;&#x2F;template&gt;&lt;script&gt;export default &#123;  name:&#39;Toast&#39;,  data()&#123;    return&#123;      message:&#39;&#39;,      isShow:false    &#125;  &#125;,  methods:&#123;    show(message,duration&#x3D;2000)&#123;      this.isShow &#x3D; true;      this.message &#x3D; message;      setTimeout(() &#x3D;&gt; &#123;        this.isShow &#x3D; false;        this.message &#x3D; &#39;&#39;      &#125;,duration)    &#125;  &#125;&#125;&lt;&#x2F;script&gt;&lt;style&gt;.toast&#123;  font-size: 16px;  position: fixed;  top:50%;  left:50%;  padding: 10px 15px;  transform:translate(-50%,-50%);  color: #fff;  background: rgba(10,10,10,.5);  border-radius: 5px;  z-index: 999;&#125;&lt;&#x2F;style&gt;</code></pre></div><p>2.创建一个index.js文件,引入toast组件，封装成插件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Toast <span class="hljs-keyword">from</span> <span class="hljs-string">'./Toast'</span><span class="hljs-keyword">const</span> obj = &#123;  &#125;obj.install = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Vue</span>)</span>&#123;  <span class="hljs-comment">// 1.创建组件构造器</span>  <span class="hljs-keyword">const</span> toastContrustor = Vue.extend(Toast)  <span class="hljs-comment">// 2.根据组件构造器，用new的方式创建一个组件对象</span>  <span class="hljs-keyword">const</span> toast = <span class="hljs-keyword">new</span> toastContrustor()  <span class="hljs-comment">// 3.将组件对象，手动挂载到某个元素上</span>  toast.$mount(<span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>))  <span class="hljs-comment">// 4.toast.$el对应的就是div</span>  <span class="hljs-built_in">document</span>.body.appendChild(toast.$el)  Vue.prototype.$toast = toast&#125;<span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> obj</code></pre></div><p>3.在main.js文件中引入封装的toast插件，并安装</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> toast <span class="hljs-keyword">from</span> <span class="hljs-string">'components/common/toast'</span><span class="hljs-comment">// 安装toast插件</span>Vue.use(toast)</code></pre></div><h3 id="本项目中遇到的最大的坑"><a href="#本项目中遇到的最大的坑" class="headerlink" title="本项目中遇到的最大的坑"></a>本项目中遇到的最大的坑</h3><p>从商品列表页面进入商品详情页面然后返回，不管商品列表页面滑动到什么位置，始终会回到顶部，在网上查了好多资料都没解决（一直持续困扰我n多天，简直让人崩溃），我本来都不想管这个bug了的，可是面试需要用到，被人看到不太好，于是今天又来查找原因，终于找到了解决方法，终是老天不负我！</p><p>应该是由于执行顺序不正确，页面正在处于滚动状态的时候触发<code>refresh</code>函数才使得滚动失效。对滚动事件添加了一个setTimeout事件，让页面刷新后再实现滚动到离开页面时的目标位置</p><div class="hljs"><pre><code class="hljs js">activated()&#123;     setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">//相当于宏任务</span>       <span class="hljs-keyword">this</span>.$refs.scroll.scrollTo(<span class="hljs-number">0</span>,<span class="hljs-keyword">this</span>.stateY,<span class="hljs-number">0</span>)     &#125;, <span class="hljs-number">0</span>)     <span class="hljs-keyword">this</span>.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123; <span class="hljs-comment">//相当于微任务</span>       <span class="hljs-keyword">this</span>.$refs.scroll.refresh() <span class="hljs-comment">//不设置页面刷新，也无法实现具体效果，不是很理解</span>     &#125;);     &#125;, deactivated()&#123;   <span class="hljs-keyword">this</span>.stateY = <span class="hljs-keyword">this</span>.$refs.scroll.getScrollY()  &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>网络模块封装——学习笔记七</title>
    <link href="/2020/06/20/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/"/>
    <url>/2020/06/20/%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9D%97%E5%B0%81%E8%A3%85%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%83/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200620163955194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="网络请求模式"><a href="#网络请求模式" class="headerlink" title="网络请求模式"></a>网络请求模式</h2><p>1.传统的Ajax（基于XMLHttpRequest(XHR)）</p><p>2.jQuery-Ajax</p><p>3.axios</p><h2 id="认识axios"><a href="#认识axios" class="headerlink" title="认识axios"></a>认识axios</h2><h3 id="axios请求方式"><a href="#axios请求方式" class="headerlink" title="axios请求方式"></a>axios请求方式</h3><p>axios(config)<br>axios.request(config)<br>axios.get(url[, config])<br>axios.delete(url[, config])<br>axios.head(url[, config])<br>axios.post(url[, data[, config]])<br>axios.put(url[, data[, config]])<br>axios.patch(url[, data[, config]])</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//发送get请求(app.vue)</span><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'App'</span>,  created()&#123;    <span class="hljs-comment">// 1.没有请求参数</span>    axios.get(<span class="hljs-string">'http://123.207.32.32:8000/home/multidata'</span>)    .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(res);    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(err);     &#125;)     <span class="hljs-comment">// 2.有请求参数</span>     axios.get(<span class="hljs-string">'http://123.207.32.32:8000/home/data'</span>,&#123;<span class="hljs-attr">params</span>:&#123;<span class="hljs-attr">type</span>:<span class="hljs-string">'sell'</span>,<span class="hljs-attr">page</span>:<span class="hljs-number">1</span>&#125;&#125;)     .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;       <span class="hljs-built_in">console</span>.log(res);     &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;       <span class="hljs-built_in">console</span>.log(err);      &#125;)  &#125;&#125;</code></pre></div><h2 id="发送基本请求"><a href="#发送基本请求" class="headerlink" title="发送基本请求"></a>发送基本请求</h2><h3 id="1-发送并发请求-同时发送多个请求"><a href="#1-发送并发请求-同时发送多个请求" class="headerlink" title="1.发送并发请求(同时发送多个请求)"></a>1.发送并发请求(同时发送多个请求)</h3><p>使用axios.all, 可以放入多个请求的数组.<br>axios.all([]) 返回的结果是一个数组，使用 axios.spread 可将数组 [res1,res2] 展开为 res1, res2</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'App'</span>,  created()&#123;    <span class="hljs-comment">// 发送并发请求</span>    axios.all(      [        axios.get(<span class="hljs-string">'http://123.207.32.32:8000/home/multidata'</span>),        axios.get(<span class="hljs-string">'http://123.207.32.32:8000/category'</span>)            ])      .then(axios.spread(<span class="hljs-function">(<span class="hljs-params">res1,res2</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(res1);        <span class="hljs-built_in">console</span>.log(res2);           &#125;))  &#125;&#125;</code></pre></div><h3 id="2-全局配置"><a href="#2-全局配置" class="headerlink" title="2.全局配置"></a>2.全局配置</h3><p>在开发中可能很多参数都是固定的.这个时候我们可以进行一些抽取, 也可以利用axios的全局配置</p><p>axios.defaults.baseURL = ‘123.207.32.32:8000’<br>axios.defaults.headers.post[‘Content-Type’] = ‘application/x-www-form-urlencoded’;</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'App'</span>,  created()&#123;    <span class="hljs-comment">//提取全局的配置</span>    axios.defaults.baseURL = <span class="hljs-string">'http://123.207.32.32:8000'</span>    <span class="hljs-comment">// 发送并发请求</span>    axios.all(      [        axios.get(<span class="hljs-string">'/home/multidata'</span>),        axios.get(<span class="hljs-string">'/category'</span>)            ])      .then(axios.spread(<span class="hljs-function">(<span class="hljs-params">res1,res2</span>)=&gt;</span>&#123;        <span class="hljs-built_in">console</span>.log(res1);        <span class="hljs-built_in">console</span>.log(res2);           &#125;))  &#125;&#125;</code></pre></div><h3 id="3-常见的配置选项"><a href="#3-常见的配置选项" class="headerlink" title="3.常见的配置选项"></a>3.常见的配置选项</h3><ul><li>请求地址<br>url: ‘/user’,</li><li>请求类型<br>method: ‘get’,</li><li>请根路径<br>baseURL: ‘<a href="http://www.mt.com/api&#39;" target="_blank" rel="noopener">http://www.mt.com/api&#39;</a>,</li><li>请求前的数据处理<br>transformRequest:[function(data){}],</li><li>请求后的数据处理<br>transformResponse: [function(data){}],</li><li>自定义的请求头<br>headers:{‘x-Requested-With’:’XMLHttpRequest’},</li><li>URL查询对象<br>params:{ id: 12 },</li><li>查询对象序列化函数<br>paramsSerializer: function(params){ }<br>request body<br>data: { key: ‘aa’},</li><li>超时设置s<br>timeout: 1000,</li><li>跨域是否带Token<br>withCredentials: false,</li><li>自定义请求处理<br>adapter: function(resolve, reject, config){},</li><li>身份验证信息<br>auth: { uname: ‘’, pwd: ‘12’},</li><li>响应的数据格式 json / blob /document /arraybuffer / text / stream<br>responseType: ‘json’,</li></ul><h2 id="axios实例"><a href="#axios实例" class="headerlink" title="axios实例"></a>axios实例</h2><p>src目录下新建network文件夹，并在该文件夹下新建request.js，封装axios模块</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> axios <span class="hljs-keyword">from</span> <span class="hljs-string">'axios'</span> 一、回调函数的方式<span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config,success,failure</span>)</span>&#123;   <span class="hljs-comment">// 1.创建axios的实例</span>  <span class="hljs-keyword">const</span> instance = axios.create(&#123;    baseURL:<span class="hljs-string">'http://123.207.32.32:8000'</span>,    timeout:<span class="hljs-number">5000</span>  &#125;)  <span class="hljs-comment">// 2.发送真正的网络请求</span>  instance(config)  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;    success(res);  &#125;)  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;    failure(err);  &#125;)&#125; 二、promise的方式 <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config</span>)</span>&#123;   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> promise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>) =&gt;</span> &#123;      <span class="hljs-comment">// 1.创建axios的实例</span>      <span class="hljs-keyword">const</span> instance = axios.create(&#123;        baseURL:<span class="hljs-string">'http://123.207.32.32:8000'</span>,        timeout:<span class="hljs-number">5000</span>      &#125;)      <span class="hljs-comment">// 2.发送真正的网络请求</span>      instance(config)      .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;        resolve(res);      &#125;)      .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;        reject(err);      &#125;)  &#125;)&#125;三、最简单的封装 <span class="hljs-keyword">export</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">request</span>(<span class="hljs-params">config</span>)</span>&#123;       <span class="hljs-comment">// 1.创建axios的实例</span>      <span class="hljs-keyword">const</span> instance = axios.create(&#123;        baseURL:<span class="hljs-string">'http://123.207.32.32:8000'</span>,        timeout:<span class="hljs-number">5000</span>      &#125;)      <span class="hljs-comment">// 2.发送真正的网络请求</span>      <span class="hljs-keyword">return</span> instance(config) <span class="hljs-comment">//instance(config) 直接返回的是promise</span>&#125;</code></pre></div><p>在需要的位置使用封装的网络请求模块</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// request模块</span><span class="hljs-keyword">import</span> &#123;request&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./network/request.js'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  name: <span class="hljs-string">'App'</span>,  created()&#123;   一、回调函数的方式   request(&#123;     url:<span class="hljs-string">'/home/multidata'</span>   &#125;,res =&gt; &#123;     <span class="hljs-built_in">console</span>.log(res);     &#125;,err =&gt; &#123;     <span class="hljs-built_in">console</span>.log(err);   &#125;)   二、promise的方式(第三种方式同样)    request(&#123;     url:<span class="hljs-string">'/home/multidata'</span>   &#125;).then (<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;       <span class="hljs-built_in">console</span>.log(res);    &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;      <span class="hljs-built_in">console</span>.log(err);    &#125;)  &#125;&#125;</code></pre></div><h2 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h2><p>用于我们在发送每次请求或者得到相应后，进行对应的处理。</p><ul><li><p>请求拦截的作用：</p><ul><li><p>当发送网络请求时，在页面中添加一个loading组件，作为动画</p></li><li><p>某些请求要求用户必须登录，判断用户是否有token,如果没有token就跳转到login页面</p></li><li><p>config中的一些信息不符合服务器要求</p><p>请求拦截中错误拦截较少，通常都是配置相关的拦截<br>可能的错误比如请求超时，可以将页面跳转到一个错误页面中。</p></li></ul></li><li><p>响应拦截中完成的事情：</p><ul><li>响应的成功拦截中，主要是对数据进行过滤。</li><li>响应的失败拦截中，可以根据status判断报错的错误码，跳转到不同的错误提示页面。</li></ul></li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// axios拦截器：配置请求和响应拦截</span>  instance.interceptors.request.use(<span class="hljs-function"><span class="hljs-params">config</span> =&gt;</span> &#123;    <span class="hljs-comment">// 请求拦截：success中</span>    <span class="hljs-keyword">return</span> config  <span class="hljs-comment">//拦截了需要返回</span>  &#125;,err =&gt; &#123;    <span class="hljs-comment">// 请求拦截：failure中</span>    <span class="hljs-keyword">return</span> err    &#125;)  instance.interceptors.response.use(<span class="hljs-function"><span class="hljs-params">response</span> =&gt;</span> &#123;    <span class="hljs-comment">// 响应拦截：success中</span>    <span class="hljs-keyword">return</span> response.data  &#125;,err =&gt; &#123;    <span class="hljs-comment">// 响应拦截：failure中</span>    <span class="hljs-keyword">if</span>(err &amp;&amp; err.response)&#123;      <span class="hljs-keyword">switch</span> (err.response.status)&#123;        <span class="hljs-keyword">case</span> <span class="hljs-number">400</span>:          err.message = <span class="hljs-string">'请求错误'</span>          <span class="hljs-keyword">break</span>        <span class="hljs-keyword">case</span> <span class="hljs-number">401</span>:          err.message = <span class="hljs-string">'未授权的访问'</span>          <span class="hljs-keyword">break</span>      &#125;    &#125;    <span class="hljs-keyword">return</span> err    &#125;)</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue axios</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vuex——学习笔记六</title>
    <link href="/2020/06/19/Vuex%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/"/>
    <url>/2020/06/19/Vuex%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%85%AD/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的<strong>状态管理模式</strong>。</p><ul><li>状态管理到底是什么？<ul><li>可以简单的将其看成把需要多个组件共享的变量全部存储在一个对象里面。</li><li>然后，将这个对象放在顶层的Vue实例中，让其他组件可以使用。</li><li>那么，多个组件就可以共享这个对象中的所有变量属性了</li></ul></li></ul><p>采用 <strong>集中式存储管理</strong> 应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。<br>Vuex 也集成到 Vue 的官方调试工具 <strong>devtools extension</strong>，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。</p><h3 id="2-单界面的状态管理"><a href="#2-单界面的状态管理" class="headerlink" title="2.单界面的状态管理"></a>2.单界面的状态管理</h3><p><img src="https://img-blog.csdnimg.cn/20200619205150959.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>State</strong>：不用多说，就是我们的<strong>状态</strong>。（你姑且可以当做就是<strong>data中的属性</strong>）<br><strong>View</strong>：<strong>视图层</strong>，可以针对State的变化，显示不同的信息。<br><strong>Actions</strong>：这里的Actions主要是<strong>用户的各种操作</strong>：点击、输入等等，会导致状态的改变。</p><h3 id="3-Vuex状态管理"><a href="#3-Vuex状态管理" class="headerlink" title="3.Vuex状态管理"></a>3.Vuex状态管理</h3><p>将共享的状态抽取出来，Vuex统一进行管理。之后，每个界面，按照规定好的规定，进行访问和修改等操作。</p><p><img src="https://img-blog.csdnimg.cn/20200619213323362.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="4-基本使用"><a href="#4-基本使用" class="headerlink" title="4.基本使用"></a>4.基本使用</h3><ul><li>在src目录下创建一个文件夹store，并且在其中创建一个index.js文件<br>提取出一个公共的store对象，用于保存在多个组件中共享的状态</li><li>挂载到Vue实例中<br>在main.js文件，导入store对象，并且放在new Vue对象中</li><li>在其他组件中使用store对象中保存的状态即可<ul><li>通过<strong>this.$store.state.属性</strong>的方式来<strong>访问状态</strong></li><li>通过<strong>this.$store.commit(‘mutation中方法’)</strong>来<strong>修改状态</strong><br>注意事项：<br>我们通过提交mutation的方式，而非直接改变store.state.count。这是因为Vuex可以更明确的追踪状态的变化，所以不要直接改变store.state.count的值。</li></ul></li></ul><h3 id="5-Vuex核心概念"><a href="#5-Vuex核心概念" class="headerlink" title="5.Vuex核心概念"></a>5.Vuex核心概念</h3><p>前端路由的核心是什么呢？<br>改变URL，但是页面不进行整体的刷新。</p><ul><li><h3 id="State"><a href="#State" class="headerlink" title="State"></a>State</h3><p>State单一状态树（英文名称是Single Source of Truth，也可以翻译成单一数据源）来管理应用层级的全部状态</p></li><li><h4 id="Getters"><a href="#Getters" class="headerlink" title="Getters"></a>Getters</h4><p>可以认为是 store 的计算属性。就像计算属性一样，getter 的返回值会根据它的依赖被缓存起来，且只有当它的依赖值发生了改变才会被重新计算。</p><p>Getters基本使用：从store中获取一些<strong>state变异后的状态</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 通过属性访问</span>  getters:&#123;     agesGreater:<span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;       <span class="hljs-keyword">return</span> state.students.filter(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.age &gt;= <span class="hljs-number">20</span>)     &#125;,    <span class="hljs-comment">//  Getter 也可以接受其他 getter 作为第二个参数</span>     agesCount:<span class="hljs-function">(<span class="hljs-params">state,getters</span>) =&gt;</span> &#123;       <span class="hljs-keyword">return</span> getters.agesGreater.length     &#125;  &#125;,  <span class="hljs-comment">// 通过方法访问</span>  getters: &#123;    <span class="hljs-comment">// 可以通过让 getter 返回一个函数，来实现给 getter 传参。在 store 里的数组进行查询时非常有用。</span>    getstuById: <span class="hljs-function"><span class="hljs-params">state</span> =&gt;</span> &#123;      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">id</span> =&gt;</span> &#123;        <span class="hljs-keyword">return</span> state.students.find(<span class="hljs-function"><span class="hljs-params">s</span> =&gt;</span> s.id === id)      &#125;    &#125;  &#125;</code></pre></div><p>mapGetters 辅助函数</p><p>mapGetters 辅助函数仅仅是将 store 中的 getter 映射到局部计算属性：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapGetters &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  computed: &#123;  <span class="hljs-comment">// 使用对象展开运算符将 getter 混入 computed 对象中</span>    ...mapGetters([      <span class="hljs-string">'doneTodosCount'</span>,      <span class="hljs-string">'anotherGetter'</span>    ])    <span class="hljs-comment">//想将一个 getter 属性另取一个名字，使用对象形式</span>    ...mapGetters(&#123;    <span class="hljs-comment">// 把 `this.doneCount` 映射为 `this.$store.getters.doneTodosCount`</span>    doneCount: <span class="hljs-string">'doneTodosCount'</span>  &#125;)    &#125;  &#125;</code></pre></div><p>getter 在<strong>通过属性访问</strong>时是作为 <strong>Vue 的响应式系统的一部分缓存</strong>其中的。</p><p>getter 在<strong>通过方法访问</strong>时，每次都会去进行调用，而<strong>不会缓存结果</strong>。</p></li><li><h4 id="Mutation"><a href="#Mutation" class="headerlink" title="Mutation"></a>Mutation</h4><p><strong>Vuex的store状态的更新</strong>唯一方式：<strong>提交Mutation</strong><br>Mutation主要包括两部分：<br><strong>字符串的事件类型（type）</strong><br>一个<strong>回调函数（handler）</strong>,该回调函数的第一个参数就是state。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// mutations的定义方式</span>  mutations:&#123;    increment(state)&#123;      state.coun++    &#125;  &#125;  <span class="hljs-comment">// 通过mutations更新</span>  increment:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;    <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">'increment'</span>)  &#125;</code></pre></div><ul><li><p>Mutation传递参数</p><p>在通过mutation更新数据的时候, 有可能我们希望携带一些<strong>额外的参数</strong>，该参数被称为是mutation的<strong>载荷(Payload)</strong></p><p>当有很多参数需要传递：<br>我们通常会以对象的形式传递, 也就是payload是一个对象.<br>这个时候可以再从对象中取出相关的信息.</p><div class="hljs"><pre><code class="hljs js">changeCount(state,payload)&#123;state.count = payload.count&#125;changeCount:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123; <span class="hljs-keyword">this</span>.$store.commit(<span class="hljs-string">'changeCount'</span>,&#123;<span class="hljs-attr">count</span>:<span class="hljs-number">0</span>&#125;)<span class="hljs-comment">//另外一种提交风格, 它是一个包含type属性的对象</span><span class="hljs-keyword">this</span>.$store.commit(&#123;  type: <span class="hljs-string">'changeCount'</span>,  amount: <span class="hljs-number">10</span>&#125;) &#125;</code></pre></div></li><li><p>Mutation响应规则</p><p>Vuex的store中的state是响应式的, 当state中的数据发生改变时, Vue组件会自动更新.<br>必须遵守一些Vuex对应的规则:</p><ul><li>提前在store中初始化好所需的属性.</li><li>当给state中的对象添加新属性时, 使用下面的方式:<br>方式一: 使用Vue.set(obj, ‘newProp’, 123)<br>方式二: 用新对象给旧对象重新赋值</li></ul></li><li><p>Mutation常量类型</p><p>使用<strong>常量</strong>替代<strong>Mutation事件的类型.</strong><br>创建一个文件: mutation-types.js, 并且在其中定义我们的常量.</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// mutation-types.js</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> SOME_MUTATION = <span class="hljs-string">'SOME_MUTATION'</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// store.js</span><span class="hljs-keyword">import</span> Vuex <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">import</span> &#123; SOME_MUTATION &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'./mutation-types'</span><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;  state: &#123; ... &#125;,  mutations: &#123;    <span class="hljs-comment">// 我们可以使用 ES2015 风格的计算属性命名功能来使用一个常量作为函数名</span>    [SOME_MUTATION] (state) &#123;      <span class="hljs-comment">// mutate state</span>    &#125;  &#125;&#125;)</code></pre></div></li><li><p>Mutation同步函数</p><p>通常情况下, Vuex要求我们<strong>Mutation中的方法</strong>必须是<strong>同步方法</strong>.<br>主要的原因是当我们使用devtools时, 可以devtools可以帮助我们捕捉mutation的快照.<br>但是如果是异步操作, 那么devtools将不能很好的追踪这个操作什么时候会被完成.</p></li><li><p>在组件中提交 Mutation</p><p>在组件中使用 this.$store.commit(‘xxx’) 提交 mutation，或者使用 mapMutations 辅助函数将组件中的 methods 映射为 store.commit 调用（需要在根节点注入 store）。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  methods: &#123;    ...mapMutations([      <span class="hljs-string">'increment'</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.commit('increment')`</span>      <span class="hljs-comment">// `mapMutations` 也支持载荷：</span>      <span class="hljs-string">'incrementBy'</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.commit('incrementBy', amount)`</span>    ]),    ...mapMutations(&#123;      add: <span class="hljs-string">'increment'</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.commit('increment')`</span>    &#125;)  &#125;&#125;</code></pre></div></li></ul></li><li><h4 id="Action"><a href="#Action" class="headerlink" title="Action"></a>Action</h4><p>Action类似于Mutation, 但是是用来代替Mutation进行异步操作的.</p><p>Action与Mutaion的区别：</p><ul><li><p>Action 提交的是 mutation，而不是直接变更状态。</p></li><li><p>Action 可以包含任意异步操作。</p><p>context是什么?</p></li></ul><p>context是和store对象具有相同方法和属性的对象.也就是说, 我们可以通过context去进行commit相关的操作,或者通过 context.state 和 context.getters 来获取 state 和 getters。</p><div class="hljs"><pre><code class="hljs js">actions:&#123;    increment(context)&#123;      context.commit(<span class="hljs-string">'increment'</span>)    &#125;,&#125;</code></pre></div><ul><li><p>Action的分发</p><p>在Vue组件中, 如果我们调用action中的方法, 那么就需要使用<strong>dispatch</strong></p><div class="hljs"><pre><code class="hljs js">methods：&#123;    increment()&#123;     <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'increment'</span>)    &#125;&#125;</code></pre></div><p>Actions 支持同样的载荷方式和对象方式进行分发：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 以载荷形式分发</span><span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'incrementAsync'</span>, &#123;  amount: <span class="hljs-number">10</span>&#125;)<span class="hljs-comment">// 以对象形式分发</span><span class="hljs-keyword">this</span>.$store.dispatch(&#123;  type: <span class="hljs-string">'incrementAsync'</span>,  amount: <span class="hljs-number">10</span>&#125;)</code></pre></div></li><li><p>Action返回的Promise</p><div class="hljs"><pre><code class="hljs js">actions:&#123;    increment(context)&#123;      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;          context.commit(<span class="hljs-string">'increment'</span>)          resolve()        &#125;,<span class="hljs-number">1000</span>)      &#125;)    &#125;  &#125;methods：&#123;  increment()&#123;   <span class="hljs-keyword">this</span>.$store.dispatch(<span class="hljs-string">'increment'</span>).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span>&#123;     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'完成了更新操作'</span>);     &#125;)  &#125;&#125;</code></pre></div><p>一个 store.dispatch 在不同模块中可以触发多个 action 函数。在这种情况下，只有当所有触发函数完成后，返回的 Promise 才会执行。</p></li><li><p>在组件中分发 Action</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123; mapActions &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">'vuex'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;  <span class="hljs-comment">// ...</span>  methods: &#123;    ...mapActions([      <span class="hljs-string">'increment'</span>, <span class="hljs-comment">// 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`</span>      <span class="hljs-comment">// `mapActions` 也支持载荷：</span>      <span class="hljs-string">'incrementBy'</span> <span class="hljs-comment">// 将 `this.incrementBy(amount)` 映射为 `this.$store.dispatch('incrementBy', amount)`</span>    ]),    ...mapActions(&#123;      add: <span class="hljs-string">'increment'</span> <span class="hljs-comment">// 将 `this.add()` 映射为 `this.$store.dispatch('increment')`</span>    &#125;)  &#125;&#125;</code></pre></div></li></ul></li><li><h4 id="Module"><a href="#Module" class="headerlink" title="Module"></a>Module</h4><p>Vuex允许我们将store分割成模块(Module), 而每个模块拥有自己的state、mutation、action、getters等</p><ul><li><p>Module局部状态</p><p>对于模块内部的 mutation 和 getter，接收的第一个参数是模块的局部状态对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  state: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (&#123;    count: <span class="hljs-number">0</span>  &#125;),  mutations: &#123;    increment (state) &#123;      <span class="hljs-comment">// 这里的 `state` 对象是模块的局部状态</span>      state.count++    &#125;  &#125;,  getters: &#123;    doubleCount (state) &#123;      <span class="hljs-keyword">return</span> state.count * <span class="hljs-number">2</span>    &#125;  &#125;&#125;</code></pre></div><p>对于模块内部的 action，局部状态通过 context.state 暴露出来，根节点状态则为 context.rootState：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  actions: &#123;    incrementIfOddOnRootSum (&#123; state, commit, rootState &#125;) &#123;      <span class="hljs-keyword">if</span> ((state.count + rootState.count) % <span class="hljs-number">2</span> === <span class="hljs-number">1</span>) &#123;        commit(<span class="hljs-string">'increment'</span>)      &#125;    &#125;  &#125;&#125;</code></pre></div><p>对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">const</span> moduleA = &#123;  <span class="hljs-comment">// ...</span>  getters: &#123;    sumWithRootCount (state, getters, rootState) &#123;      <span class="hljs-keyword">return</span> state.count + rootState.count    &#125;  &#125;&#125;</code></pre></div></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Promise语法</title>
    <link href="/2020/06/18/Promise%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/06/18/Promise%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200618120131804.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-基本含义"><a href="#1-基本含义" class="headerlink" title="1.基本含义"></a>1.基本含义</h2><h3 id="抽象表达"><a href="#抽象表达" class="headerlink" title="抽象表达:"></a>抽象表达:</h3><p>Promise是JS中进行异步编程的解决方案</p><h3 id="具体表达"><a href="#具体表达" class="headerlink" title="具体表达:"></a>具体表达:</h3><p>从语法上来说: Promise是一个对象，从它可以获取异步操作的消息<br>从功能上来说: Promise对象用来封装一个异步操作并可以获取其结果</p><p>应用场景：解决复杂网络请求出现的回调地狱</p><h2 id="2-语法"><a href="#2-语法" class="headerlink" title="2.语法"></a>2.语法</h2><p><code>new Promise( function(resolve, reject) {...} /* executor */ );</code></p><p>Promise构造函数: Promise (executor) {}<br>executor函数: 同步执行 (resolve, reject) =&gt; {}<br>resolve函数: 内部定义成功时我们调用的函数 value =&gt; {}<br>reject函数: 内部定义失败时我们调用的函数 reason =&gt; {}<br>说明: executor会在Promise内部立即同步回调,异步操作在执行器中执行</p><p><strong>executor解析</strong></p><ul><li>executor是带有 resolve 和 reject 两个参数的函数 。</li><li>Promise构造函数执行时立即调用executor 函数， resolve 和 reject 两个函数作为参数传递给executor（executor 函数在Promise构造函数返回所建promise实例对象前被调用）。</li><li>executor 内部通常会执行一些异步操作，一旦异步操作执行完毕(可能成功/失败)，要么调用resolve函数来将promise状态改成fulfilled，要么调用reject 函数将promise的状态改为rejected。</li></ul><h2 id="3-Promise三种状态"><a href="#3-Promise三种状态" class="headerlink" title="3.Promise三种状态"></a>3.Promise三种状态</h2><p>首先, 当开发中有异步操作时, 就可以给异步操作包装一个Promise，异步操作之后会有三种状态。</p><ul><li>pending：等待状态，比如正在进行网络请求，或者定时器没有到时间。</li><li>fulfilled：满足状态，当我们主动回调了resolve时，就处于该状态，并且会回调.then()</li><li>rejected：拒绝状态，当我们主动回调了reject时，就处于该状态，并且会回调.catch()</li></ul><p><img src="https://img-blog.csdnimg.cn/20200618115852720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：</p><p>（1）<code>Promise</code>对象的状态不受外界影响。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态。<br>（2）一旦状态改变，就不会再变，任何时候都可以得到这个结果。<code>Promise</code>对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>和从<code>pending</code>变为<code>rejected</code>。只要这两种情况发生，状态就凝固了，不会再变了，会一直保持这个结果，这时就称为 resolved（已定型）。</p><h2 id="4-基本用法"><a href="#4-基本用法" class="headerlink" title="4.基本用法"></a>4.基本用法</h2><p>Promise对象是一个构造函数，用来生成Promise实例。Promise实例生成以后，可以用then方法分别指定resolved状态和rejected状态的回调函数。</p><h3 id="基础示例"><a href="#基础示例" class="headerlink" title="基础示例"></a>基础示例</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> myFirstPromise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>)</span>&#123;    <span class="hljs-comment">//当异步代码执行成功时，我们才会调用resolve(...), 当异步代码失败时就会调用reject(...)</span>    <span class="hljs-comment">//在本例中，我们使用setTimeout(...)来模拟异步代码，实际编码时可能是XHR请求或是HTML5的一些API方法.</span>    setTimeout(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;        resolve(<span class="hljs-string">"成功!"</span>); <span class="hljs-comment">//代码正常执行！</span>    &#125;, <span class="hljs-number">250</span>);&#125;);myFirstPromise.then(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">successMessage</span>)</span>&#123;    <span class="hljs-comment">//successMessage的值是上面调用resolve(...)方法传入的值.</span>    <span class="hljs-comment">//successMessage参数不一定非要是字符串类型，这里只是举个例子</span>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"Yay! "</span> + successMessage);&#125;);</code></pre></div><h2 id="5-方法"><a href="#5-方法" class="headerlink" title="5.方法"></a>5.方法</h2><h3 id="5-1Promise-prototype-then"><a href="#5-1Promise-prototype-then" class="headerlink" title="5.1Promise.prototype.then()"></a>5.1Promise.prototype.then()</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;resolve(<span class="hljs-string">'成功！'</span>);<span class="hljs-comment">// or</span><span class="hljs-comment">// reject(new Error("出错了！"));</span>&#125;);p1.then(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> &#123;  <span class="hljs-built_in">console</span>.log(value); <span class="hljs-comment">// 成功！</span>&#125;, reason =&gt; &#123;  <span class="hljs-built_in">console</span>.error(reason); <span class="hljs-comment">// 出错了！</span>&#125;);</code></pre></div><p>then方法的第一个参数是resolved状态的回调函数，第二个参数（可选）是rejected状态的回调函数。<br>说明: 作用是为 Promise 实例添加状态改变时的回调函数,返回一个新的promise对象</p><h3 id="5-2Promise-prototype-catch"><a href="#5-2Promise-prototype-catch" class="headerlink" title="5.2Promise.prototype.catch()"></a>5.2Promise.prototype.catch()</h3><div class="hljs"><pre><code class="hljs js">p.catch(onRejected);p.catch(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">reason</span>) </span>&#123; <span class="hljs-comment">// 拒绝</span>&#125;);</code></pre></div><p>Promise.prototype.catch()方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p><h3 id="5-3Promise-all"><a href="#5-3Promise-all" class="headerlink" title="5.3Promise.all()"></a>5.3Promise.all()</h3><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br><code>const p = Promise.all([p1, p2, p3]);</code></p><p>说明: 返回一个新的promise, 只有所有的promise都成功才成功, 只要有一个失败了就直接失败</p><h3 id="5-4Promise-race"><a href="#5-4Promise-race" class="headerlink" title="5.4Promise.race()"></a>5.4Promise.race()</h3><p>用于将多个 Promise 实例，包装成一个新的 Promise 实例。<br><code>const p = Promise.race([p1, p2, p3]);</code></p><p>说明: 返回一个新的promise, 第一个完成的promise的结果状态就是最终的结果状态</p><h2 id="async-函数"><a href="#async-函数" class="headerlink" title="async 函数"></a>async 函数</h2><h3 id="基本含义"><a href="#基本含义" class="headerlink" title="基本含义"></a>基本含义</h3><p>Generator 函数的语法糖。async异步函数可以包含await指令，该指令会暂停异步函数的执行，并等待Promise执行，然后继续执行异步函数，并返回结果。</p><p>注意：await 关键字只在异步函数内有效。如果你在异步函数外使用它，会抛出语法错误。</p><p><strong>async/await</strong>的目的是<strong>简化</strong>使用<strong>多个 promise</strong> 时的<strong>同步行为</strong>，并对一组 Promises执行某些操作</p><h3 id="特点-async函数对-Generator-函数的改进"><a href="#特点-async函数对-Generator-函数的改进" class="headerlink" title="特点(async函数对 Generator 函数的改进)"></a>特点(async函数对 Generator 函数的改进)</h3><p>（1）内置执行器。<br><code>async</code>函数的执行，与普通函数一模一样，只要一行。</p><div class="hljs"><pre><code class="hljs javascript">asyncReadFile();</code></pre></div><p>上面的代码调用了<code>asyncReadFile</code>函数，然后它就会自动执行，输出最后结果。</p><p>Generator 函数，需要调用<code>next</code>方法，或者用<code>co</code>模块，才能真正执行，得到最后结果</p><p>（2）更好的语义。<br>async函数就是将 Generator 函数的星号（<code>*</code>）替换成<code>async</code>，将<code>yield</code>替换成<code>await</code><br><code>async</code>表示函数里有异步操作，<code>await</code>表示紧跟在后面的表达式需要等待结果。</p><p>（3）返回值是 Promise。<br><code>async</code>函数的返回值是 Promise 对象，可以用<code>then</code>方法指定下一步的操作。</p><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p>async函数返回一个 Promise 对象，可以使用then方法添加回调函数。当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体内后面的语句。</p>]]></content>
    
    
    <categories>
      
      <category>promise</category>
      
    </categories>
    
    
    <tags>
      
      <tag>promise async</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueRouter——学习笔记五</title>
    <link href="/2020/06/17/VueRouter%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/"/>
    <url>/2020/06/17/VueRouter%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%94/</url>
    
    <content type="html"><![CDATA[<h2 id="vue-router"><a href="#vue-router" class="headerlink" title="vue-router"></a>vue-router</h2><h3 id="1-路由"><a href="#1-路由" class="headerlink" title="1.路由"></a>1.路由</h3><p>路由（routing）就是通过互联的网络把信息从源地址传输到目的地址的活动. — 维基百科</p><p>路由器提供了两种机制: 路由和转送.</p><ul><li>路由是决定数据包从来源到目的地的路径.</li><li>转送将输入端的数据转移到合适的输出端.</li></ul><p>路由中有一个非常重要的概念叫路由表.路由表本质上就是一个映射表, 决定了数据包的指向.</p><h4 id="1-1后端路由"><a href="#1-1后端路由" class="headerlink" title="1.1后端路由"></a>1.1后端路由</h4><p>一个页面有自己对应的网址, 也就是URL。URL会发送到服务器, 服务器会通过正则对该URL进行匹配, 并且最后交给一个Controller进行处理。Controller进行各种处理, 最终生成HTML或者数据, 返回给前端。</p><h4 id="1-2前端路由"><a href="#1-2前端路由" class="headerlink" title="1.2前端路由"></a>1.2前端路由</h4><p>前端路由的<strong>核心</strong>是什么呢？<strong>改变URL</strong>，但是<strong>页面不进行整体的刷新</strong>。</p><p>前端路由规则：</p><ul><li><p>URL的hash<br>URL的hash也就是锚点(#), 本质上是改变window.location的href属性.<br>我们可以通过直接赋值location.hash来改变href, 但是页面不发生刷新</p></li><li><p>HTML5的history模式</p><p>history接口是HTML5新增的, 它有五种模式改变URL而不刷新页面.</p><ul><li>history.pushState()</li><li>history.replaceState()</li><li>history.go()<br>补充说明：history.back() 等价于 history.go(-1)；history.forward() 则等价于 history.go(1)。这三个接口等同于浏览器界面的前进后退。</li></ul></li></ul><h3 id="2-认识vue-router"><a href="#2-认识vue-router" class="headerlink" title="2.认识vue-router"></a>2.认识vue-router</h3><p>vue-router是Vue.js官方的路由插件，它和vue.js是深度集成的，适合用于构建单页面应用。<br>vue-router是基于路由和组件的,路由用于设定访问路径, 将路径和组件映射起来.<br>在vue-router的单页面应用中, 页面的路径的改变就是组件的切换.</p><h4 id="2-1安装vue-router"><a href="#2-1安装vue-router" class="headerlink" title="2.1安装vue-router"></a>2.1安装vue-router</h4><p><code>npm install vue-router --save</code></p><p>在模块化工程中使用</p><ul><li>导入路由对象，并且调用 Vue.use(VueRouter)</li><li>创建路由实例，并且传入路由映射配置</li><li>在Vue实例中挂载创建的路由实例</li></ul><p>创建路由实例（在src目录下，新建router文件夹，并创建index.js）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">'vue'</span><span class="hljs-keyword">import</span> VueRouter <span class="hljs-keyword">from</span> <span class="hljs-string">'vue-router'</span><span class="hljs-comment">// 1.注入插件</span>Vue.use(VueRouter)<span class="hljs-comment">// 2.定义路由</span><span class="hljs-keyword">const</span> routes = [  &#123;    path: <span class="hljs-string">'/'</span>,    name: <span class="hljs-string">'Home'</span>,    component: Home  &#125;]<span class="hljs-comment">// 3.创建router实例</span><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;  routers&#125;)<span class="hljs-comment">// 4.导出router实例</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> router</code></pre></div><p>挂载到Vue实例中(main.js入口文件)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> router <span class="hljs-keyword">from</span> <span class="hljs-string">'./router'</span><span class="hljs-keyword">new</span> Vue(&#123;  router,  render: <span class="hljs-function"><span class="hljs-params">h</span> =&gt;</span> h(App)&#125;).$mount(<span class="hljs-string">'#app'</span>)</code></pre></div><h4 id="2-2使用vue-router的步骤"><a href="#2-2使用vue-router的步骤" class="headerlink" title="2.2使用vue-router的步骤"></a>2.2使用vue-router的步骤</h4><ul><li><p>创建路由组件</p></li><li><p>配置路由映射: 组件和路径映射关系</p></li><li><p>使用路由: <code>&lt;router-link&gt;</code>和<code>&lt;router-view&gt;</code></p><ul><li><p>router-link 来导航</p><p><code>&lt;router-link&gt;</code>: 该标签是一个vue-router中已经内置的组件, 它会被渲染成一个<code>&lt;a&gt;</code>标签.</p></li><li><p>router-view 来显示匹配到的组件</p><p><code>&lt;router-view&gt;</code>: 该标签会根据当前的路径, 动态渲染出不同的组件.<br>网页的其他内容, 比如顶部的标题/导航, 或者底部的一些版权信息等会和<code>&lt;router-view&gt;</code>处于同一个等级.<br>在路由切换时, 切换的是<code>&lt;router-view&gt;</code>挂载的组件, 其他内容不会发生改变.</p></li></ul></li></ul><p>注意事项：</p><p>1.路由的默认路径<br>示例：让路径默认跳到到首页, 并且<code>&lt;router-view&gt;</code>渲染首页组件</p><ul><li>在routes中重新配置了一个映射</li><li>path配置根路径: /</li><li>redirect（重定向）, 将根路径重定向到/home的路径下</li></ul><p>2.HTML5的History模式<br>改变路径的方式有两种:</p><ul><li>URL的hash</li><li>HTML5的history （使用此模式：在router实例中添加mode属性，并设置其值为history）</li></ul><p>默认情况下, 路径的改变使用的URL的hash.</p><ol start="3"><li><strong>router-link</strong> 的属性</li></ol><ul><li><p>to, 用于指定跳转的路径</p></li><li><p>tag，可以指定router-link渲染成什么组件, 比如渲染成一个li元素, 而不是a元素</p></li><li><p>replace，不会留下history记录, 所以指定replace的情况下, 后退键返回不能返回到上一个页面中</p></li><li><p>active-class，当router-link对应的路由匹配成功时, 会自动给当前元素设置一个router-link-active的class, 设置active-class可以修改默认的名称.</p><ul><li>在进行高亮显示的导航菜单或者底部tabbar时, 会使用到该类.</li><li>但是通常不会修改类的属性, 会直接使用默认的router-link-active即可.</li><li>如果需要修改，该class具体的名称也可以通过router实例的属性进行修改<br><code>linkActiveClass:&#39;active&#39;</code></li></ul></li></ul><ol start="4"><li>路由代码跳转（另一种方式）<br><code>this.$router.push(&#39;/home&#39;)</code></li><li>动态路由(页面的path路径不确定)<br>动态路由也是路由传递数据的一种方式</li></ol><h3 id="3-路由懒加载"><a href="#3-路由懒加载" class="headerlink" title="3.路由懒加载"></a>3.路由懒加载</h3><p>路由懒加载的主要作用就是将路由对应的组件打包成一个个的js代码块.<br>只有在这个路由被访问到的时候, 才加载对应的组件<br><code>const Home = () =&gt; import(&#39;../components/Home.vue&#39;)</code></p><h3 id="4-路由嵌套"><a href="#4-路由嵌套" class="headerlink" title="4.路由嵌套"></a>4.路由嵌套</h3><p><img src="https://img-blog.csdnimg.cn/20200617234419267.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>实现嵌套路由有两个步骤:</p><ul><li>创建对应的子组件, 并且在路由映射中配置对应的子路由.</li><li>在组件内部使用<code>&lt;router-view&gt;</code>标签.</li></ul><h3 id="5-获取参数"><a href="#5-获取参数" class="headerlink" title="5.获取参数"></a>5.获取参数</h3><p>通过<strong>$route对象</strong>获取</p><p><strong>$route和$router的区别</strong></p><ul><li>$router为VueRouter实例，想要导航到不同URL，则使用$router.push方法</li><li>$route为当前router跳转对象里面可以获取name、path、query、params等</li></ul><h3 id="6-传递参数"><a href="#6-传递参数" class="headerlink" title="6.传递参数"></a>6.传递参数</h3><ul><li><p>传递参数主要有两种类型</p><ul><li><p>params的类型</p><p>配置路由格式: /router/:id<br>传递的方式: 在path后面跟上对应的值<br>传递后形成的路径: /router/123, /router/abc</p></li><li><p>query的类型</p><p>配置路由格式: /router, 也就是普通配置<br>传递的方式: 对象中使用query的key作为传递方式<br>传递后形成的路径: /router?id=123, /router?id=abc</p></li></ul></li><li><p>使用方式</p><ul><li>传递参数方式一: <code>&lt;router-link&gt;</code></li><li>传递参数方式二: JavaScript代码</li></ul></li></ul><h3 id="7-导航守卫"><a href="#7-导航守卫" class="headerlink" title="7.导航守卫"></a>7.导航守卫</h3><ul><li><p>什么是导航守卫?<br>vue-router提供的导航守卫主要用来监听监听路由的进入和离开的.<br>vue-router提供了beforeEach和afterEach的钩子函数, 它们会在路由即将改变前和改变后触发.</p></li><li><p>导航守卫使用<br>利用beforeEach来完成标题的修改.</p><ul><li><p>首先, 我们可以在钩子当中定义一些标题, 可以利用meta来定义</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//在定义路由中设置</span>meta:&#123;      title:<span class="hljs-string">'首页'</span>&#125;</code></pre></div></li><li><p>其次, 利用导航守卫,修改我们的标题.</p><div class="hljs"><pre><code class="hljs js">router.beforeEach(<span class="hljs-function">(<span class="hljs-params">to,<span class="hljs-keyword">from</span>,next</span>) =&gt;</span>&#123;  <span class="hljs-built_in">window</span>.document.title = to.meta.title  next()&#125;)导航钩子的三个参数解析:to: 即将要进入的目标的路由对象.<span class="hljs-keyword">from</span>: 当前导航即将要离开的路由对象.next: 调用该方法后, 才能进入下一个钩子.</code></pre></div></li></ul></li></ul><p>导航守卫补充<br>补充一:如果是后置钩子, 也就是afterEach, 不需要主动调用next()函数.<br>补充二: 上面我们使用的导航守卫, 被称之为全局守卫</p><ul><li>路由独享的守卫</li><li>组件内的守卫</li></ul><h3 id="8-keep-alive"><a href="#8-keep-alive" class="headerlink" title="8.keep-alive"></a>8.keep-alive</h3><p>keep-alive 是 Vue 内置的一个组件，可以使被包含的组件保留状态，或避免重新渲染。<br>它们有两个非常重要的属性:</p><ul><li>include - 字符串或正则表达，只有匹配的组件会被缓存</li><li>exclude - 字符串或正则表达式，任何匹配的组件都不会被缓存</li></ul><p>router-view 也是一个组件，如果直接被包在 keep-alive 里面，所有路径匹配到的视图组件都会被缓存</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>VueCLI——学习笔记四</title>
    <link href="/2020/06/17/VueCLI%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/"/>
    <url>/2020/06/17/VueCLI%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E5%9B%9B/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-CLI"><a href="#Vue-CLI" class="headerlink" title="Vue CLI"></a>Vue CLI</h2><ul><li><p>CLI是什么意思?<br>CLI是Command-Line Interface, 翻译为命令行界面, 但是俗称脚手架.<br>Vue CLI是一个官方发布 vue.js 项目脚手架,使用 vue-cli 可以快速搭建Vue开发环境以及对应的webpack配置.</p></li><li><p>Vue CLI使用前提 - Node<br>Vue CLI 需要 Node.js 8.9 或更高版本 (推荐 8.11.0+)。</p></li><li><p>什么是NPM呢?<br>NPM的全称是Node Package Manager<br>是一个NodeJS包管理和分发工具，已经成为了非官方的发布Node模块（包）的标准。经常使用NPM来安装一些开发过程中依赖包.</p></li><li><p>cnpm安装<br>由于国内直接使用 npm 的官方镜像是非常慢的，这里推荐使用淘宝 NPM 镜像。<br>你可以使用淘宝定制的 cnpm (gzip 压缩支持) 命令行工具代替默认的 npm:<br>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a><br>这样就可以使用 cnpm 命令来安装模块了：<br>cnpm install [name]</p></li></ul><h3 id="1-Vue-CLI的使用"><a href="#1-Vue-CLI的使用" class="headerlink" title="1.Vue CLI的使用"></a>1.Vue CLI的使用</h3><ul><li><p>安装Vue脚手架：npm install -g @vue/cli</p></li><li><p>Vue CLI初始化项目<br><code>vue create my-project</code></p><p><img src="https://img-blog.csdnimg.cn/20200617180411671.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注：也可以通过 vue ui 命令以图形化界面创建和管理项目</p><p>目录结构：</p><p><img src="https://img-blog.csdnimg.cn/20200617181052840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="2-runtime-compiler（运行时-编译器）和runtime-only（只含有运行时版本）的区别"><a href="#2-runtime-compiler（运行时-编译器）和runtime-only（只含有运行时版本）的区别" class="headerlink" title="2.runtime-compiler（运行时+编译器）和runtime-only（只含有运行时版本）的区别"></a>2.runtime-compiler（运行时+编译器）和runtime-only（只含有运行时版本）的区别</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//需要编译器</span><span class="hljs-keyword">new</span> Vue(&#123;el:<span class="hljs-string">'#app'</span>,components:&#123;App&#125;,template:<span class="hljs-string">'&lt;App/&gt;'</span>&#125;)<span class="hljs-comment">//不需要编译器</span><span class="hljs-keyword">new</span> Vue(&#123;el:<span class="hljs-string">'#app'</span>,render h =&gt; h(App)&#125;)</code></pre></div><p>如果在之后的开发中，你依然使用template，就需要选择Runtime-Compiler<br>如果你之后的开发中，使用的是.vue文件夹开发，那么可以选择Runtime-only</p><ul><li><p>Vue程序运行过程</p><p>template -&gt; ast -&gt; render -&gt; vdom -&gt; 真实DOM</p><p><img src="https://img-blog.csdnimg.cn/20200617165922757.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>render函数的使用</p></li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">new</span> Vue(&#123;el:<span class="hljs-string">'#app'</span>,render:<span class="hljs-function">(<span class="hljs-params">createElement</span>)=&gt;</span>&#123;<span class="hljs-comment">//1.使用方式一</span><span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'标签'</span>，<span class="hljs-string">'相关数据对象（可以不传）'</span>，[<span class="hljs-string">'内容数组'</span>])<span class="hljs-comment">// render函数基本使用</span>        <span class="hljs-keyword">return</span> createElement(<span class="hljs-string">'div'</span>，<span class="hljs-string">'&#123;class:'</span>box<span class="hljs-string">'&#125;'</span>，[<span class="hljs-string">'内容数组'</span>])        <span class="hljs-comment">//2.使用方式二</span>        <span class="hljs-keyword">return</span> createElement(cpn)&#125;&#125;)</code></pre></div><h3 id="3-vue-config-js（自定义配置）"><a href="#3-vue-config-js（自定义配置）" class="headerlink" title="3.vue.config.js（自定义配置）"></a>3.vue.config.js（自定义配置）</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>.exports = &#123;  lintOnSave: <span class="hljs-literal">false</span>,  publicPath: process.env.NODE_ENV === <span class="hljs-string">"production"</span> ? <span class="hljs-string">"./"</span> : <span class="hljs-string">"/"</span>,  devServer: &#123;    proxy: &#123;      <span class="hljs-string">"/api"</span>: &#123;        target: <span class="hljs-string">"https://elm.cangdu.org"</span>,        changeOrigin: <span class="hljs-literal">true</span>,        pathRewrite: &#123;          <span class="hljs-string">"^/api"</span>: <span class="hljs-string">""</span>           &#125;      &#125;    &#125;  &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Webpack</title>
    <link href="/2020/06/16/Webpack/"/>
    <url>/2020/06/16/Webpack/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200616225712689.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="Webpack"><a href="#Webpack" class="headerlink" title="Webpack"></a>Webpack</h2><h3 id="1-基本概述"><a href="#1-基本概述" class="headerlink" title="1.基本概述"></a>1.基本概述</h3><p>是一个现代的JavaScript应用的静态模块打包工具</p><h3 id="2-安装依赖"><a href="#2-安装依赖" class="headerlink" title="2.安装依赖"></a>2.安装依赖</h3><p>1.首先需要安装Node.js（Node.js自带了软件包管理工具npm）</p><p>2.全局安装webpack：运行npm i webpack -g全局安装webpack，这样就能在全局使用webpack的命令</p><p>3.局部安装webpack：在项目根目录中运行npm i webpack –save-dev安装到项目依赖中</p><p>为什么全局安装后，还需要局部安装呢</p><ul><li>在终端直接执行webpack命令，使用的全局安装的webpack（只有那些安装到全局 -g 的工具，才能在终端中正常执行）</li><li>当在package.json中定义了scripts时，其中包含了webpack命令，那么使用的是局部webpack<br>注意：还需安装npm i webpack-cli -D</li></ul><h3 id="3-准备工作"><a href="#3-准备工作" class="headerlink" title="3.准备工作"></a>3.准备工作</h3><ul><li><p><strong>npm init</strong> 初始化项目，使用npm管理项目中的依赖包</p></li><li><p>创建项目基本的目录结构 dist 、src等</p><p>文件和文件夹解析：</p><ul><li>dist文件夹：用于存放之后打包的文件</li><li>src文件夹：用于存放我们写的源文件<ul><li>main.js：项目的入口文件。</li><li>mathUtils.js：定义了一些数学工具函数，可以在其他地方引用，并且使用。</li></ul></li><li>index.html：浏览器打开展示的首页html</li><li>package.json：通过npm init生成的，npm包管理的文件</li></ul></li><li><p>js文件的打包</p><p>使用webpack的指令：webpack src/js/main.js dist/bundle.js</p></li><li><p>使用打包后的文件</p><p>bundle.js文件，是webpack处理了项目直接文件依赖后生成的一个js文件，我们只需要将这个js文件在index.html中引入即可</p></li></ul><h3 id="4-Webpack配置"><a href="#4-Webpack配置" class="headerlink" title="4.Webpack配置"></a>4.Webpack配置</h3><ul><li><p>项目根目录中创建一个webpack.config.js文件。</p></li><li><p>webpack.config.js中配置指定入口文件和输出文件的路径</p></li><li><p>package.json中定义启动</p><p>可以在package.json的scripts中定义自己的执行脚本。<br><code>&quot;dev&quot;: &quot;webpack&quot;</code><br>执行命令 ： npm run dev<br>package.json中的scripts的脚本在执行时，会按照一定的顺序寻找命令对应的位置。首先，会寻找本地的node_modules/.bin路径中对应的命令。如果没有找到，会去全局的环境变量中寻找。</p></li></ul><h3 id="5-loader的使用"><a href="#5-loader的使用" class="headerlink" title="5.loader的使用"></a>5.loader的使用</h3><h4 id="5-1loader使用过程"><a href="#5-1loader使用过程" class="headerlink" title="5.1loader使用过程"></a>5.1loader使用过程</h4><p>步骤一：通过npm安装需要使用的loader<br>步骤二：在webpack.config.js中的modules关键字下进行配置</p><h4 id="5-2css文件处理"><a href="#5-2css文件处理" class="headerlink" title="5.2css文件处理:"></a>5.2css文件处理:</h4><p>1.安装 cnpm i style-loader css-loader –save-dev</p><p>2.修改webpack.config.js这个配置文件：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">module</span>: &#123; <span class="hljs-comment">// 用来配置第三方loader模块的</span>        rules: [ <span class="hljs-comment">// 文件的匹配规则</span>            &#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.css$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>] &#125;<span class="hljs-comment">//处理css文件的规则</span>        ]    &#125;</code></pre></div><p>注意：</p><ul><li>use表示使用哪些模块来处理test所匹配到的文件；</li><li>use中相关loader模块的调用顺序是从后向前调用的；</li><li>css-loader只负责加载css文件</li><li>style-loader负责将css具体样式嵌入到文档中</li></ul><h4 id="5-3less文件处理"><a href="#5-3less文件处理" class="headerlink" title="5.3less文件处理"></a>5.3less文件处理</h4><p>1.安装运行cnpm i less-loader less -D(-D是–save-dev的简写)<br>2.修改webpack.config.js这个配置文件：</p><div class="hljs"><pre><code class="hljs js">&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.less$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'less-loader'</span>] &#125;</code></pre></div><p>注意：这里还安装了less，因为webpack会使用less对less文件进行编译</p><h4 id="5-4sass文件处理"><a href="#5-4sass文件处理" class="headerlink" title="5.4sass文件处理"></a>5.4sass文件处理</h4><p>1.安装 cnpm i sass-loader node-sass –save-dev<br>2.在webpack.config.js中添加处理sass文件的loader模块：</p><div class="hljs"><pre><code class="hljs js">&#123; <span class="hljs-attr">test</span>: <span class="hljs-regexp">/\.scss$/</span>, <span class="hljs-attr">use</span>: [<span class="hljs-string">'style-loader'</span>, <span class="hljs-string">'css-loader'</span>, <span class="hljs-string">'sass-loader'</span>] &#125;</code></pre></div><p>注意：有时候使用npm i node-sass -D装不上，这时候，就必须使用 cnpm i node-sass -D</p><h4 id="5-5图片文件处理-（url-loader）"><a href="#5-5图片文件处理-（url-loader）" class="headerlink" title="5.5图片文件处理 （url-loader）"></a>5.5图片文件处理 （url-loader）</h4><p>1.cnpm i url-loader file-loader –save-dev<br>2.在webpack.config.js中添加loader模块：</p><div class="hljs"><pre><code class="hljs js">&#123;     test: <span class="hljs-regexp">/\.(png|jpg|gif)$/</span>,     use: [        &#123;        loader:<span class="hljs-string">'url-loader'</span> ,    option:&#123;            limit:<span class="hljs-number">8196</span>,            name:<span class="hljs-string">'img/[name].[hash:8].[ext]'</span>            <span class="hljs-comment">//可以在options中添加上如下选项:</span>            <span class="hljs-comment">//img：文件要打包到的文件夹</span>            <span class="hljs-comment">//name：获取图片原来的名字，放在该位置</span>            <span class="hljs-comment">//hash:8：为了防止图片名称冲突，依然使用hash，但是我们只保留8位</span>            <span class="hljs-comment">//ext：使用图片原来的扩展名</span>        &#125;        ]&#125;</code></pre></div><ul><li>可以通过limit指定进行base64编码的图片大小；只有小于指定字节（byte）的图片才会进行base64编码</li></ul><h4 id="5-6ES6语法处理-js兼容性处理"><a href="#5-6ES6语法处理-js兼容性处理" class="headerlink" title="5.6ES6语法处理(js兼容性处理)"></a>5.6ES6语法处理(js兼容性处理)</h4><p>1.安装<br>npm i babel-loader @babel/core core-js -D<br>npm i @babel/preset-env -D</p><p>2.配置</p><div class="hljs"><pre><code class="hljs js"> &#123; test: <span class="hljs-regexp">/\.js$/</span>, loader: <span class="hljs-string">'babel-loader'</span>, <span class="hljs-comment">//排除 node_modules 目录</span>exclude: <span class="hljs-regexp">/node_modules/</span> ,options:<span class="hljs-comment">//预设：指示babel做怎么样的兼容性处理</span>&#123;presets:[<span class="hljs-string">'@babel/preset-env'</span>，    &#123;<span class="hljs-comment">//按需加载</span>useBuiltIns:<span class="hljs-string">'usage'</span>,<span class="hljs-comment">//指定corejs版本</span>corejs&#123;version:<span class="hljs-number">3</span>&#125;,<span class="hljs-comment">//指定兼容性做到哪个版本浏览器</span>targets&#123;chrome:<span class="hljs-string">'60'</span>,firefix:<span class="hljs-string">'60'</span>,ie:<span class="hljs-string">'9'</span>,safari:<span class="hljs-string">'10'</span>,edge:<span class="hljs-string">'17'</span>&#125;&#125;]&#125;&#125;</code></pre></div><h4 id="5-7-vue文件封装处理"><a href="#5-7-vue文件封装处理" class="headerlink" title="5.7.vue文件封装处理"></a>5.7.vue文件封装处理</h4><p>1.安装vue-loader和vue-template-compiler<br>npm install vue-loader vue-template-compiler –save-dev<br>2.修改webpack.config.js的配置文件：</p><div class="hljs"><pre><code class="hljs js">&#123;test:<span class="hljs-regexp">/\.vue$/</span>,use:[<span class="hljs-string">'vue-loader'</span>]&#125;</code></pre></div><h3 id="6-plugin"><a href="#6-plugin" class="headerlink" title="6.plugin"></a>6.plugin</h3><h4 id="6-1基本介绍"><a href="#6-1基本介绍" class="headerlink" title="6.1基本介绍"></a>6.1基本介绍</h4><p>plugin是插件的意思，通常是用于对某个现有的架构进行扩展。<br>webpack中的插件，就是对webpack现有功能的各种扩展，比如打包优化，文件压缩等等。</p><h4 id="6-2使用过程"><a href="#6-2使用过程" class="headerlink" title="6.2使用过程"></a>6.2使用过程</h4><p>步骤一：通过npm安装需要使用的plugins(某些webpack已经内置的插件不需要安装)<br>步骤二：在webpack.config.js中的plugins中配置插件。</p><h4 id="6-3添加版权的Plugin"><a href="#6-3添加版权的Plugin" class="headerlink" title="6.3添加版权的Plugin"></a>6.3添加版权的Plugin</h4><p>该插件名字叫BannerPlugin，属于webpack自带的插件。</p><p>按照下面的方式来修改webpack.config.js的文件：</p><div class="hljs"><pre><code class="hljs js">plugins:[<span class="hljs-keyword">new</span> webpack.BannerPlugin(<span class="hljs-string">'最终版权归某某人所有'</span>)]</code></pre></div><h4 id="6-4打包html的plugin-HtmlWebpackPlugin插件"><a href="#6-4打包html的plugin-HtmlWebpackPlugin插件" class="headerlink" title="6.4打包html的plugin:HtmlWebpackPlugin插件"></a>6.4打包html的plugin:HtmlWebpackPlugin插件</h4><p>HtmlWebpackPlugin插件可以为我们做这些事情：</p><ul><li>自动生成一个index.html文件(可以指定模板来生成)</li><li>将打包的js文件，自动通过script标签插入到body中</li></ul><p>1.安装HtmlWebpackPlugin插件<br>npm install html-webpack-plugin –save-dev<br>2.使用插件，修改webpack.config.js文件中plugins部分的内容如下：</p><ul><li><p>这里的template表示根据什么模板来生成index.html</p></li><li><p>另外，我们需要删除之前在output中添加的publicPath属性,否则插入的script标签中的src可能会有问题</p><div class="hljs"><pre><code class="hljs js">plugins:[<span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;template:<span class="hljs-string">'./src/index.html'</span>&#125;)]</code></pre></div></li></ul><h3 id="7-本地开发服务器-devserver"><a href="#7-本地开发服务器-devserver" class="headerlink" title="7.本地开发服务器(devserver)"></a>7.本地开发服务器(devserver)</h3><p>实现代码实时打包编译，当修改代码之后，会自动进行打包构建，浏览器自动刷新。<br>特点：只会在内存中编译打包，不会有任何输出</p><p>1.运行cnpm i webpack-dev-server –save-dev安装到开发依赖</p><p>2.devserver也是作为webpack中的一个选项，选项本身可以设置如下属性：</p><ul><li>contentBase：为哪一个文件夹提供本地服务，默认是根文件夹，我们这里要填写./dist</li><li>port：端口号</li><li>historyApiFallback：在SPA页面中，依赖HTML5的history模式</li></ul><p>3.webpack.config.js文件配置修改如下：<br>我们可以再配置另外一个scripts：–open参数表示直接打开浏览器</p><h3 id="8-示例"><a href="#8-示例" class="headerlink" title="8.示例"></a>8.示例</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// webpack是基于Node进行构建的，webpack的配置文件中，任何合法的Node代码都是支持的</span><span class="hljs-comment">// const path = require('path');</span><span class="hljs-comment">// 如果要配置插件，需要在导出的对象中，挂载一个 plugins 节点</span><span class="hljs-keyword">const</span> HtmlWebpackPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'html-webpack-plugin'</span>);<span class="hljs-comment">//提取js中的css成单独文件</span><span class="hljs-keyword">const</span> MiniCssExtractPlugin = <span class="hljs-built_in">require</span>(<span class="hljs-string">'mini-css-extract-plugin'</span>);<span class="hljs-keyword">const</span> OptimizeCssAssetsWebpackPlugin = <span class="hljs-built_in">require</span> (<span class="hljs-string">'optimize-css-assets-webpack-plugin'</span>);<span class="hljs-comment">// const VueLoaderPlugin = require('vue-loader/lib/plugin');</span><span class="hljs-comment">// const webpack = require('webpack');</span><span class="hljs-comment">// 设置nodejs环境变量:决定使用browserslist的那个环境</span><span class="hljs-comment">// process.env.NODE_ENV ='development';</span><span class="hljs-comment">// 复用loader</span><span class="hljs-keyword">const</span> commentCSSLoader = [    MiniCssExtractPlugin.loader,     <span class="hljs-string">'css-loader'</span>,    &#123;        <span class="hljs-comment">// 需要在package.json中定义browserslist</span>        <span class="hljs-comment">/*</span><span class="hljs-comment">        "browserslist": &#123;</span><span class="hljs-comment">            "development": [</span><span class="hljs-comment">              "last 1 chrome version",</span><span class="hljs-comment">              "last 1 firefox version",</span><span class="hljs-comment">              "last 1 safari version"</span><span class="hljs-comment">            ],</span><span class="hljs-comment">            "production": [</span><span class="hljs-comment">              "&gt;0.2%",</span><span class="hljs-comment">              "not dead",</span><span class="hljs-comment">              "not op_mini all"</span><span class="hljs-comment">            ]</span><span class="hljs-comment">          &#125;*/</span><span class="hljs-comment">//css的兼容性处理 npm i postcss-loader postcss-preset-env -D        </span>        loader:<span class="hljs-string">'postcss-loader'</span>,        options:&#123;            ident:<span class="hljs-string">'postcss'</span>,            plugins:<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>[                <span class="hljs-built_in">require</span>(<span class="hljs-string">'postcss-preset-env'</span>)()            ]        &#125;     &#125;]<span class="hljs-built_in">module</span>.exports = &#123;    <span class="hljs-comment">// mode:'production',</span>    mode:<span class="hljs-string">'development'</span>,    entry: <span class="hljs-string">'./src/js/main.js'</span>, <span class="hljs-comment">// 入口文件</span>    output:&#123;        filename:<span class="hljs-string">'js/bundle.js'</span>,        path: __dirname + <span class="hljs-string">'/build'</span>    &#125;,    <span class="hljs-built_in">module</span>:&#123;        rules:[            &#123;                 test: <span class="hljs-regexp">/\.css$/</span>,                 use: [...commentCSSLoader]             &#125;,            &#123;                 test: <span class="hljs-regexp">/\.less$/</span>,                 use: [...commentCSSLoader,                    <span class="hljs-string">'less-loader'</span>]             &#125;,             &#123;                 test: <span class="hljs-regexp">/\.(jpg|png|gif|bmp|jpeg)$/</span>,                use: &#123;                    loader:<span class="hljs-string">'url-loader'</span>,                    options:&#123;                        esModule: <span class="hljs-literal">false</span>,                        limit: <span class="hljs-number">10240</span>,                        name:<span class="hljs-string">'[name].[ext]-[hash:8]'</span>,                        outputPath:<span class="hljs-string">'imgs'</span>                    &#125;                &#125;            &#125;, <span class="hljs-comment">// 处理图片路径的loader</span>            &#123;                test:<span class="hljs-regexp">/\.html$/</span>,                loader:<span class="hljs-string">'html-loader'</span>            &#125;,            &#123;                 test: <span class="hljs-regexp">/\.(ttf|eot|svg|woff|woff2)$/</span>,                 use: <span class="hljs-string">'url-loader'</span> ,                outputPath:<span class="hljs-string">'font'</span>            &#125;,            <span class="hljs-comment">//自己写的js语法检查</span><span class="hljs-comment">//npm i eslint-loader eslint eslint-config-airbnb-base eslint-plugin-import -D</span>            &#123;                <span class="hljs-comment">// 在package.json中配置eslintConfig</span>                test:<span class="hljs-regexp">/\.js$/</span>,                exclude:<span class="hljs-regexp">/node_modules/</span>,                <span class="hljs-comment">// 优先执行</span>                enforce:<span class="hljs-string">'pre'</span>,                loader:<span class="hljs-string">'eslint-loader'</span>,                options:&#123;                    <span class="hljs-comment">// 自动修复eslint的错误</span>                    fix:<span class="hljs-literal">true</span>                &#125;            &#125;,            &#123;                test:<span class="hljs-regexp">/\.js$/</span>,                exclude:<span class="hljs-regexp">/node_modules/</span>,                loader:<span class="hljs-string">'babel-loader'</span>,                options:&#123;                    presets:[                        [                            <span class="hljs-string">'@babel/preset-env'</span>,                            &#123;                                useBuiltIns:<span class="hljs-string">'usage'</span>,                                corejs:&#123;<span class="hljs-attr">version</span>:<span class="hljs-number">3</span>&#125;,                                targets:&#123;                                    chrome:<span class="hljs-string">'60'</span>,                                    firefox:<span class="hljs-string">'60'</span>,                                    ie:<span class="hljs-string">'9'</span>,                                    safari:<span class="hljs-string">'10'</span>,                                    edge:<span class="hljs-string">'17'</span>                                &#125;                            &#125;                        ]                    ]                &#125;            &#125;                ]    &#125;,    plugins:[        <span class="hljs-keyword">new</span> HtmlWebpackPlugin(&#123;            template:<span class="hljs-string">'./src/index.html'</span>,            minify:&#123;                collapseWhitespace:<span class="hljs-literal">true</span>,                removeComments:<span class="hljs-literal">true</span>            &#125;        &#125;),        <span class="hljs-keyword">new</span> MiniCssExtractPlugin(&#123;            filename:<span class="hljs-string">'css/built.css'</span>        &#125;),        <span class="hljs-keyword">new</span> OptimizeCssAssetsWebpackPlugin(),        <span class="hljs-comment">// new VueLoaderPlugin(),</span>        <span class="hljs-comment">// new webpack.HotModuleReplacementPlugin()</span>    ],    <span class="hljs-comment">// resolve: &#123;</span>    <span class="hljs-comment">//     alias: &#123; // 修改Vue被导入时包的路径</span>    <span class="hljs-comment">//       "vue$": "vue/dist/vue.js"</span>    <span class="hljs-comment">//     &#125;</span>    <span class="hljs-comment">// &#125;,</span>    devServer: &#123;        open:<span class="hljs-literal">true</span>,        port:<span class="hljs-number">3000</span>,        compress:<span class="hljs-literal">true</span>,        historyApiFallback: <span class="hljs-literal">true</span>,      &#125;&#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Webpack</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Webpack</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue模块化开发——学习笔记三</title>
    <link href="/2020/06/16/Vue%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/"/>
    <url>/2020/06/16/Vue%E6%A8%A1%E5%9D%97%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%89/</url>
    
    <content type="html"><![CDATA[<h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>常见的模块化规范：<br>CommonJS、AMD、CMD，也有ES6的Modules</p><p>前端标准的模块化规范：</p><ul><li>AMD - requirejs</li><li>CMD - seajs</li></ul><p>服务器端的模块化规范：CommonJS - Node.js</p><p>模块：一个js文件就是一个模块，模块内部的成员都是相互独立</p><h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><p>模块化有两个核心：导出和导入<br>CommonJS的导出：</p><p><img src="https://img-blog.csdnimg.cn/2020061615354771.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>CommonJS的导入：</p><p><img src="https://img-blog.csdnimg.cn/20200616153606986.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="ES6模块化"><a href="#ES6模块化" class="headerlink" title="ES6模块化"></a>ES6模块化</h2><h3 id="export基本使用"><a href="#export基本使用" class="headerlink" title="export基本使用"></a>export基本使用</h3><ul><li><p>export指令用于导出变量</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> name = <span class="hljs-string">'es6'</span><span class="hljs-keyword">export</span> <span class="hljs-keyword">let</span> age = <span class="hljs-number">100</span><span class="hljs-comment">//另一种写法</span><span class="hljs-keyword">let</span> name = <span class="hljs-string">'es6'</span><span class="hljs-keyword">let</span> age = <span class="hljs-number">100</span><span class="hljs-keyword">export</span> &#123;name,age&#125;</code></pre></div></li><li><p>导出函数或类</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span>(<span class="hljs-params">content</span>)</span>&#123;    ...&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;    <span class="hljs-keyword">constructor</span>(name,age)&#123;        <span class="hljs-keyword">this</span>.name = name;        <span class="hljs-keyword">this</span>.age = age;    &#125;&#125;<span class="hljs-keyword">export</span>&#123;test,Person&#125;</code></pre></div></li></ul><ul><li><p>export default</p><p>某些情况下，一个模块中包含某个的功能，我们并不希望给这个功能命名，而且让导入者可以自己来命名,这个时候就可以使用export default</p><p>需要注意：export default在同一个模块中，不允许同时存在多个。</p></li></ul><h3 id="import使用"><a href="#import使用" class="headerlink" title="import使用"></a>import使用</h3><p>export指令导出了模块对外提供的接口，我们就可以通过import命令来加载对应的这个模块了</p><p>import指令用于导入模块中的内容，比如main.js的代码</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> &#123;name,age,height&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">"./main.js"</span></code></pre></div><p>如果我们希望某个模块中所有的信息都导入，通过<code>*</code>可以导入模块中所有的export变量,但是通常情况下我们需要给<code>*</code>起一个别名，方便后续的使用</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">import</span> * <span class="hljs-keyword">as</span> info <span class="hljs-keyword">from</span> <span class="hljs-string">"./main.js"</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript高级</title>
    <link href="/2020/06/13/JavaScript%E9%AB%98%E7%BA%A7/"/>
    <url>/2020/06/13/JavaScript%E9%AB%98%E7%BA%A7/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200613120140686.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="1-编程思想"><a href="#1-编程思想" class="headerlink" title="1.编程思想"></a>1.编程思想</h2><h3 id="1-1面向过程编程POP"><a href="#1-1面向过程编程POP" class="headerlink" title="1.1面向过程编程POP"></a>1.1面向过程编程POP</h3><p>面向过程就是分析出解决问题所需要的步骤，然后用函数把这些步骤一步一步实现，使用的时候再一个一个的依次调用就可以了。<br>简单来说：面向过程，就是按照我们分析好了的步骤，<strong>按照步骤解决问题</strong>。</p><h3 id="1-2面向对象编程OOP"><a href="#1-2面向对象编程OOP" class="headerlink" title="1.2面向对象编程OOP"></a>1.2面向对象编程OOP</h3><ul><li>面向对象是把事务分解成为一个个对象，然后由对象之间分工与合作。以<strong>对象功能来划分问题</strong>。</li><li>面向对象的特性： 封装性、 继承性、多态性</li><li>面向对象的思维特点:<ul><li>抽取对象共用的属性和行为组织封装成一个类(模板)</li><li>对类进行实例化, 获取类的对象</li></ul></li></ul><h3 id="1-3面向过程与面向对象对比"><a href="#1-3面向过程与面向对象对比" class="headerlink" title="1.3面向过程与面向对象对比"></a>1.3面向过程与面向对象对比</h3><table><thead><tr><th></th><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>优点</td><td>性能比面向对象高，适合跟硬件联系很紧密的东西，例如单片机就采用的面向过程编程。</td><td>易维护、易复用、易扩展，由于面向对象有封装、继承、多态性的特性，可以设计出低耦合的系统，使系统 更加灵活、更加易于维护</td></tr><tr><td>缺点</td><td>不易维护、不易复用、不易扩展</td><td>性能比面向过程低</td></tr></tbody></table><h2 id="2-类和对象（ES6）"><a href="#2-类和对象（ES6）" class="headerlink" title="2.类和对象（ES6）"></a>2.类和对象（ES6）</h2><h3 id="2-1对象"><a href="#2-1对象" class="headerlink" title="2.1对象"></a>2.1对象</h3><p>对象是由属性和方法组成的：是一个无序键值对的集合,指的是一个具体的事物。例如字符串、数值、数组、函数等。<br>对象是由属性和方法组成的：</p><ul><li>属性：事物的特征，在对象中用属性来表示（常用名词）</li><li>方法：事物的行为，在对象中用方法来表示（常用动词）</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//创建对象</span><span class="hljs-comment">//字面量创建对象</span><span class="hljs-keyword">var</span> ldh = &#123;    name: <span class="hljs-string">'刘德华'</span>,    age: <span class="hljs-number">18</span>&#125;<span class="hljs-comment">//new关键字</span><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Object</span>();<span class="hljs-comment">//构造函数创建对象</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">name, age</span>) </span>&#123;    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age; &#125;<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>)<span class="hljs-comment">//实例化对象</span></code></pre></div><h3 id="2-2类-class"><a href="#2-2类-class" class="headerlink" title="2.2类 class"></a>2.2类 class</h3><ul><li><p>基本介绍</p><ul><li><p>在 ES6 中,可以使用 class 关键字声明一个类，之后以这个类来实例化对象。</p></li><li><p>类与对象的区别：</p><p>类抽象了对象的公共部分，它泛指某一大类（class）<br>对象特指某一个，通过类实例化一个具体的对象</p></li></ul></li><li><p>创建类</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Name</span> </span>&#123;<span class="hljs-comment">// class body</span>&#125;<span class="hljs-keyword">var</span> 对象名 = <span class="hljs-keyword">new</span> Name();注意： 类必须使用 <span class="hljs-keyword">new</span> 实例化对象</code></pre></div></li><li><p>添加属性和方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(name,age) &#123; <span class="hljs-comment">// constructor 构造方法或者构造函数(类的共有属性)</span>    <span class="hljs-keyword">this</span>.name = name;    <span class="hljs-keyword">this</span>.age = age;    &#125; <span class="hljs-comment">//-----&gt;注意,方法与方法之间不需要添加逗号,同时方法不需要添加 function 关键字。</span>    sing(song) &#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>.name + <span class="hljs-string">'唱'</span> + song);    &#125;&#125;<span class="hljs-keyword">var</span> ldh = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>);<span class="hljs-built_in">console</span>.log(ldh); <span class="hljs-comment">// Star &#123;name: "刘德华", age: 18&#125;</span>ldh.sing(<span class="hljs-string">'冰雨'</span>); <span class="hljs-comment">// 刘德华唱冰雨</span></code></pre></div><p><strong>注意:</strong></p><ol><li>通过class 关键字创建类, 类名我们还是习惯性定义首字母大写</li><li>类里面有个constructor 函数,可以接受传递过来的参数,同时返回实例对象</li><li>constructor 函数 只要 new 生成实例时,就会自动调用这个函数, 如果我们不写这个函数,类也会自动生成这个函数</li><li>多个函数方法之间不需要添加逗号分隔</li><li>生成实例 new 不能省略</li><li>语法规范:创建类 类名后面不要加小括号,生成实例 类名后面加小括号, 构造函数不需要加function</li></ol></li></ul><h3 id="2-3类的继承"><a href="#2-3类的继承" class="headerlink" title="2.3类的继承"></a>2.3类的继承</h3><ul><li><p>子类可以继承父类的一些属性和方法。<br>语法：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span></span>&#123; <span class="hljs-comment">// 父类</span>&#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123; <span class="hljs-comment">// 子类继承父类</span>&#125;</code></pre></div></li></ul><ul><li><p>子类使用super关键字访问父类的方法</p><p>super关键字 用于访问和调用对象父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Father</span> </span>&#123;    <span class="hljs-keyword">constructor</span>(surname) &#123;    <span class="hljs-keyword">this</span>.surname = surname;    &#125;    saySurname() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我的姓是'</span> + <span class="hljs-keyword">this</span>.surname);    &#125; &#125;<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Son</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Father</span> </span>&#123; <span class="hljs-comment">// 这样子类就继承了父类的属性和方法</span>    <span class="hljs-keyword">constructor</span>(surname, fristname) &#123;    <span class="hljs-keyword">super</span>(surname); <span class="hljs-comment">// 调用父类的constructor(surname)</span>    <span class="hljs-keyword">this</span>.fristname = fristname;    &#125;    sayFristname() &#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">"我的名字是："</span> + <span class="hljs-keyword">this</span>.fristname);    &#125; &#125;<span class="hljs-keyword">var</span> damao = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘'</span>, <span class="hljs-string">"德华"</span>);damao.saySurname();damao.sayFristname();</code></pre></div><p>注意: 子类在构造函数中使用super, 必须放到 this 前面 (必须先调用父类的构造方法,再使用子类构造方法)</p></li></ul><p><strong>重点：</strong></p><ul><li><p>this的指向问题,类里面的共有的属性和方法一定要加this使用.</p><ul><li>constructor中的this指向的是new出来的实例对象</li><li>自定义的方法,一般也指向的new出来的实例对象</li><li>绑定事件之后this指向的就是触发事件的事件源</li></ul></li><li><p>在 ES6 中类没有变量提升，所以必须先定义类，才能通过类实例化对象</p></li></ul><h2 id="3-构造函数和原型"><a href="#3-构造函数和原型" class="headerlink" title="3.构造函数和原型"></a>3.构造函数和原型</h2><h3 id="3-1构造函数"><a href="#3-1构造函数" class="headerlink" title="3.1构造函数"></a>3.1构造函数</h3><ul><li><p>基本介绍</p><ul><li><p>构造函数是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 一起使用。我们可以把对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面。</p></li><li><p>在 JS 中，使用构造函数时要注意以下两点：</p><p>1.构造函数用于创建某一类对象，其首字母要大写</p><p>2.构造函数要和 new 一起使用才有意义</p><p><strong>new 在执行时会做四件事情</strong>：</p><p>① 在内存中创建一个新的空对象。</p><p>② 让 this 指向这个新的对象。</p><p>③ 执行构造函数里面的代码，给这个新对象添加属性和方法。</p><p>④ 返回这个新对象（所以构造函数里面不需要 return ）。</p></li></ul></li><li><p>静态成员和实例成员</p><ul><li>静态成员：在构造函数本身上添加的成员称为静态成员，只能由构造函数本身来访问</li><li>实例成员：在构造函数内部通过this添加的对象成员称为实例成员，只能由实例化的对象来访问</li></ul></li><li><p>构造函数的问题</p><ul><li>存在浪费内存的问题</li></ul></li></ul><h3 id="3-2构造函数原型对象（-prototype）"><a href="#3-2构造函数原型对象（-prototype）" class="headerlink" title="3.2构造函数原型对象（ prototype）"></a>3.2构造函数原型对象（ prototype）</h3><p>JavaScript 规定，每一个构造函数都有一个 prototype 属性，指向另一个对象。注意这个 prototype 就是一个对象，这个对象的所有属性和方法，都会被构造函数所拥有。<br>我们可以把那些不变的方法，直接定义在 prototype 对象上，这样所有对象的实例就可以共享这些方法。</p><p><strong>原型对象this指向</strong></p><p>构造函数中的this 指向我们实例对象.</p><p>原型对象里面放的是方法, 这个方法里面的this 指向的是 这个方法的调用者, 也就是这个实例对象.</p><h3 id="3-3对象原型-（proto-）"><a href="#3-3对象原型-（proto-）" class="headerlink" title="3.3对象原型 （proto ）"></a>3.3对象原型 （<strong><strong>proto</strong></strong> ）</h3><p>对象都会有一个属性 <strong><strong>proto</strong></strong> 指向构造函数的原型对象（prototype） ，之所以我们对象可以使用构造函数原型对象（prototype）的属性和方法，就是因为对象有原型（<strong><strong>proto</strong></strong> ）的存在。<br>对象原型 （<strong><strong>proto</strong></strong> ）和原型对象 prototype 是等价的<br>对象原型 （<strong><strong>proto</strong></strong> ）的意义就在于为对象的查找机制提供一个方向，或者说一条路线，但是它是一个非标准属性，因此实际开发中，不可以使用这个属性，它只是内部指向原型对象 prototype</p><h3 id="3-4-constructor构造函数"><a href="#3-4-constructor构造函数" class="headerlink" title="3.4 constructor构造函数"></a>3.4 constructor构造函数</h3><p>对象原型（ <strong>proto</strong>）和构造函数（prototype）原型对象里面都有一个属性 constructor 属性 ，constructor 我们称为构造函数，因为它指回构造函数本身。<br>constructor 主要用于记录该对象引用于哪个构造函数，它可以让原型对象重新指向原来的构造函数。<br>一般情况下，对象的方法都在构造函数的原型对象中设置。如果有多个对象的方法，我们可以给原型对象采取对象形式赋值，但是这样就会覆盖构造函数原型对象原来的内容，这样修改后的原型对象 constructor 就不再指向当前构造函数了。此时，我们可以在修改后的原型对象中，添加一个 constructor 指向原来的构造函数。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params">uname, age</span>) </span>&#123;     <span class="hljs-keyword">this</span>.uname = uname;     <span class="hljs-keyword">this</span>.age = age; &#125; <span class="hljs-comment">// 很多情况下,我们需要手动的利用constructor 这个属性指回 原来的构造函数</span> Star.prototype = &#123; <span class="hljs-comment">// 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数</span>   <span class="hljs-keyword">constructor</span>: Star, // 手动设置指回原来的构造函数   sing: function() &#123;     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会唱歌'</span>);   &#125;,   movie: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我会演电影'</span>);   &#125;&#125;<span class="hljs-keyword">var</span> zxy = <span class="hljs-keyword">new</span> Star(<span class="hljs-string">'张学友'</span>, <span class="hljs-number">19</span>);<span class="hljs-built_in">console</span>.log(zxy)</code></pre></div><h3 id="3-5原型链"><a href="#3-5原型链" class="headerlink" title="3.5原型链"></a>3.5原型链</h3><p>每一个实例对象都有一个<strong><strong>proto</strong></strong>属性，指向的构造函数的原型对象，构造函数的原型对象也是一个对象，也有<strong><strong>proto</strong></strong>属性，这样一层一层往上找就形成了原型链。</p><div class="hljs"><pre><code class="hljs text">当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。如果没有就查找它的原型（也就是 __proto__指向的 prototype 原型对象）。如果还没有就查找原型对象的原型（Object的原型对象）。依此类推一直找到 Object 为止（null）。__proto__对象原型的意义就在于为对象成员查找机制提供一个方向，或者说一条路线。</code></pre></div><p><img src="https://img-blog.csdnimg.cn/20200613090128300.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>构造函数实例和原型对象三角关系：</p><p>1.构造函数的prototype属性指向了构造函数原型对象<br>2.实例对象是由构造函数创建的,实例对象的<strong>proto</strong>属性指向了构造函数的原型对象<br>3.构造函数的原型对象的constructor属性指向了构造函数,实例对象的原型的constructor属性也指向了构造函数</p><p><img src="https://img-blog.csdnimg.cn/20200613090128279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-6扩展内置对象"><a href="#3-6扩展内置对象" class="headerlink" title="3.6扩展内置对象"></a><strong>3.6扩展内置对象</strong></h3><p>可以通过原型对象，对原来的内置对象进行扩展自定义的方法。比如给数组增加自定义求偶数和的功能。</p><p>注意：数组和字符串内置对象不能给原型对象覆盖操作 Array.prototype = {} ，只能是 Array.prototype.xxx = function(){} 的方式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Array</span>.prototype.sum = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-keyword">var</span> sum = <span class="hljs-number">0</span>;  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) &#123;  sum += <span class="hljs-keyword">this</span>[i];  &#125;  <span class="hljs-keyword">return</span> sum;&#125;;<span class="hljs-comment">//此时数组对象中已经存在sum()方法了  可以始终使用 数组.sum()进行数据的求和</span></code></pre></div><h2 id="4-继承"><a href="#4-继承" class="headerlink" title="4.继承"></a>4.继承</h2><h3 id="4-1call"><a href="#4-1call" class="headerlink" title="4.1call()"></a>4.1call()</h3><ul><li><p>call()可以调用函数</p></li><li><p>call()可以修改this的指向</p><div class="hljs"><pre><code class="hljs js">fun.call(thisArg, arg1, arg2, ...)thisArg ：当前调用函数 <span class="hljs-keyword">this</span> 的指向对象arg1，arg2：传递的其他参数</code></pre></div></li></ul><h3 id="4-2子构造函数继承父构造函数中的属性"><a href="#4-2子构造函数继承父构造函数中的属性" class="headerlink" title="4.2子构造函数继承父构造函数中的属性"></a>4.2子构造函数继承父构造函数中的属性</h3><p>核心原理： 通过 call() 把父类型的 this 指向子类型的 this ，这样就可以实现子类型继承父类型的属性。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 父构造函数</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;   <span class="hljs-comment">// this 指向父构造函数的对象实例</span>   <span class="hljs-keyword">this</span>.uname = uname;   <span class="hljs-keyword">this</span>.age = age; &#125;  <span class="hljs-comment">// 2 .子构造函数 </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;  <span class="hljs-comment">// this 指向子构造函数的对象实例</span>  <span class="hljs-number">3.</span>使用call方式实现子继承父的属性  Father.call(<span class="hljs-keyword">this</span>, uname, age);  <span class="hljs-keyword">this</span>.score = score;&#125;<span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);<span class="hljs-built_in">console</span>.log(son);</code></pre></div><h3 id="4-3借用原型对象继承父类型方法"><a href="#4-3借用原型对象继承父类型方法" class="headerlink" title="4.3借用原型对象继承父类型方法"></a>4.3借用原型对象继承父类型方法</h3><p>一般情况下，对象的方法都在构造函数的原型对象中设置，通过构造函数无法继承父类方法。<br>核心原理：<br>① 将子类所共享的方法提取出来，让子类的 prototype 原型对象 = new 父类()<br>② 本质：子类原型对象等于是实例化父类，因为父类实例化之后另外开辟空间，就不会影响原来父类原型对象<br>③ 将子类的 constructor 从新指向子类的构造函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 父构造函数</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Father</span>(<span class="hljs-params">uname, age</span>) </span>&#123;  <span class="hljs-comment">// this 指向父构造函数的对象实例</span>  <span class="hljs-keyword">this</span>.uname = uname;  <span class="hljs-keyword">this</span>.age = age;&#125;Father.prototype.money = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-number">100000</span>); &#125;; <span class="hljs-comment">// 2 .子构造函数 </span>  <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Son</span>(<span class="hljs-params">uname, age, score</span>) </span>&#123;      <span class="hljs-comment">// this 指向子构造函数的对象实例</span>      Father.call(<span class="hljs-keyword">this</span>, uname, age);      <span class="hljs-keyword">this</span>.score = score;  &#125;<span class="hljs-comment">// Son.prototype = Father.prototype;  这样直接赋值会有问题,如果修改了子原型对象,父原型对象也会跟着一起变化</span>  Son.prototype = <span class="hljs-keyword">new</span> Father();  <span class="hljs-comment">// 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数</span>  Son.prototype.constructor = Son;  <span class="hljs-comment">// 这个是子构造函数专门的方法</span>  Son.prototype.exam = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'孩子要考试'</span>);  &#125;  <span class="hljs-keyword">var</span> son = <span class="hljs-keyword">new</span> Son(<span class="hljs-string">'刘德华'</span>, <span class="hljs-number">18</span>, <span class="hljs-number">100</span>);  <span class="hljs-built_in">console</span>.log(son);</code></pre></div><h2 id="5-方法-ES5"><a href="#5-方法-ES5" class="headerlink" title="5. 方法(ES5)"></a>5. 方法(ES5)</h2><h3 id="5-1数组方法"><a href="#5-1数组方法" class="headerlink" title="5.1数组方法"></a>5.1数组方法</h3><ul><li><p><strong>forEach()遍历数组</strong></p><p>array.forEach(function(currentValue, index, arr))</p><ul><li>currentValue：数组当前项的值</li><li>index：数组当前项的索引</li><li>arr：数组对象本身</li></ul><p>相当于数组遍历的 for循环 <strong>没有返回值</strong></p></li><li><p>map()</p><p><code>map</code> 方法会给原数组中的每个元素都按顺序调用一次 <code>callback</code> 函数。<code>callback</code> 每次执行后的返回值（包括 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/undefined" target="_blank" rel="noopener"><code>undefined</code></a>）组合起来形成一个新数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> new_array = arr.map(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">callback</span>(<span class="hljs-params">currentValue[, index[, array]]</span>) </span>&#123; <span class="hljs-comment">// Return element for new_array </span>&#125;[, thisArg])<span class="hljs-comment">//callback 函数会被自动传入三个参数：数组元素，元素索引，原数组本身。</span><span class="hljs-comment">//thisArg可选  执行 callback 函数时值被用作this。</span></code></pre></div><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">9</span>];<span class="hljs-keyword">var</span> roots = numbers.map(<span class="hljs-built_in">Math</span>.sqrt);<span class="hljs-comment">// roots的值为[1, 2, 3], numbers的值仍为[1, 4, 9]</span></code></pre></div></li><li><p><strong>filter()过滤数组</strong></p><p>array.filter(function(currentValue, index, arr))</p><p>filter() 方法创建一个新的数组，新数组中的元素是通过检查指定数组中<strong>符合条件的所有元素</strong>,主要用于筛选数组</p><p>注意:它直接<strong>返回一个新数组</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">12</span>, <span class="hljs-number">66</span>, <span class="hljs-number">4</span>, <span class="hljs-number">88</span>, <span class="hljs-number">3</span>, <span class="hljs-number">7</span>];  <span class="hljs-keyword">var</span> newArr = arr.filter(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value, index,array</span>) </span>&#123;   <span class="hljs-comment">//参数一是:数组元素</span>     <span class="hljs-comment">//参数二是:数组元素的索引</span>     <span class="hljs-comment">//参数三是:当前的数组</span>     <span class="hljs-keyword">return</span> value &gt;= <span class="hljs-number">20</span>;  &#125;);  <span class="hljs-built_in">console</span>.log(newArr);<span class="hljs-comment">//[66,88] //返回值是一个新数组</span></code></pre></div></li><li><p><strong>some()</strong></p><p>array.some(function(currentValue, index, arr))</p><ul><li>some() 方法用于检测<strong>数组中的元素是否满足指定条件</strong>.</li><li>注意它<strong>返回值是布尔值</strong>, 如果查找到这个元素, 就返回true , 如果查找不到就返回false.</li><li>如果找到第一个满足条件的元素,则终止循环. 不在继续查找.</li></ul><div class="hljs"><pre><code class="hljs js">some 查找数组中是否有满足条件的元素  <span class="hljs-keyword">var</span> arr = [<span class="hljs-number">10</span>, <span class="hljs-number">30</span>, <span class="hljs-number">4</span>]; <span class="hljs-keyword">var</span> flag = arr.some(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value,index,array</span>) </span>&#123;     <span class="hljs-keyword">return</span> value &lt; <span class="hljs-number">3</span>;  &#125;);<span class="hljs-built_in">console</span>.log(flag);<span class="hljs-comment">//false返回值是布尔值,只要查找到满足条件的一个元素就立马终止循环</span></code></pre></div><p><strong>some和forEach区别</strong></p><ul><li><p>如果查询数组中唯一的元素, 用some方法更合适,在some 里面 遇到 return true 就是终止遍历 迭代效率更高</p></li><li><p>在forEach 里面 return 不会终止迭代</p></li></ul></li></ul><h3 id="5-2字符串方法"><a href="#5-2字符串方法" class="headerlink" title="5.2字符串方法"></a>5.2字符串方法</h3><p>trim() 方法会从一个字符串的两端删除空白字符。<br><code>str.trim()</code><br>trim() 方法并不影响原字符串本身，它返回的是一个新的字符串。</p><h3 id="5-3对象方法"><a href="#5-3对象方法" class="headerlink" title="5.3对象方法"></a>5.3对象方法</h3><ul><li><p>Object.keys() 方法</p><p>获取到当前对象中的属性名 ,返回一个所有元素为字符串的数组。<br>Object.keys(obj)<br>效果类似 for…in</p><div class="hljs"><pre><code class="hljs js"> <span class="hljs-keyword">var</span> obj = &#123;     id: <span class="hljs-number">1</span>,     pname: <span class="hljs-string">'小米'</span>,     price: <span class="hljs-number">1999</span>,     num: <span class="hljs-number">2000</span>&#125;;<span class="hljs-keyword">var</span> result = <span class="hljs-built_in">Object</span>.keys(obj)<span class="hljs-built_in">console</span>.log(result)<span class="hljs-comment">//[id，pname,price,num]</span></code></pre></div></li><li><p>Object.defineProperty()</p><p>定义新属性或修改原有的属性。<br>Object.defineProperty(obj, prop, descriptor)</p><ul><li><p>obj：必需。目标对象</p></li><li><p>prop：必需。需定义或修改的属性的名字</p></li><li><p>descriptor：必需。目标属性所拥有的特性</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">Object</span>.defineProperty(对象，修改或新增的属性名，&#123;value:修改或新增的属性的值,writable:<span class="hljs-literal">true</span>/<span class="hljs-literal">false</span>,<span class="hljs-comment">//如果值为false 不允许修改这个属性值</span>enumerable: <span class="hljs-literal">false</span>,<span class="hljs-comment">//enumerable 如果值为false 则不允许遍历</span>        configurable: <span class="hljs-literal">false</span>  <span class="hljs-comment">//configurable 如果为false 则不允许删除这个属性 属性是否可以被删除或是否可以再次修改特性</span>&#125;)</code></pre></div></li></ul></li></ul><h2 id="6-函数进阶"><a href="#6-函数进阶" class="headerlink" title="6.函数进阶"></a>6.函数进阶</h2><h3 id="6-1函数的定义和调用"><a href="#6-1函数的定义和调用" class="headerlink" title="6.1函数的定义和调用"></a>6.1函数的定义和调用</h3><ul><li>函数的定义方式</li></ul><ol><li>函数声明方式 function 关键字 (命名函数)</li><li>函数表达式 (匿名函数)</li><li>new Function()<br>var fn = new Function(‘参数1’,’参数2’…, ‘函数体’)<ul><li>Function 里面参数都必须是字符串格式</li><li>第三种方式执行效率低，也不方便书写，因此较少使用</li><li>所有函数都是 Function 的实例(对象)</li><li>函数也属于对象</li></ul></li></ol><ul><li>函数的调用方式</li></ul><ol><li><p>普通函数</p></li><li><p>对象的方法</p></li><li><p>构造函数</p></li><li><p>绑定事件函数</p></li><li><p>定时器函数</p></li><li><p>立即执行函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">/* 1. 普通函数 */</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);&#125; fn(); <span class="hljs-comment">/* 2. 对象的方法 */</span><span class="hljs-keyword">var</span> o = &#123;  sayHi: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;  <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);  &#125;&#125;o.sayHi();<span class="hljs-comment">/* 3. 构造函数*/</span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">Star</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;<span class="hljs-keyword">new</span> Star();<span class="hljs-comment">/* 4. 绑定事件函数*/</span> btn.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;;   <span class="hljs-comment">// 点击了按钮就可以调用这个函数</span><span class="hljs-comment">/* 5. 定时器函数*/</span>setInterval(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;&#125;, <span class="hljs-number">1000</span>);  这个函数是定时器自动<span class="hljs-number">1</span>秒钟调用一次<span class="hljs-comment">/* 6. 立即执行函数(自调用函数)*/</span>(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-string">'人生的巅峰'</span>);&#125;)();</code></pre></div></li></ol><h3 id="6-2-函数内部的this的指向"><a href="#6-2-函数内部的this的指向" class="headerlink" title="6.2 函数内部的this的指向"></a>6.2 函数内部的this的指向</h3><p>this 的指向，是当我们调用函数的时候确定的。调用方式的不同决定了this 的指向不同,一般指向我们的调用者.</p><p><img src="https://img-blog.csdnimg.cn/20200613101447726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>改变函数内部 this 指向的三种方法</p><ul><li><p><strong>call 方法</strong><br>call() 方法调用一个对象。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。<br><code>fun.call(thisArg, arg1, arg2, ...)</code></p><ul><li>thisArg：在 fun 函数运行时指定的 this 值</li><li>arg1，arg2：传递的其他参数</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>因此当我们想改变 this 指向，同时想调用这个函数的时候，可以使用 call</li><li>应用场景: 经常做继承.</li></ul></li><li><p><strong>apply 方法</strong><br>apply() 方法调用一个函数。简单理解为调用函数的方式，但是它可以改变函数的 this 指向。<br><code>fun.apply(thisArg, [argsArray])</code></p><ul><li>thisArg：在fun函数运行时指定的 this 值</li><li>argsArray：传递的值，必须包含在数组里面</li><li>返回值就是函数的返回值，因为它就是调用函数</li><li>apply 主要跟数组有关系，比如使用 Math.max() 求数组的最大值</li></ul></li><li><p><strong>bind 方法</strong><br>bind() 方法不会调用函数，但是能改变函数内部this 指向。返回的是原函数改变this之后产生的新函数<br><code>fun.bind(thisArg, arg1, arg2, ...)</code></p><ul><li><p>thisArg：在 fun 函数运行时指定的 this 值</p></li><li><p>arg1，arg2：传递的其他参数</p></li><li><p>返回由指定的 this 值和初始化参数改造的原函数拷贝</p></li><li><p>因此当我们只是想改变 this 指向，并且不想调用这个函数的时候，可以使用 bind</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> o = &#123; name: <span class="hljs-string">'andy'</span> &#125;;<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">a, b</span>) </span>&#123;<span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-built_in">console</span>.log(a + b);&#125;;<span class="hljs-keyword">var</span> f = fn.bind(o, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>); <span class="hljs-comment">//此处的f是bind返回的新函数</span>f();<span class="hljs-comment">//调用新函数  this指向的是对象o 参数使用逗号隔开</span></code></pre></div></li></ul></li></ul><p><strong>call、apply、bind三者的异同</strong></p><ul><li>共同点 : 都可以改变this指向</li><li>不同点:<ul><li>call 和 apply 会调用函数, 并且改变函数内部this指向.</li><li>call 和 apply传递的参数不一样,call传递参数使用逗号隔开,apply使用数组传递</li><li>bind 不会调用函数, 可以改变函数内部this指向.</li></ul></li></ul><ul><li>应用场景<ol><li>call 经常做继承.</li><li>apply经常跟数组有关系. 比如借助于数学对象实现数组最大值最小值</li><li>bind 不调用函数,但是还想改变this指向. 比如改变定时器内部的this指向.</li></ol></li></ul><h2 id="7-严格模式"><a href="#7-严格模式" class="headerlink" title="7.严格模式"></a>7.严格模式</h2><p>JavaScript 除了提供正常模式外，还提供了严格模式（strict mode）。严格模式在 IE10 以上版本的浏览器中才会被支持，旧版本浏览器中会被忽略。</p><p>严格模式对正常的 JavaScript 语义做了一些更改：</p><p>1.消除了 Javascript 语法的一些不合理、不严谨之处，减少了一些怪异行为。</p><p>2.消除代码运行的一些不安全之处，保证代码运行的安全。</p><p>3.提高编译器效率，增加运行速度。</p><p>4.禁用了在 ECMAScript 的未来版本中可能会定义的一些语法，为未来新版本的 Javascript 做好铺垫。比如一些保留字如：class,enum,export, extends, import, super 不能做变量名</p><ul><li><p>开启严格模式</p><ul><li><p>为脚本开启严格模式</p><p>有的 script 脚本是严格模式，有的 script 脚本是正常模式，这样不利于文件合并，所以可以将整个脚本文件放在一个立即执行的匿名函数之中。这样独立创建一个作用域而不影响其他<br>script 脚本文件。为整个脚本文件开启严格模式，需要在所有语句之前放一个特定语句“use strict”;（或‘use strict’;）。</p></li><li><p>为函数开启严格模式<br>要给某个函数开启严格模式，需要把“use strict”; (或 ‘use strict’; ) 声明放在函数体所有语句之前。</p></li></ul></li><li><p>严格模式中的变化</p><ul><li><p>变量规定<br>① 在正常模式中，如果一个变量没有声明就赋值，默认是全局变量。严格模式禁止这种用法，变量都必须先用var 命令声明，然后再使用。<br>② 严禁删除已经声明变量。</p></li><li><p>this 指向问题<br>① 以前在全局作用域函数中的 this 指向 window 对象。严格模式下全局作用域中函数中的 this 是 undefined。</p><p>②以前构造函数时不加new也可以调用,当普通函数，this指向全局对象。严格模式下,如果构造函数不加new调用, this 指向的是undefined 如果给他赋值则会报错</p><p>③ new 实例化的构造函数指向创建的对象实例。<br>④ 定时器 this 还是指向 window 。</p><p>⑤ 事件、对象还是指向调用者。</p></li><li><p>函数变化<br>① 函数不能有重名的参数。</p><p>② 函数必须声明在顶层.新版本的 JavaScript 会引入“块级作用域”（ ES6 中已引入）。为了与新版本接轨，不允许在非函数的代码块内声明函数。</p></li></ul></li></ul><h2 id="8-高阶函数"><a href="#8-高阶函数" class="headerlink" title="8.高阶函数"></a>8.高阶函数</h2><p>高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出。</p><h2 id="9-闭包"><a href="#9-闭包" class="headerlink" title="9.闭包"></a>9.闭包</h2><p>闭包（closure）是一个函数 （一个作用域可以访问另外一个函数内部的局部变量。 ）</p><p>作用：延伸变量的作用范围</p><div class="hljs"><pre><code class="hljs js"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;   <span class="hljs-keyword">var</span> num = <span class="hljs-number">10</span>;   <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fun</span>(<span class="hljs-params"></span>) </span>&#123;       <span class="hljs-built_in">console</span>.log(num); &#125;    <span class="hljs-keyword">return</span> fun; &#125;<span class="hljs-keyword">var</span> f = fn();f();</code></pre></div><h2 id="10-递归"><a href="#10-递归" class="headerlink" title="10.递归"></a>10.递归</h2><p>一个函数在内部可以调用其本身，那么这个函数就是递归函数。简单理解:函数内部自己调用自己<br><strong>注意：</strong>递归函数的作用和循环效果一样,由于递归很容易发生“栈溢出”错误（stack overflow），所以必须要加退出条件 return。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//利用递归函数求1~n的阶乘 1 * 2 * 3 * 4 * ..n</span> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params">n</span>) </span>&#123;     <span class="hljs-keyword">if</span> (n == <span class="hljs-number">1</span>) &#123; <span class="hljs-comment">//结束条件</span>       <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;     &#125;     <span class="hljs-keyword">return</span> n * fn(n - <span class="hljs-number">1</span>); &#125; <span class="hljs-built_in">console</span>.log(fn(<span class="hljs-number">3</span>));</code></pre></div><h2 id="11-正则表达式"><a href="#11-正则表达式" class="headerlink" title="11.正则表达式"></a>11.正则表达式</h2><h3 id="11-1概述"><a href="#11-1概述" class="headerlink" title="11.1概述"></a>11.1概述</h3><p>正则表通常被用来检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名表单只能输入英文字母、数字或者下划线， 昵称输入框中可以输入中文(<strong>匹配</strong>)。此外，正则表达式还常用于过滤掉页面内容中的一 些敏感词(<strong>替换</strong>)，或从字符串中获取我们想要的特定部分(<strong>提取</strong>)等 。</p><p>正则表达式（ Regular Expression ）是用于匹配字符串中字符组合的模式。在 JavaScript中，正则表达式也是对象。</p><h3 id="11-2基本使用"><a href="#11-2基本使用" class="headerlink" title="11.2基本使用"></a>11.2基本使用</h3><ul><li><p>创建正则表达式</p><p>在 JavaScript 中，可以通过两种方式创建一个正则表达式。</p><p>方式一：通过调用RegExp对象的构造函数创建</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> regexp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-regexp">/123/</span>);<span class="hljs-built_in">console</span>.log(regexp);</code></pre></div><p>方式二：利用字面量创建 正则表达式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> rg = <span class="hljs-regexp">/123/</span>;</code></pre></div></li><li><p>测试正则表达式 test</p><p>test() 正则对象方法，用于检测字符串是否符合该规则，该对象会返回 true 或 false，其参数是测试字符串。<br><code>regexObj.test(str)</code></p><ul><li>regexObj 是写的正则表达式</li><li>str 我们要测试的文本</li></ul></li></ul><h3 id="11-3特殊字符"><a href="#11-3特殊字符" class="headerlink" title="11.3特殊字符"></a>11.3特殊字符</h3><p>一个正则表达式可以由简单的字符构成，比如 /abc/，也可以是简单和特殊字符的组合，比如 /ab*c/ ,其中特殊字符也被称为元字符，在正则表达式中是具有特殊意义的专用符号，如 ^ 、$ 、+ 等。</p><p>特殊字符非常多，可以参考： <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions" target="_blank" rel="noopener">MDN</a></p><p>jQuery 手册：正则表达式部分 <a href="<http://tool.oschina.net/regex">正则测试工具</a></p><ul><li><p>边界符</p><p>正则表达式中的边界符（位置符）用来提示字符所处的位置，主要有两个字符</p><table><thead><tr><th>边界符</th><th>说明</th></tr></thead><tbody><tr><td>^</td><td>表示匹配行首的文本（以谁开始）</td></tr><tr><td>$</td><td>表示匹配行尾的文本（以谁结束）</td></tr></tbody></table><p>如果 ^和 $ 在一起，表示必须是精确匹配。</p></li><li><p>字符类</p><p>表示有一系列字符可供选择，只要匹配其中一个就可以了。所有可供选择的字符都放在方括号内。</p><ul><li><p>[] 方括号<br><code>/[abc]/.test(&#39;andy&#39;)</code><br>后面的字符串只要包含 abc 中任意一个字符，都返回 true 。</p></li><li><p>[-] 方括号内部范围符-</p><p><code>/^[a-z]$/.test(c&#39;)</code><br>方括号内部加上 - 表示范围，这里表示 a 到 z 26个英文字母都可以。</p></li><li><p>[^] 方括号内部 取反符^<br><code>/[^abc]/.test(&#39;andy&#39;)</code><br>方括号内部加上 ^ 表示取反，只要包含方括号内的字符，都返回 false 。</p></li><li><p>字符组合<br><code>/[a-z1-9]/.test(&#39;andy&#39;)</code><br>方括号内部可以使用字符组合，这里表示包含 a 到 z 的26个英文字母和 1 到 9 的数字都可以。</p></li></ul></li><li><p>量词符</p><p>量词符用来设定某个模式出现的次数。</p><table><thead><tr><th>量词</th><th>说明</th></tr></thead><tbody><tr><td>*</td><td>重复0次或更多次</td></tr><tr><td>+</td><td>重复1次或更多次</td></tr><tr><td>?</td><td>重复0次或1次</td></tr><tr><td>{n}</td><td>重复n次</td></tr><tr><td>{n,}</td><td>重复n次或更多次</td></tr><tr><td>{n,m}</td><td>重复n到m次</td></tr></tbody></table></li><li><p>括号总结</p><ul><li>大括号量词符. 里面表示重复次数</li><li>中括号字符集合。匹配方括号中的任意字符.</li><li>小括号 表示优先级</li></ul></li><li><p>预定义类</p><p>预定义类指的是某些常见模式的简写方式。</p><p><img src="https://img-blog.csdnimg.cn/20200613110614915.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="11-4正则替换replace"><a href="#11-4正则替换replace" class="headerlink" title="11.4正则替换replace"></a>11.4正则替换replace</h3><ul><li><p>replace 替换</p><p>replace() 方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式。<br><code>stringObject.replace(regexp/substr,replacement)</code></p><ul><li><p>第一个参数: 被替换的字符串 或者 正则表达式</p></li><li><p>第二个参数: 替换为的字符串</p><p>返回值是一个替换完毕的新字符串</p></li></ul></li><li><p>正则表达式参数</p><p><code>/表达式/[switch]</code><br>switch(也称为修饰符) 按照什么样的模式来匹配. 有三种值：</p><ul><li>g：全局匹配</li><li>i：忽略大小写</li><li>gi：全局匹配 + 忽略大小写</li></ul></li></ul><h2 id="12-ES6"><a href="#12-ES6" class="headerlink" title="12.ES6"></a>12.ES6</h2><h3 id="12-1新增语法"><a href="#12-1新增语法" class="headerlink" title="12.1新增语法"></a>12.1新增语法</h3><ul><li><p><strong>let</strong></p><p>ES6中新增的用于声明变量的关键字。</p><ul><li><p><strong>let声明的变量只在所处于的块级有效</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">let</span> a = <span class="hljs-number">10</span>; &#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span>注意：使用<span class="hljs-keyword">let</span>关键字声明的变量才具有块级作用域，使用<span class="hljs-keyword">var</span>声明的变量不具备块级作用域特性。</code></pre></div></li><li><p><strong>不存在变量提升</strong></p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(a); <span class="hljs-comment">// a is not defined </span><span class="hljs-keyword">let</span> a = <span class="hljs-number">20</span>;</code></pre></div></li><li><p><strong>暂时性死区</strong></p><p>利用let声明的变量会绑定在这个块级作用域，不会受外界的影响</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> tmp = <span class="hljs-number">123</span>;<span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;     tmp = <span class="hljs-string">'abc'</span>;    <span class="hljs-keyword">let</span> tmp; &#125;</code></pre></div></li></ul><p>经典面试题</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(i);     &#125;&#125;arr[<span class="hljs-number">0</span>]();<span class="hljs-comment">//2</span>arr[<span class="hljs-number">1</span>]();<span class="hljs-comment">//2</span></code></pre></div><p>此题的关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++) &#123;    arr[i] = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(i);     &#125;&#125;arr[<span class="hljs-number">0</span>]();<span class="hljs-comment">//0</span>arr[<span class="hljs-number">1</span>]();<span class="hljs-comment">//1</span></code></pre></div><p>此题的关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上一级（循环产生的块级作用域）作用域下的i值.</p><p><strong>小结</strong></p><ul><li>let关键字就是用来声明变量的</li><li>使用let关键字声明的变量具有块级作用域</li><li>防止循环变量变成全局变量</li><li>使用let关键字声明的变量没有变量提升</li><li>使用let关键字声明的变量具有暂时性死区特性</li></ul></li><li><p><strong>const</strong></p><p>作用：声明常量，常量就是值（内存地址）不能变化的量</p><ul><li><p>具有块级作用域</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">if</span> (<span class="hljs-literal">true</span>) &#123;<span class="hljs-keyword">const</span> a = <span class="hljs-number">10</span>; &#125;<span class="hljs-built_in">console</span>.log(a) <span class="hljs-comment">// a is not defined</span></code></pre></div></li><li><p>声明常量时必须赋值</p></li><li><p>常量赋值后，值不能修改。</p></li></ul><p><strong>小结</strong></p><ul><li>const声明的变量是一个常量</li><li>既然是常量不能重新进行赋值，如果是基本数据类型，不能更改值，如果是复杂数据类型，不能更改地址值</li><li>声明 const时候必须要给定值</li></ul></li><li><p><strong>let、const、var 的区别</strong></p><ul><li>使用 var 声明的变量，其作用域为该语句所在的函数内，且存在变量提升现象</li><li>使用 let 声明的变量，其作用域为该语句所在的代码块内，不存在变量提升</li><li>使用 const 声明的是常量，在后面出现的代码中不能再修改该常量的值</li></ul></li></ul><h3 id="12-2解构赋值"><a href="#12-2解构赋值" class="headerlink" title="12.2解构赋值"></a>12.2解构赋值</h3><p>按照一定模式，从数组中或对象中提取值，将提取出来的值赋值给另外的变量。</p><h4 id="数组解构"><a href="#数组解构" class="headerlink" title="数组解构"></a>数组解构</h4><div class="hljs"><pre><code class="hljs javascript"> <span class="hljs-keyword">let</span> [a, b, c] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-built_in">console</span>.log(a)<span class="hljs-comment">//1</span> <span class="hljs-built_in">console</span>.log(b)<span class="hljs-comment">//2</span> <span class="hljs-built_in">console</span>.log(c)<span class="hljs-comment">//3</span><span class="hljs-comment">//如果解构不成功，变量的值为undefined</span></code></pre></div><h4 id="对象解构"><a href="#对象解构" class="headerlink" title="对象解构"></a>对象解构</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> person = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'zhangsan'</span>, <span class="hljs-attr">age</span>: <span class="hljs-number">20</span> &#125;; <span class="hljs-keyword">let</span> &#123; name, age &#125; = person;<span class="hljs-built_in">console</span>.log(name); <span class="hljs-comment">// 'zhangsan' </span><span class="hljs-built_in">console</span>.log(age); <span class="hljs-comment">// 20</span><span class="hljs-keyword">let</span> &#123;<span class="hljs-attr">name</span>: myName, <span class="hljs-attr">age</span>: myAge&#125; = person; <span class="hljs-comment">// myName myAge 属于别名</span><span class="hljs-built_in">console</span>.log(myName); <span class="hljs-comment">// 'zhangsan' </span><span class="hljs-built_in">console</span>.log(myAge); <span class="hljs-comment">// 20</span></code></pre></div><h4 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h4><ul><li>解构赋值就是把数据结构分解，然后给变量进行赋值</li><li>如果结构不成功，变量跟数值个数不匹配的时候，变量的值为undefined</li><li>数组解构用中括号包裹，多个变量用逗号隔开，对象解构用花括号包裹，多个变量用逗号隔开</li><li>利用解构赋值能够让我们方便的去取对象中的属性跟方法</li></ul><h3 id="12-3箭头函数"><a href="#12-3箭头函数" class="headerlink" title="12.3箭头函数"></a>12.3箭头函数</h3><p>ES6中新增的定义函数的方式。</p><div class="hljs"><pre><code class="hljs javascript">() =&gt; &#123;&#125; <span class="hljs-comment">//()：代表是函数； =&gt;：必须要的符号，指向哪一个代码块；&#123;&#125;：函数体</span><span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;&#125;<span class="hljs-comment">//代表把一个函数赋值给fn</span></code></pre></div><p>函数体中只有一句代码，且代码的执行结果就是返回值，可以省略大括号</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span>(<span class="hljs-params">num1, num2</span>) </span>&#123;     <span class="hljs-keyword">return</span> num1 + num2; &#125;<span class="hljs-comment">//es6写法</span><span class="hljs-keyword">const</span> sum = <span class="hljs-function">(<span class="hljs-params">num1, num2</span>) =&gt;</span> num1 + num2;</code></pre></div><p>如果形参只有一个，可以省略小括号</p><div class="hljs"><pre><code class="hljs javascript"> <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params">v</span>) </span>&#123;     <span class="hljs-keyword">return</span> v; &#125; <span class="hljs-comment">//es6写法</span> <span class="hljs-keyword">const</span> fn = <span class="hljs-function"><span class="hljs-params">v</span> =&gt;</span> v;</code></pre></div><p>箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> obj = &#123; <span class="hljs-attr">name</span>: <span class="hljs-string">'张三'</span>&#125; <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//this 指向 是obj对象</span>     <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;          <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>);<span class="hljs-comment">//this 指向 的是箭头函数定义的位置，那么这个箭头函数定义在fn里面，而这个fn指向是的obj对象，所以这个this也指向是obj对象</span>     &#125;  &#125;  <span class="hljs-keyword">const</span> resFn = fn.call(obj);  resFn();</code></pre></div><h4 id="小结-1"><a href="#小结-1" class="headerlink" title="小结"></a>小结</h4><ul><li>箭头函数中不绑定this，箭头函数中的this指向是它所定义的位置，可以简单理解成，定义箭头函数中的作用域的this指向谁，它就指向谁</li><li>箭头函数的优点在于解决了this执行环境所造成的一些问题。比如：解决了匿名函数this指向的问题（匿名函数的执行环境具有全局性），包括setTimeout和setInterval中使用this所造成的问题</li></ul><h4 id="面试题"><a href="#面试题" class="headerlink" title="面试题"></a>面试题</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> age = <span class="hljs-number">100</span>;<span class="hljs-keyword">var</span> obj = &#123;age: <span class="hljs-number">20</span>,say: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;alert(<span class="hljs-keyword">this</span>.age)&#125;&#125;obj.say();<span class="hljs-comment">//箭头函数this指向的是被声明的作用域里面，而对象没有作用域的，所以箭头函数虽然在对象中被定义，但是this指向的是全局作用域</span></code></pre></div><h3 id="12-4剩余参数"><a href="#12-4剩余参数" class="headerlink" title="12.4剩余参数"></a>12.4剩余参数</h3><p>剩余参数语法允许我们将一个不定数量的参数表示为一个数组，不定参数定义方式，这种方式很方便的去声明不知道参数情况下的一个函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sum</span> (<span class="hljs-params">first, ...args</span>) </span>&#123;     <span class="hljs-built_in">console</span>.log(first); <span class="hljs-comment">// 10</span>     <span class="hljs-built_in">console</span>.log(args); <span class="hljs-comment">// [20, 30] </span> &#125; sum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>)</code></pre></div><h4 id="剩余参数和解构配合使用"><a href="#剩余参数和解构配合使用" class="headerlink" title="剩余参数和解构配合使用"></a>剩余参数和解构配合使用</h4><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> students = [<span class="hljs-string">'wangwu'</span>, <span class="hljs-string">'zhangsan'</span>, <span class="hljs-string">'lisi'</span>];<span class="hljs-keyword">let</span> [s1, ...s2] = students; <span class="hljs-built_in">console</span>.log(s1);  <span class="hljs-comment">// 'wangwu' </span><span class="hljs-built_in">console</span>.log(s2);  <span class="hljs-comment">// ['zhangsan', 'lisi']</span></code></pre></div><h3 id="12-5ES6-的内置对象扩展"><a href="#12-5ES6-的内置对象扩展" class="headerlink" title="12.5ES6 的内置对象扩展"></a>12.5ES6 的内置对象扩展</h3><ul><li><p>Array 的扩展方法</p><ul><li><p><strong>扩展运算符（展开语法）</strong></p><p>扩展运算符可以将数组或者对象转为用逗号分隔的参数序列</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>];...ary  <span class="hljs-comment">// 1, 2, 3</span><span class="hljs-built_in">console</span>.log(...ary);    <span class="hljs-comment">// 1 2 3,相当于下面的代码</span><span class="hljs-built_in">console</span>.log(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>);</code></pre></div><p>扩展运算符可以应用于合并数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">// 方法一 </span> <span class="hljs-keyword">let</span> ary1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]; <span class="hljs-keyword">let</span> ary2 = [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-keyword">let</span> ary3 = [...ary1, ...ary2]; <span class="hljs-comment">// 方法二 </span> ary1.push(...ary2);</code></pre></div><p>将类数组或可遍历对象转换为真正的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> oDivs = <span class="hljs-built_in">document</span>.getElementsByTagName(<span class="hljs-string">'div'</span>); oDivs = [...oDivs];</code></pre></div></li><li><p><strong>构造函数方法：Array.from()</strong></p><p>将伪数组或可遍历对象转换为真正的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-comment">//定义一个集合</span><span class="hljs-keyword">let</span> arrayLike = &#123;    <span class="hljs-string">'0'</span>: <span class="hljs-string">'a'</span>,    <span class="hljs-string">'1'</span>: <span class="hljs-string">'b'</span>,    <span class="hljs-string">'2'</span>: <span class="hljs-string">'c'</span>,    length: <span class="hljs-number">3</span>&#125;; <span class="hljs-comment">//转成数组</span><span class="hljs-keyword">let</span> arr2 = <span class="hljs-built_in">Array</span>.from(arrayLike); <span class="hljs-comment">// ['a', 'b', 'c']</span></code></pre></div><p>方法还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arrayLike = &#123;     <span class="hljs-string">"0"</span>: <span class="hljs-number">1</span>,    <span class="hljs-string">"1"</span>: <span class="hljs-number">2</span>,    <span class="hljs-string">"length"</span>: <span class="hljs-number">2</span>&#125;<span class="hljs-keyword">let</span> newAry = <span class="hljs-built_in">Array</span>.from(arrayLike, item =&gt; item *<span class="hljs-number">2</span>)<span class="hljs-comment">//[2,4]</span></code></pre></div><p>注意：如果是对象，那么属性需要写对应的索引</p></li><li><p>实例方法：find()</p><p>用于找出第一个符合条件的数组成员，如果没有找到返回undefined</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [&#123;     id: <span class="hljs-number">1</span>,     name: <span class="hljs-string">'张三'</span> &#125;, &#123;      id: <span class="hljs-number">2</span>,     name: <span class="hljs-string">'李四'</span> &#125;];  <span class="hljs-keyword">let</span> target = ary.find(<span class="hljs-function">(<span class="hljs-params">item, index</span>) =&gt;</span> item.id == <span class="hljs-number">2</span>);<span class="hljs-comment">//找数组里面符合条件的值，当数组中元素id等于2的查找出来，注意，只会匹配第一个</span></code></pre></div></li><li><p>实例方法：findIndex()</p><p>用于找出第一个符合条件的数组成员的位置，如果没有找到返回-1</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> ary = [<span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>, <span class="hljs-number">15</span>];<span class="hljs-keyword">let</span> index = ary.findIndex(<span class="hljs-function">(<span class="hljs-params">value, index</span>) =&gt;</span> value &gt; <span class="hljs-number">9</span>); <span class="hljs-built_in">console</span>.log(index); <span class="hljs-comment">// 2</span></code></pre></div></li><li><p>实例方法：includes()</p><p>判断某个数组是否包含给定的值，返回布尔值。</p><div class="hljs"><pre><code class="hljs javascript">[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">2</span>) <span class="hljs-comment">// true </span>[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>].includes(<span class="hljs-number">4</span>) <span class="hljs-comment">// false</span></code></pre></div></li></ul></li><li><p>String 的扩展方法</p><ul><li><p>模板字符串</p><p>ES6新增的创建字符串的方式，使用反引号定义</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">`zhangsan`</span>;</code></pre></div><p>模板字符串中可以解析变量</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> name = <span class="hljs-string">'张三'</span>; <span class="hljs-keyword">let</span> sayHello = <span class="hljs-string">`hello,my name is <span class="hljs-subst">$&#123;name&#125;</span>`</span>; <span class="hljs-comment">// hello, my name is zhangsan</span></code></pre></div><p>模板字符串中可以换行</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> result = &#123;     name: <span class="hljs-string">'zhangsan'</span>,     age: <span class="hljs-number">20</span>,    sex: <span class="hljs-string">'男'</span> &#125; <span class="hljs-keyword">let</span> html = <span class="hljs-string">` &lt;div&gt;</span><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.name&#125;</span>&lt;/span&gt;</span><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.age&#125;</span>&lt;/span&gt;</span><span class="hljs-string">    &lt;span&gt;<span class="hljs-subst">$&#123;result.sex&#125;</span>&lt;/span&gt;</span><span class="hljs-string">&lt;/div&gt; `</span>;</code></pre></div><p>在模板字符串中可以调用函数</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> sayHello = <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;     <span class="hljs-keyword">return</span> <span class="hljs-string">'哈哈哈哈 追不到我吧 我就是这么强大'</span>; &#125;;  <span class="hljs-keyword">let</span> greet = <span class="hljs-string">`<span class="hljs-subst">$&#123;sayHello()&#125;</span> 哈哈哈哈`</span>; <span class="hljs-built_in">console</span>.log(greet); <span class="hljs-comment">// 哈哈哈哈 追不到我吧 我就是这么强大 哈哈哈哈</span></code></pre></div></li><li><p>实例方法：startsWith() 和 endsWith()<br>startsWith()：表示参数字符串是否在原字符串的头部，返回布尔值<br>endsWith()：表示参数字符串是否在原字符串的尾部，返回布尔值</p></li><li><p>实例方法：repeat()<br>repeat方法表示将原字符串重复n次，返回一个新字符串。</p></li></ul></li><li><p>Set 数据结构</p><p>ES6 提供了新的数据结构 Set。它类似于数组，但是成员的值都是唯一的，没有重复的值。</p><p>Set本身是一个构造函数，用来生成 Set 数据结构</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();</code></pre></div><p>Set函数可以接受一个数组作为参数，用来初始化。</p><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-keyword">set</span> = new Set([1, 2, 3, 4, 4]);//&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>&#125;</code></pre></div><p><strong>实例方法</strong></p><ul><li>add(value)：添加某个值，返回 Set 结构本身</li><li>delete(value)：删除某个值，返回一个布尔值，表示删除是否成功</li><li>has(value)：返回一个布尔值，表示该值是否为 Set 的成员</li><li>clear()：清除所有成员，没有返回值</li></ul><div class="hljs"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> s = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Set</span>();s.add(<span class="hljs-number">1</span>).add(<span class="hljs-number">2</span>).add(<span class="hljs-number">3</span>); <span class="hljs-comment">// 向 set 结构中添加值 </span>s.delete(<span class="hljs-number">2</span>)             <span class="hljs-comment">// 删除 set 结构中的2值   </span>s.has(<span class="hljs-number">1</span>)                <span class="hljs-comment">// 表示 set 结构中是否有1这个值 返回布尔值 </span>s.clear()               <span class="hljs-comment">// 清除 set 结构中的所有值</span><span class="hljs-comment">//注意：删除的是元素的值，不是代表的索引</span></code></pre></div><p><strong>遍历</strong></p><p>Set 结构的实例与数组一样，也拥有forEach方法，用于对每个成员执行某种操作，没有返回值。</p><div class="hljs"><pre><code class="hljs javascript">s.forEach(<span class="hljs-function"><span class="hljs-params">value</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(value))</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>数据可视化ECharts项目</title>
    <link href="/2020/06/08/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96ECharts%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96ECharts%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200608152310511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>此项目是根据<a href="https://www.bilibili.com/video/BV1v7411R7mp?p=51" target="_blank" rel="noopener">pink老师的课程</a>实现的ECharts数据可视化项目<br>项目地址： <a href="http://tq07.gitee.io/echarts" target="_blank" rel="noopener">http://tq07.gitee.io/echarts</a></p><h3 id="Echarts基础知识"><a href="#Echarts基础知识" class="headerlink" title="Echarts基础知识"></a>Echarts基础知识</h3><blockquote><p>ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。<br>官网地址：<a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">https://www.echartsjs.com/zh/index.html</a></p></blockquote><h4 id="1-使用步骤："><a href="#1-使用步骤：" class="headerlink" title="1.使用步骤："></a>1.使用步骤：</h4><p>1.获取 ECharts （<a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">Apache ECharts (incubating) 官网下载界面</a>）（该项目使用直接下载的ECharts插件）</p><p>2.引入ECharts 插件到html页面中</p><div class="hljs"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"./js/echarts.min.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p>3.准备一个具备大小的DOM容器</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 600px;height:400px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>4.初始化echarts实例对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span> <span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'main'</span>));</code></pre></div><p>5.指定配置项和数据(option)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> option = &#123;            title: &#123;                text: <span class="hljs-string">'ECharts 入门示例'</span>            &#125;,            tooltip: &#123;&#125;,            legend: &#123;                data:[<span class="hljs-string">'销量'</span>]            &#125;,            xAxis: &#123;                data: [<span class="hljs-string">"衬衫"</span>,<span class="hljs-string">"羊毛衫"</span>,<span class="hljs-string">"雪纺衫"</span>,<span class="hljs-string">"裤子"</span>,<span class="hljs-string">"高跟鞋"</span>,<span class="hljs-string">"袜子"</span>]            &#125;,            yAxis: &#123;&#125;,            series: [&#123;                name: <span class="hljs-string">'销量'</span>,                type: <span class="hljs-string">'bar'</span>,                data: [<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]            &#125;]        &#125;;</code></pre></div><p>6.将配置项设置给echarts实例对象</p><div class="hljs"><pre><code class="hljs js">myChart.setOption(option);</code></pre></div><h4 id="2-Echarts基础配置"><a href="#2-Echarts基础配置" class="headerlink" title="2.Echarts基础配置"></a>2.Echarts基础配置</h4><ul><li>series（系列）<br>每个系列通过 <code>series.type</code> 决定自己的图表类型（图表数据，指定什么类型的图表，可以多个图表重叠）。</li><li>xAxis：直角坐标系 grid 中的 x 轴</li><li>yAxis：直角坐标系 grid 中的 y 轴</li><li>grid：直角坐标系内绘图网格</li><li>title：标题组件</li><li>tooltip：提示框组件</li><li>legend：图例组件</li><li>color：调色盘颜色列表</li><li>boundaryGap:<br>坐标轴两边留白策略，类目轴中 boundaryGap 可以配置为 true 和 false。默认为 true，可以保证刻度线和标签对齐。这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。<img src="https://img-blog.csdnimg.cn/20200608161640464.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>数据堆叠，同个类目轴上系列配置相同的<code>stack</code>值后 后一个系列的值会在前一个系列的值上相加。</li></ul><p>示例：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> option = &#123;<span class="hljs-comment">// color设置线条的颜色 注意后面是个数组</span>        color: [<span class="hljs-string">'pink'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'skyblue'</span>],        <span class="hljs-comment">// 设置图表的标题</span>    title: &#123;        text: <span class="hljs-string">'折线图堆叠123'</span>    &#125;,    <span class="hljs-comment">// 图表的提示框组件</span>    tooltip: &#123;    <span class="hljs-comment">// 触发方式</span>            trigger: <span class="hljs-string">'axis'</span>,            <span class="hljs-comment">// 坐标轴指示器，坐标轴触发有效</span>            axisPointer: &#123;                type: <span class="hljs-string">'shadow'</span>  <span class="hljs-comment">// 默认为直线，可选为：'line' | 'shadow'</span>            &#125;        &#125;,        <span class="hljs-comment">// 图例组件</span>    legend: &#123;       <span class="hljs-comment">// series里面有了 name值，则 legend里面的data可以删掉</span>    &#125;,    <span class="hljs-comment">// 网格配置  grid可以控制线形图 柱状图 图表大小</span>        grid: &#123;            top: <span class="hljs-string">"10%"</span>,            left: <span class="hljs-string">"22%"</span>,            bottom: <span class="hljs-string">"10%"</span>，            <span class="hljs-comment">// 是否显示刻度标签 如果是true 就显示， false则不显示</span>           containLabel: <span class="hljs-literal">true</span>        &#125;,        <span class="hljs-comment">// 工具箱组件  可以另存为图片等功能</span>    toolbox: &#123;        feature: &#123;            saveAsImage: &#123;&#125;        &#125;    &#125;,    <span class="hljs-comment">// 设置x轴的相关配置</span>        xAxis: &#123;            show:<span class="hljs-literal">false</span>        &#125;,        <span class="hljs-comment">// 设置y轴的相关配置</span>        yAxis: [            &#123;                type: <span class="hljs-string">'category'</span>,                inverse: <span class="hljs-literal">true</span>,                data: [<span class="hljs-string">"HTML5"</span>, <span class="hljs-string">"CSS3"</span>, <span class="hljs-string">"javascript"</span>, <span class="hljs-string">"VUE"</span>, <span class="hljs-string">"NODE"</span>],                <span class="hljs-comment">//不显示y轴线条</span>                axisLine: &#123;                    show: <span class="hljs-literal">false</span>                    <span class="hljs-comment">// 如果想要设置单独的线条样式 </span>    <span class="hljs-comment">// lineStyle: &#123;</span>     <span class="hljs-comment">//    color: "rgba(255,255,255,.1)",</span>       <span class="hljs-comment">//    width: 1,</span>       <span class="hljs-comment">//    type: "solid"</span>      <span class="hljs-comment">//  &#125;</span>                        &#125;,                <span class="hljs-comment">// 不显示刻度</span>                axisTick: &#123;                show: <span class="hljs-literal">false</span>                &#125;,               Y轴的文字颜色和大小                axisLabel:&#123;                    color:<span class="hljs-string">"#fff"</span>，                    fontSize: <span class="hljs-string">"12"</span>                &#125;，                <span class="hljs-comment">// y 轴分隔线样式</span>   splitLine: &#123;       lineStyle: &#123;          color: <span class="hljs-string">"rgba(255,255,255,.1)"</span>        &#125;   &#125;            &#125;,            &#123;                type: <span class="hljs-string">'category'</span>,                inverse: <span class="hljs-literal">true</span>,                data: [<span class="hljs-number">702</span>, <span class="hljs-number">350</span>, <span class="hljs-number">610</span>, <span class="hljs-number">793</span>, <span class="hljs-number">664</span>],                <span class="hljs-comment">//不显示y轴线条</span>                axisLine: &#123;                    show: <span class="hljs-literal">false</span>                        &#125;,                <span class="hljs-comment">// 不显示刻度</span>                axisTick: &#123;                show: <span class="hljs-literal">false</span>                &#125;,                                axisLabel:&#123;                    color:<span class="hljs-string">"#fff"</span>,                    fontSize:<span class="hljs-number">12</span>                &#125;            &#125;,        ],        <span class="hljs-comment">// 系列图表配置 它决定着显示那种类型的图表</span>        series: [            &#123;                name: <span class="hljs-string">'bar'</span>,                type: <span class="hljs-string">'bar'</span>,                <span class="hljs-comment">// 柱子之间的距离</span>                barCategoryGap:<span class="hljs-number">50</span>,                <span class="hljs-comment">// 修改柱子宽度</span>                barWidth:<span class="hljs-number">10</span>,                itemStyle:&#123;                 <span class="hljs-comment">// 修改柱子圆角</span>                        barBorderRadius:<span class="hljs-number">20</span>,                        <span class="hljs-comment">//给 itemStyle  里面的color 属性设置一个 返回值函数</span>                        <span class="hljs-comment">// params 传进来的是柱子对象</span>                        color:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>)</span>&#123;                        <span class="hljs-comment">// dataIndex 是当前柱子的索引号</span>                        <span class="hljs-keyword">return</span> myColor[params.dataIndex];                        &#125;                 &#125;,                data: [<span class="hljs-number">70</span>, <span class="hljs-number">34</span>, <span class="hljs-number">60</span>, <span class="hljs-number">78</span>, <span class="hljs-number">69</span>],                <span class="hljs-comment">// 图形上的文本标签</span>                label:&#123;                    normal:&#123;                        show: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 图形内显示</span>                        position: <span class="hljs-string">"inside"</span>,                        <span class="hljs-comment">// 文字的显示格式   &#123;c&#125; 会自动的解析为 数据  data里面的数据</span>                        formatter: <span class="hljs-string">"&#123;c&#125;%"</span>                    &#125;                &#125;,                yAxisIndex: <span class="hljs-number">0</span>, <span class="hljs-comment">//层级关系</span>            &#125;,            &#123;                name: <span class="hljs-string">'box'</span>,                type: <span class="hljs-string">'bar'</span>,                barCategoryGap: <span class="hljs-number">50</span>,                barWidth: <span class="hljs-number">15</span>,                itemStyle: &#123;                    color: <span class="hljs-string">"none"</span>,                    borderColor: <span class="hljs-string">"#00c1de"</span>,                    borderWidth: <span class="hljs-number">3</span>,                    barBorderRadius: <span class="hljs-number">15</span>                &#125;,                data: [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>],                yAxisIndex: <span class="hljs-number">1</span>, <span class="hljs-comment">//层级关系</span>            &#125;        ]    &#125;;</code></pre></div><p>补充知识点：<br>1.折线类型图表把折线修饰为圆滑 ，在series 数据中添加 smooth 为 true<br>2.带有直角坐标系的比如折线图、柱状图是 grid修改图形大小，而饼形图是通过 radius 修改大小<br>3.饼图图形上的文本标签可以控制饼形图的文字的一些样式， label 对象中设置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 文本标签控制饼形图文字的相关样式， 注意它是一个对象</span>       label: &#123;         fontSize: <span class="hljs-number">10</span>       &#125;,</code></pre></div><p>4.引导线调整，在series对象里面的 labelLine 对象设置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 引导线调整</span>      labelLine: &#123;       <span class="hljs-comment">// 连接扇形图线长</span>        length: <span class="hljs-number">6</span>,       <span class="hljs-comment">// 连接文字线长</span>       length2: <span class="hljs-number">8</span>      &#125;</code></pre></div><p>5.地图放大通过 zoom ，设置为数字</p><h3 id="项目使用的技术："><a href="#项目使用的技术：" class="headerlink" title="项目使用的技术："></a>项目使用的技术：</h3><ul><li><p>div + css</p></li><li><p>flex 布局</p></li><li><p>Less （在html页面中需导入对应的css文件，在VScode中安装Easy LESS插件可以直接把less文件转成css文件）</p></li><li><p>原生js</p><p>注意：每个图表指定配置项和数据(option)需要使用立即执行函数或者在函数中使用let声明变量，避免命名冲突</p></li><li><p>rem适配</p></li><li><p>引用淘宝的flexible.js 把屏幕分为 24 等份</p></li><li><p>VScode中安装cssrem插件，并修改cssrem 插件的基准值为 80px<br><img src="https://img-blog.csdnimg.cn/20200608181816692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述">注：别忘记重启vscode软件保证生效</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECharts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI</title>
    <link href="/2020/06/05/WebAPI/"/>
    <url>/2020/06/05/WebAPI/</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/6/5/17282a52b579827e?w=3111&h=10775&f=png&s=2950128" srcset="/img/loading.gif" alt=""></p><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，帮助我们实现某种功能</p><p>Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p><h2 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2.DOM"></a>2.DOM</h2><p>文档对象模型（Document Object Model，简称DOM），是 W3C组织推荐的处理可扩展标记语言（html或者xhtml）的标准编程接口。<br><strong>文档</strong>：一个页面就是一个文档，DOM中使用<strong>document</strong>表示<br><strong>节点</strong>：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用<strong>node</strong>表示<br><strong>标签节点</strong>：网页中的所有标签，通常称为<strong>元素节点</strong>，又简称为“元素”，使用<strong>element</strong>表示</p><h3 id="2-1获取元素"><a href="#2-1获取元素" class="headerlink" title="2.1获取元素"></a>2.1获取元素</h3><ul><li><p>ID 获取</p><ul><li>语法：document.getElementById(‘id’)</li><li>作用：根据ID获取元素对象</li><li>参数：id值，区分大小写的<strong>字符串</strong></li><li>返回值：元素对象 或 null</li></ul></li><li><p>标签名获取</p><ul><li><p>语法：</p><p>1.<strong>document</strong>.getElementsByTagName(‘标签名’)</p><p>2.<strong>element</strong>.getElementsByTagName(‘标签名’)</p></li><li><p>作用：根据标签名获取元素对象</p></li><li><p>参数：标签名</p></li><li><p>返回值：元素对象集合（伪数组，数组元素是元素对象）</p><p>注意：</p><p>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。</p><p>2.得到元素对象是动态的</p><p>3.如果获取不到元素,则返回为空的伪数组</p></li></ul></li><li><p>HTML5 新增的方法获取</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementsByClassName(‘类名’)；<span class="hljs-comment">// 根据类名返回元素对象集合</span><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'选择器'</span>); <span class="hljs-comment">// 根据指定选择器返回第一个元素对象</span><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'选择器'</span>); <span class="hljs-comment">// 根据指定选择器返回所有元素对象集合</span></code></pre></div><p>注意：querySelector 和querySelectorAll里面的选择器需要加符号</p><p><code>document.querySelector(&#39;#nav&#39;);</code></p></li><li><p>特殊元素获取</p><ul><li>获取body元素<br><code>doucumnet.body // 返回body元素对象</code></li><li>获取html元素<br><code>document.documentElement // 返回html元素对象</code></li></ul></li></ul><h3 id="2-2事件基础"><a href="#2-2事件基础" class="headerlink" title="2.2事件基础"></a>2.2事件基础</h3><ul><li><p>事件三要素</p><ul><li><p>事件源（谁）：触发事件的元素</p></li><li><p>事件类型（什么事件）： 例如 click 点击事件</p></li><li><p>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</p></li></ul></li><li><p>执行事件的步骤</p><ul><li>获取事件源</li><li>注册事件（绑定事件）</li><li>添加事件处理程序（采取函数赋值形式）</li></ul></li><li><p>常见的鼠标事件</p><p><img src="https://img-blog.csdnimg.cn/20200604225603884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="2-3操作元素"><a href="#2-3操作元素" class="headerlink" title="2.3操作元素"></a>2.3操作元素</h3><p>JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p><p><strong>获取属性的值</strong><br>元素对象.属性名<br><strong>设置属性的值</strong><br>元素对象.属性名 = 值<br><strong>表单元素</strong>中有一些属性如：disabled、checked、selected，元素对象的这些<strong>属性的值</strong>是<strong>布尔型</strong>。</p><ul><li><p>改变元素内容</p><ul><li>element.innerText<br>从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉</li><li><strong>element.innerHTML</strong>(W3C标准)<br>起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行</li></ul></li><li><p>常用元素的属性操作</p><ol><li><p>nnerText、innerHTML 改变元素内容</p></li><li><p>src、href</p></li><li><p>id、alt、title</p></li></ol></li><li><p>表单元素的属性操作</p><p>type、value、checked、selected、disabled</p></li><li><p>样式属性操作</p><ul><li><p>element.style 行内样式操作<br><code>元素对象.style.样式属性 = 值;</code><br><strong>注意</strong>：<br>1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor<br>2.JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高</p></li><li><p>element.className 类名样式操作<br><code>元素对象.className = 值;</code><br><strong>注意</strong>：</p><p>1.如果样式修改较多，可以采取操作类名方式更改元素样式。</p><p>2.class因为是个保留字，因此使用className来操作元素类名属性</p><p>3.className 会直接更改元素的类名，会覆盖原先的类名。</p></li></ul></li><li><p>自定义属性的操作<br><strong>H5自定义属性</strong><br>自定义属性目的：是为了<strong>保存并使用数据</strong>。有些数据可以保存到页面中而不用保存到数据库中<br><strong>1. 设置H5自定义属性</strong><br>H5规定自定义属性data-开头做为属性名并且赋值。<br><code>&lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt;</code><br>或者使用 JS 设置<br><code>element.setAttribute(‘data-index’, 2)</code><br><strong>2. 获取H5自定义属性</strong><br>兼容性获取 element.getAttribute(‘data-index’);<br>H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持<br><strong>获取属性值</strong><br>element.属性 获取内置属性值（元素本身自带的属性）<br><code>element.getAttribute(‘属性’);</code> 主要获得自定义的属性 （标准）<br><strong>设置属性值</strong><br>element.属性 设置内置属性值<br><code>element.setAttribute(‘属性’);</code> 主要设置自定义的属性 （标准）<br><strong>移除属性</strong><br><code>element.removeAttribute(&#39;属性&#39;);</code></p></li></ul><h3 id="2-4节点操作"><a href="#2-4节点操作" class="headerlink" title="2.4节点操作"></a>2.4节点操作</h3><ul><li><p>节点概述</p><p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点 nodeType 为 1</li><li>属性节点 nodeType 为 2</li><li>文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）<br>我们在实际开发中，节点操作主要操作的是<strong>元素节点</strong></li></ul></li><li><p>节点层级</p><p>利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。</p><p>1.父级节点<br><code>node.parentNode</code></p><ul><li>parentNode 属性可返回某节点的父节点，注意是最近的一个父节点</li><li>如果指定的节点没有父节点则返回 null</li></ul><p>2.子节点</p><ul><li><p>所有子节点<br>parentNode.childNodes（标准）<br>parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。<br>注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。<br>如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes</p></li><li><p><strong>子元素节点</strong><br>parentNode.<strong>children</strong>（非标准）<br>parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回 （<strong>这个是我们重点掌握的</strong>）。</p><p>parentNode.<strong>firstChild</strong><br>firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。parentNode.<strong>lastChild</strong> 最后一个子节点<br>lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p><p>parentNode.<strong>firstElementChild</strong><br>firstElementChild 返回第一个子元素节点，找不到则返回null。parentNode.<strong>lastElementChild</strong><br>lastElementChild 返回最后一个子元素节点，找不到则返回null。<br>注意：这两个方法有兼容性问题，IE9 以上才支持。</p><p>实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和lastElementChild 又有兼容性问题，那么我们如何<strong>获取第一个子元素节点</strong>或<strong>最后一个子元素节点</strong>呢？</p><p><strong>解决方案：</strong></p><ol><li>如果想要第一个子元素节点，可以使用 <strong>parentNode.chilren[0]</strong></li><li>如果想要最后一个子元素节点，可以使用<strong>parentNode.chilren[parentNode.chilren.length - 1]</strong></li></ol></li></ul><p>3.兄弟节点</p><p>​ node.<strong>nextSibling</strong><br>​ nextSibling 返回当前元素的下一个兄弟节点，找不到则返回null。同样，也是包含所有的节点。<br>​ node.<strong>previousSibling</strong><br>​ previousSibling 返回当前元素上一个兄弟节点，找不到则返回null。同样，也是包含所有的节点。</p><p>​ 注意：这下面两个方法有兼容性问题， IE9 以上才支持。<br>​ node.nextElementSibling<br>​ nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。<br>​ node.previousElementSibling<br>​ previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。</p></li><li><p>创建节点</p><p><strong>document.createElement(‘tagName’)</strong><br>document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为<strong>动态创建元素节点</strong>。</p></li><li><p>添加节点</p><p><strong>node.appendChild(child)</strong><br>node.appendChild() 方法将<strong>一个节点</strong>添加到指定<strong>父节点的子节点列表末尾</strong>。类似于 CSS 里面的after 伪元素。</p><p><strong>node.insertBefore(child, 指定元素)</strong><br>node.insertBefore() 方法将<strong>一个节点</strong>添加到<strong>父节点的指定子节点前面</strong>。类似于 CSS 里面的 before 伪元素。</p></li><li><p>删除节点</p><p>node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点。</p></li><li><p>复制节点</p><p>node.cloneNode()<br>node.cloneNode() 方法返回调用该方法的节点的一个副本。<br>注意：</p><p>1.如果括号<strong>参数为空</strong>或者为 <strong>false</strong> ，则是<strong>浅拷贝</strong>，即只克隆复制节点本身，不克隆里面的子节点。</p><p>2.如果括号<strong>参数为 tru</strong>e ，则是<strong>深度拷贝</strong>，会复制节点本身以及里面所有的子节点。</p></li><li><p>替换节点</p><p>parentNode.replaceChild(newChild, oldChild);<br>用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</p></li><li><p><strong>三种动态创建元素区别</strong></p><p>document.write()<br>element.innerHTML<br>document.createElement()<br>区别：</p><ol><li><p><strong>document.write</strong> 是直接将内容写入页面的内容流，会<strong>导致页面</strong>全部<strong>重绘</strong></p></li><li><p>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘</p></li><li><p>如果页面<strong>创建元素很多</strong>，建议使用 <strong>innerHTML</strong> ，因其<strong>效率更高</strong>（不要拼接字符串，<strong>采取数组形式拼接</strong>） ，但是结构稍微复杂</p></li><li><p>如果页面创建元素较少，建议使用 createElement() ，结构更清晰<br>总结：不同浏览器下，innerHTML 效率要比 creatElement 高</p><p><strong>createElement方式</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);            div.style.width = <span class="hljs-string">'100px'</span>;            div.style.height = <span class="hljs-string">'2px'</span>;            div.style.border = <span class="hljs-string">'1px solid red'</span>;            <span class="hljs-built_in">document</span>.body.appendChild(div);        &#125;        <span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p><strong>innerHTML数组方式</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">var</span> array = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            array.push(<span class="hljs-string">'&lt;div style="width:100px; height:2px; border:1px solid blue;"&gt;&lt;/div&gt;'</span>);        &#125;        <span class="hljs-built_in">document</span>.body.innerHTML = array.join(<span class="hljs-string">''</span>);        <span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div></li></ol></li></ul><h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3.BOM"></a>3.BOM</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p><img src="https://img-blog.csdnimg.cn/20200605084652710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-1window"><a href="#3-1window" class="headerlink" title="3.1window"></a>3.1window</h3><p>window 对象是浏览器的顶级对象，它具有双重角色。</p><ol><li>它是 JS 访问浏览器窗口的一个接口。</li><li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。</li><li>在调用的时候可以省略 window， alert()、prompt()都属于 window 对象方法。<br>注意：window下的一个特殊属性 window.name</li></ol><h3 id="3-2window-对象的常见事件"><a href="#3-2window-对象的常见事件" class="headerlink" title="3.2window 对象的常见事件"></a>3.2window 对象的常见事件</h3><ul><li><p>窗口加载事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"load"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);</code></pre></div><p>window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等)。<br>注意：</p><ul><li><p>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。</p></li><li><p>window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个为准。如果使用 addEventListener 则没有限制</p></li></ul><p><code>document.addEventListener(&#39;DOMContentLoaded&#39;,function(){}) //Ie9以上才支持</code><br>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。<br>如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p></li><li><p>调整窗口大小事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);</code></pre></div><p>window.onresize 是调整窗口大小加载事件<br>注意：</p><ul><li>只要窗口大小发生像素变化，就会触发这个事件。</li><li>经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度</li></ul></li></ul><h3 id="3-3location-对象"><a href="#3-3location-对象" class="headerlink" title="3.3location 对象"></a>3.3location 对象</h3><p>​ 用于获取或设置窗体的 URL，并且可以用于解析 URL</p><ul><li><p>统一资源定位符 (Uniform Resource Locator, URL)</p><p>是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p></li></ul><p>​ URL 的一般语法格式为：protocol://host[:port]/path/[?query]#fragment</p><p><img src="https://img-blog.csdnimg.cn/20200605093430290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>location 对象的属性</p><p><img src="https://img-blog.csdnimg.cn/20200605093832429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>重点记住： href 和 search</p></li><li><p>location对象的常见方法</p><p><img src="https://img-blog.csdnimg.cn/20200605093832427.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="3-4navigator-对象"><a href="#3-4navigator-对象" class="headerlink" title="3.4navigator 对象"></a>3.4navigator 对象</h3><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户端发送服务器的 user-agent 头部的值,可以判断用户使用什么终端打开页面，实现跳转</p><h3 id="3-5history-对象"><a href="#3-5history-对象" class="headerlink" title="3.5history 对象"></a>3.5history 对象</h3><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。（ 一般在OA 办公系统中使用）</p><p><img src="https://img-blog.csdnimg.cn/20200605093831302.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-6定时器"><a href="#3-6定时器" class="headerlink" title="3.6定时器"></a>3.6定时器</h3><ul><li><p><strong>setTimeout() 定时器</strong>（炸弹）</p><p>开启定时器：window.setTimeout(调用函数, [延迟的毫秒数]);<br>setTimeout() 的调用函数我们也称为回调函数 callback，在<strong>定时器到期后执行调用函数</strong><br>注意：</p><ul><li><p>window 可以省略。</p></li><li><p>这个调用函数可以直接写函数，或者写函数名</p></li><li><p>延迟的毫秒数省略默认是 0</p></li><li><p>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</p></li></ul><p>停止定时器：<br>window.clearTimeout(timeoutID)<br>clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。<br>注意：里面的参数就是定时器的标识符 。</p></li><li><p><strong>setInterval() 定时器（闹钟）</strong></p><p>开启定时器：<br>window.setInterval(回调函数, [间隔的毫秒数]);<br>setInterval() 方法重复调用一个函数，<strong>每隔这个时间，就去调用一次回调函数</strong>。<br>注意：</p><ul><li><p>window 可以省略。</p></li><li><p>这个调用函数可以直接写函数，或者写函数名。</p></li><li><p>间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。</p></li><li><p>第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。</p></li></ul><p>停止 setInterval() 定时器：<br>window.clearInterval(intervalID);<br>clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。</p></li></ul><h3 id="3-7this指向问题"><a href="#3-7this指向问题" class="headerlink" title="3.7this指向问题"></a>3.7this指向问题</h3><p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p><ol><li>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</li><li>方法调用中谁调用this指向谁</li><li>构造函数中this指向构造函数的实例</li></ol><h2 id="4-事件高级"><a href="#4-事件高级" class="headerlink" title="4.事件高级"></a>4.事件高级</h2><h3 id="4-1注册事件"><a href="#4-1注册事件" class="headerlink" title="4.1注册事件"></a>4.1注册事件</h3><p>给元素添加事件，称为注册事件或者绑定事件。<br>注册事件有两种方式：传统方式和方法监听注册方式</p><ul><li><p>传统注册方式</p><ul><li>利用 on 开头的事件 onclick</li><li><code>&lt;button onclick=“alert(&#39;hi~&#39;)”&gt;&lt;/button&gt;</code>或者<code>btn.onclick = function() {}</code><br>特点：同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数</li></ul></li><li><p>方法监听注册方式(w3c 标准推荐方式)</p><p><strong>addEventListener 事件监听方式</strong></p><p><code>eventTarget.addEventListener(type, listener[, useCapture])</code></p><p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。<br>该方法接收三个参数：</p><ul><li><p>type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on</p></li><li><p>listener：事件处理函数，事件发生时，会调用该监听函数</p></li><li><p>useCapture：可选参数，是一个布尔值，默认是 false。</p><p>特点：不支持IE9 之前的 IE，同一个元素同一个事件可以注册多个监听器,按注册顺序依次执行</p></li></ul><p><strong>attachEvent 事件监听方式</strong></p><p><code>eventTarget.attachEvent(eventNameWithOn, callback)</code></p><p>eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触</p><p>发指定的事件时，指定的回调函数就会被执行。</p><p>该方法接收两个参数：</p><ul><li><p>eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on</p></li><li><p>callback： 事件处理函数，当目标触发事件时回调函数被调用</p><p><strong>注意：</strong>IE8 及早期版本支持</p></li></ul></li></ul><h3 id="4-2删除事件"><a href="#4-2删除事件" class="headerlink" title="4.2删除事件"></a>4.2删除事件</h3><ul><li>传统方式<br>eventTarget.onclick = null;</li><li>方法监听注册方式<br>① eventTarget.removeEventListener(type, listener[, useCapture]);<br>② eventTarget.detachEvent(eventNameWithOn, callback);</li></ul><h3 id="4-3DOM-事件流"><a href="#4-3DOM-事件流" class="headerlink" title="4.3DOM 事件流"></a>4.3DOM 事件流</h3><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p>注意 :</p><ul><li>JS代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>onclick 和 attachEvent 只能得到冒泡阶段。</li><li>addEventListener(type, listener[, <strong>useCapture</strong>])第三个参数如果是 <strong>true</strong>，表示在<strong>事件捕</strong><br><strong>获阶段</strong>调用事件处理程序；如果是 <strong>false</strong>（不写默认就是false），表示在<strong>事件冒泡阶段</strong>调用事件处理<br>程序。</li><li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ul><p>DOM 事件流会经历3个阶段：</p><ol><li><p>捕获阶段</p><p>由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段</p><p>事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程</p><p><img src="https://img-blog.csdnimg.cn/20200605101429216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h3 id="4-4事件对象"><a href="#4-4事件对象" class="headerlink" title="4.4事件对象"></a>4.4事件对象</h3><div class="hljs"><pre><code class="hljs js">eventTarget.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125; eventTarget.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;） <span class="hljs-comment">// 这个 event 就是事件对象</span></code></pre></div><p>官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。<br>简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法。</p><p><strong>事件对象本身的获取存在兼容问题：</strong></p><ol><li><p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p></li><li><p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。<br>解决:<br>e = e || window.event;</p><p>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。<br>只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);    div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;            <span class="hljs-comment">// 事件对象</span>            e = e || <span class="hljs-built_in">window</span>.event;            <span class="hljs-built_in">console</span>.log(e);    &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div></li></ol><p><strong>事件对象的属性和方法</strong></p><p><img src="https://img-blog.csdnimg.cn/202006051021537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>e.target 和 this 的区别</strong>：<br><strong>this</strong> 是<strong>事件绑定的元素</strong>， 这个函数的调用者（绑定这个事件的元素）<br><strong>e.target</strong> 是<strong>事件触发的元素</strong>。</p><p>通常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），这时候this指向的是父元素，因为它是绑定事件的元素对象，而target指向的是子元素，因为他是触发事件的那个具体元素对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//事件冒泡下的e.target和this</span>&lt;ul&gt;    &lt;li&gt;abc&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">    &lt;li&gt;abc&lt;/</span>li&gt;    &lt;li&gt;abc&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">&lt;/u</span>l&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);    ul.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;          <span class="hljs-comment">// 我们给ul 绑定了事件  那么this 就指向ul  </span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// ul</span>          <span class="hljs-comment">// e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li</span>          <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// li</span>    &#125;);&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h3 id="4-5阻止默认行为"><a href="#4-5阻止默认行为" class="headerlink" title="4.5阻止默认行为"></a>4.5阻止默认行为</h3><blockquote><p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p></blockquote><div class="hljs"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">"http://www.baidu.com"</span>&gt;百度&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">    /</span><span class="hljs-regexp">/阻止默认行为 让链接不跳转 </span><span class="hljs-regexp">    var a = document.querySelector('a');</span><span class="hljs-regexp">    a.addEventListener('click', function(e) &#123;</span><span class="hljs-regexp">         e.preventDefault(); /</span><span class="hljs-regexp">/  dom 标准写法</span><span class="hljs-regexp">    &#125;);</span><span class="hljs-regexp">   /</span><span class="hljs-regexp">/传统的注册方式</span><span class="hljs-regexp">    a.onclick = function(e) &#123;</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 普通浏览器 e.preventDefault();  方法</span><span class="hljs-regexp">        e.preventDefault();</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 低版本浏览器 ie678  returnValue  属性</span><span class="hljs-regexp">        e.returnValue = false;</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 我们可以利用return false 也能阻止默认行为 没有兼容性问题</span><span class="hljs-regexp">        return false;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre></div><h3 id="4-6阻止事件冒泡"><a href="#4-6阻止事件冒泡" class="headerlink" title="4.6阻止事件冒泡"></a>4.6阻止事件冒泡</h3><ul><li>标准写法：利用事件对象里面的 stopPropagation()方法<br>e.stopPropagation()</li><li>非标准写法：IE 6-8 利用事件对象 cancelBubble 属性<br>e.cancelBubble = true;</li></ul><h3 id="4-7事件委托"><a href="#4-7事件委托" class="headerlink" title="4.7事件委托"></a>4.7事件委托</h3><p>事件委托也称为事件代理,通俗的讲就是不给子元素注册事件，<strong>给父元素注册事件</strong>，把处理代码在父元素的事件中执行。</p><p><strong>事件委托的原理</strong><br>给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p><p><strong>事件委托的作用</strong></p><ul><li>只操作了一次 DOM ，提高了程序的性能。</li><li>动态新创建的子元素，也拥有事件。</li></ul><h3 id="4-8鼠标事件"><a href="#4-8鼠标事件" class="headerlink" title="4.8鼠标事件"></a>4.8鼠标事件</h3><p><img src="https://img-blog.csdnimg.cn/20200605103724655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>1.禁止鼠标右键菜单</p><p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'contextmenu'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.preventDefault();&#125;)</code></pre></div><p>2.禁止鼠标选中（selectstart 开始选中）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'selectstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.preventDefault();&#125;)</code></pre></div><p><strong>鼠标事件对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200605103724703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></p><h3 id="4-9键盘事件"><a href="#4-9键盘事件" class="headerlink" title="4.9键盘事件"></a>4.9键盘事件</h3><p><img src="https://img-blog.csdnimg.cn/20200605105020906.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 常用的键盘事件</span>    <span class="hljs-comment">//1. keyup 按键弹起的时候触发 </span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我弹起了'</span>);    &#125;)    <span class="hljs-comment">//3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我按下了press'</span>);    &#125;)    <span class="hljs-comment">//2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我按下了down'</span>);    &#125;)    <span class="hljs-comment">// 4. 三个事件的执行顺序  keydown -- keypress -- keyup</span>&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p><strong>键盘事件对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200605105350505.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200605105351133.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>使用keyCode属性判断用户按下哪个键</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'up:'</span> + e.keyCode);        <span class="hljs-comment">// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</span>        <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">65</span>) &#123;            alert(<span class="hljs-string">'您按下的a键'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(<span class="hljs-string">'您没有按下a键'</span>)        &#125;    &#125;)    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// console.log(e);</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'press:'</span> + e.keyCode);    &#125;)&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="5-JS-执行机制"><a href="#5-JS-执行机制" class="headerlink" title="5.JS 执行机制"></a>5.JS 执行机制</h2><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步任务都在主线程上执行，形成一个执行栈。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>JS 的异步是通过回调函数实现的。<br>一般而言，异步任务有以下三种类型:<br>1、普通事件，如 click、resize 等<br>2、资源加载，如 load、error 等<br>3、定时器，包括 setInterval、setTimeout 等<br>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。</p><h3 id="JS执行步骤"><a href="#JS执行步骤" class="headerlink" title="JS执行步骤"></a><strong>JS执行步骤</strong></h3><ol><li><strong>先执行</strong>执行栈中的<strong>同步任务</strong>。</li><li><strong>异步任务</strong>（回调函数）放入<strong>任务队列</strong>中。</li><li>一旦执行栈中的所有<strong>同步任务执行完毕</strong>，系统就会按次序<strong>读取</strong>任务队列中的<strong>异步任务</strong>，于是被读取的异步任务结束等待状态，<strong>进入执行栈</strong>，开始<strong>执行</strong>。<br><img src="https://img-blog.csdnimg.cn/20200605111242706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础语法</title>
    <link href="/2020/06/03/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/06/03/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200602233705724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>JS 脚本语言–编程类语言</strong></p><p>一种运行在客户端的脚本语言 （Script 是脚本的意思）<br>作用：实现业务逻辑和页面控制( 决定功能 )</p><p><strong>浏览器怎么执行 JS</strong></p><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）<br><strong>渲染引擎</strong>：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit<br><strong>JS 引擎</strong>：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8<br>浏览器本身并不会执行JS代码，而是通过内置 JS 引擎来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行</p><h2 id="JS-的组成"><a href="#JS-的组成" class="headerlink" title="JS 的组成"></a>JS 的组成</h2><h3 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1.ECMAScript"></a>1.ECMAScript</h3><p>JS是 ECMAScript 语言的实现和扩展，ECMAScript 规定了JS的编程语法和基础核心知识</p><h3 id="2-DOM（页面文档对象模型）"><a href="#2-DOM（页面文档对象模型）" class="headerlink" title="2.DOM（页面文档对象模型）"></a>2.DOM（页面文档对象模型）</h3><p>是W3C组织推荐的处理可扩展标记语言的标准编程接口。<br>通过 DOM 提供的接口可以对页面上的各种元素进行操作</p><h3 id="3-BOM（浏览器对象模型）"><a href="#3-BOM（浏览器对象模型）" class="headerlink" title="3.BOM（浏览器对象模型）"></a>3.BOM（浏览器对象模型）</h3><p>它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。<br>通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>通俗：变量是用于存放数据的容器<br>本质：变量是程序在内存中申请的一块用来存放数据的空间</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>1.声明变量<br><code>var age; // 声明一个 名称为age 的变量</code><br><strong>var</strong> 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间<br><strong>age</strong> 是定义的变量名，我们要通过变量名来访问内存中分配的空间</p><p>2.赋值<br><code>age = 10; // 给 age 这个变量赋值为 10</code><br><strong>=</strong> 用来把右边的值赋给左边的变量空间中<br>变量值是保存到变量空间里的值<br>3.变量的初始化<br><code>var age = 18; // 声明变量同时赋值为 18</code><br><strong>声明一个变量并赋值， 我们称之为变量的初始化。</strong></p><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ol><li>必须以字母(A-Za-z)、下划线(_)、美元符号( $ )开头，后续的字符也可以是数字（0-9）。如：usrAge, num01, _name</li><li>严格区分大小写。var app; 和 var App; 是两个变量</li><li>不能以数字开头。 18age 是错误的</li><li>不能是关键字、保留字。例如：var、for、while</li><li>变量名必须有意义。</li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="8种数据类型"><a href="#8种数据类型" class="headerlink" title="8种数据类型"></a>8种数据类型</h3><ul><li><p>基本数据类型（值类型/简单数据类型）</p><p>在存储时变量中存储的是值本身,值类型变量的数据直接存放在变量（<strong>栈空间</strong>）中</p><p><strong>简单类型传参</strong><br>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><ul><li><p>Number</p><p>既可以用来保存整数值，也可以保存小数(浮点数）<br>数字型三个特殊值</p><div class="hljs"><pre><code class="hljs js">alert(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity </span>alert(-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// -Infinity </span>alert(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// NaN</span></code></pre></div><p>Infinity ，代表无穷大，大于任何数值<br>-Infinity ，代表无穷小，小于任何数值<br>NaN ，Not a number，代表一个非数值<br><strong>isNaN()</strong> 用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li><li><p>String</p><p>字符串型是一串表示文本值的字符序列，其语法为 双引号 “” 和 单引号’’</p><p>因为 <strong>HTML 标签</strong>里面的属性使用的是<strong>双引号</strong>，<strong>JS</strong> 这里我们更推荐使用<strong>单引号</strong>。</p><p>字符串引号嵌套<br>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)<br><strong>字符串转义符</strong><br>转义符都是 \ 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n 是 newline 的意思</td></tr><tr><td>\ \</td><td>斜杠 \</td></tr><tr><td>&#39;</td><td>‘ 单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b 是 blank 的意思</td></tr></tbody></table><p>字符串长度<br>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <strong>length</strong> 属性可以获取整个字符 串的长度。<br><strong>字符串拼接</strong><br>多个字符串之间可以使用 <strong>+</strong> 进行拼接，其拼接方式为 <strong>字符串 + 任何类型 = 拼接之后的新字符串</strong><br>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1.1 字符串 "相加" </span>alert(<span class="hljs-string">'hello'</span> + <span class="hljs-string">' '</span> + <span class="hljs-string">'world'</span>); <span class="hljs-comment">// hello world </span><span class="hljs-comment">//1.2 数值字符串 "相加" </span>alert(<span class="hljs-string">'100'</span> + <span class="hljs-string">'100'</span>); <span class="hljs-comment">// 100100 </span><span class="hljs-comment">//1.3 数值字符串 + 数值 </span>alert(<span class="hljs-string">'11'</span> + <span class="hljs-number">12</span>); <span class="hljs-comment">// 1112</span></code></pre></div><p>口诀：数值相加 ，字符相连<br><strong>字符串拼接加强</strong><br>我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值<br><strong>变量是不能添加引号的，因为加引号的变量会变成字符串</strong><br>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</p></li><li><p>Boolean<br>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。<br>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2 </span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span></code></pre></div></li><li><p>Undefined</p><p>undefined表示“缺少值”，此处应该有一个值，只是声明后没有被赋值</p></li><li><p>Null</p><p>表示“没有对象”，即该处里面存的值为空</p></li><li><p>BigInt</p><p>是一种数字数据类型，可以以任意精度格式表示整数</p></li><li><p>Symbol</p><p>Symbol可以用来创建唯一常量</p></li></ul></li><li><p>引用类型/复杂数据类型：对象（Object）</p><p>在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型</p><p>通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</p><p><strong>引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</strong></p><p><strong>复杂类型传参</strong></p><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p></li></ul><h3 id="获取变量数据类型"><a href="#获取变量数据类型" class="headerlink" title="获取变量数据类型"></a>获取变量数据类型</h3><ul><li>typeof 检测变量的数据类型，返回一个字符串</li><li>字面量是脚本中按字面意思给出的固定的值，而不是变量。（译注：字面量是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false，3.1415</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。</p><ul><li><p>转换为字符串</p><p><strong>toString()</strong><br><code>var num= 1；num.toString()；</code><br>String() 强制转化<br><code>var num =1;String(num);</code><br><strong>加号拼接字符串</strong><br>和字符串拼接的结果都是字符串<br>三种转换方式，第三种加号拼接字符串转换方式也称之为<strong>隐式转换</strong>。</p></li><li><p>转换为数字型（重点）</p><p><strong>1.parseInt()</strong><br>将string类型转成<strong>整数数值型</strong><br><strong>2.parseFloat()</strong><br>将string类型转成<strong>浮点数数值型</strong><br>3.Number()强制转换函数<br>将string类型转成数值型<br>4.js隐式转化（- * /）<br>利用算术运算隐式转换成数值型<br>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</p></li><li><p>转换为布尔型</p><p>Boolean()函数 其它类型转换成布尔值<br>代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined ,其余值都会被转换为 true</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算使用的符号，用于执行两个变量或值的算术运算</p><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>前置递增运算符<br><strong>++num</strong> 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。<br>使用口诀：<strong>先自加，后返回值</strong><br>后置递增运算符<br><strong>num++</strong> 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。<br>使用口诀：<strong>先返回原值，后自加</strong></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值</p><ul><li><p>逻辑与 <strong>&amp;&amp;</strong><br>两边都是 true才返回 true，否则返回 false</p></li><li><p>逻辑或 <strong>||</strong><br>两边都为 false 才返回 false，否则都为true</p></li><li><p>逻辑非 <strong>！</strong><br>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p></li><li><p>短路运算（逻辑中断）<br>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p><ul><li><p>逻辑与<br> 语法： 表达式1 &amp;&amp; 表达式2<br> 如果第一个表达式的值为真，则返回表达式2<br> 如果第一个表达式的值为假，则返回表达式1</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 0 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>&amp;&amp; <span class="hljs-number">789</span> ); <span class="hljs-comment">// 789</span></code></pre></div></li><li><p>逻辑或<br> 语法： 表达式1 || 表达式2<br> 如果第一个表达式的值为真，则返回表达式1<br> 如果第一个表达式的值为假，则返回表达式2</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 123 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> || <span class="hljs-number">789</span> ); <span class="hljs-comment">// 123</span></code></pre></div></li></ul></li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>用来把数据赋值给变量的运算符。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制就是来控制我们的代码按照什么结构顺序来执行</p><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果<br><strong>if 语句</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立执行代码，否则什么也不做 </span><span class="hljs-keyword">if</span> (条件表达式) &#123; <span class="hljs-comment">// 条件成立执行的代码语句 </span>&#125;</code></pre></div><p>语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，<br><strong>if else语句（双分支语句）</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立 执行 if 里面代码，否则执行else 里面的代码 </span><span class="hljs-keyword">if</span> (条件表达式) &#123; <span class="hljs-comment">// [如果] 条件成立执行的代码 </span>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [否则] 执行的代码 </span>&#125;</code></pre></div><p><strong>if else if 语句(多分支语句)</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 适合于检查多重条件。 </span><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123; 语句<span class="hljs-number">1</span>； &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123; 语句<span class="hljs-number">2</span>； &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123; 语句<span class="hljs-number">3</span>； .... &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 上述条件都不成立执行此处代码 </span>&#125;</code></pre></div><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式</p><ol><li>语法结构<br>表达式1 ? 表达式2 : 表达式3;</li><li>执行思路<ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于 if else （双分支） 的简写</li></ul></li></ol><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句也是多分支语句，它用于基于<strong>不同的条件来执行不同的代码</strong>。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>( 表达式 )&#123; <span class="hljs-keyword">case</span> value1: <span class="hljs-comment">// 表达式 等于 value1 时要执行的代码 </span><span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> value2: <span class="hljs-comment">// 表达式 等于 value2 时要执行的代码 </span><span class="hljs-keyword">break</span>; <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 表达式 不等于任何一个 value 时要执行的代码 </span>&#125;</code></pre></div><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3><h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">while</span>语句的语法结构如下：<span class="hljs-keyword">while</span> (条件表达式) &#123;  <span class="hljs-comment">// 循环体代码 </span>&#125;</code></pre></div><p>执行思路：</p><ol><li><p>先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</p></li><li><p>执行循环体代码</p></li><li><p>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</p><p>注意：使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</p></li></ol><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3.do-while循环"></a>3.do-while循环</h3><p>do… while 语句的语法结构如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span>&#125; <span class="hljs-keyword">while</span>(条件表达式);</code></pre></div><p>执行思路:</p><ol><li>先执行一次循环体代码</li><li>再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码<br>注意：<strong>先再执行循环体，再判断</strong>，do…while循环语句至少会执行一次循环体代码</li></ol><h3 id="continue、break"><a href="#continue、break" class="headerlink" title="continue、break"></a>continue、break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。<br>break 关键字用于立即跳出整个循环（循环结束）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul><li><p>new 创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 数组名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() ； <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">// 创建一个新的空数组</span></code></pre></div><p>注意 Array () ，A 要大写</p></li><li><p>数组字面量创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1. 使用数组字面量方式创建空的数组 </span><span class="hljs-keyword">var</span> 数组名 = []； <span class="hljs-comment">//2. 使用数组字面量方式创建带初始值的数组 </span><span class="hljs-keyword">var</span> 数组名 = [<span class="hljs-string">'小白'</span>,<span class="hljs-string">'小黑'</span>,<span class="hljs-string">'大黄'</span>,<span class="hljs-string">'瑞奇'</span>];</code></pre></div><p> 数组的字面量是方括号 [ ]<br> 声明数组并赋值称为数组的初始化</p></li></ul><h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><p>数组可以通过索引来访问、设置、修改对应的数组元素，我们可以通过“数组名[索引]”的形式来获取数组中的元素。</p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>我们可以通过 for 循环索引遍历数组中的每一项<br><strong>数组的长度</strong> 使用“数组名.length”可以访问数组元素的数量（数组长度）。</p><h3 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h3><p>1.通过修改 length 长度新增数组元素<br>2.通过修改数组索引新增数组元素</p><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]; arr[<span class="hljs-number">4</span>] = <span class="hljs-string">'hotpink'</span>; <span class="hljs-built_in">console</span>.log(arr);</code></pre></div><p>这种方式也是我们最常用的一种方式。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数：就是封装了一段可被重复调用执行的代码块</p><h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><ul><li><p>声明函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//函数体代码 </span>&#125;</code></pre></div><p> function 是声明函数的关键字,必须小写<br> 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p></li><li><p>调用函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 调用函数 </span>函数名(); <span class="hljs-comment">// 通过调用函数名来执行函数体代码</span></code></pre></div><p> 调用的时候千万不要忘记添加小括号<br> 口诀：函数不调用，自己不执行。<br>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p></li></ul><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p><strong>形参和实参</strong><br>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时,同样也需要传递相应的参数，这些参数被称为实参。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 带参数的函数声明 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2</span> , 形参<span class="hljs-number">3.</span>..</span>) </span>&#123; <span class="hljs-comment">// 可以定义任意多的参数，用逗号分隔 </span><span class="hljs-comment">// 函数体 </span>&#125; <span class="hljs-comment">// 带参数的函数调用 </span>函数名(实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2</span>, 实参<span class="hljs-number">3.</span>..);</code></pre></div><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ul><li><p>return 语句</p><p>函数将值返回给调用者，此时通过使用 return 语句就可以实现<br>return 语句的语法格式如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名（）</span>&#123; ... <span class="hljs-keyword">return</span> 需要返回的值； &#125; <span class="hljs-comment">// 调用函数 </span>函数名(); <span class="hljs-comment">// 此时调用函数就可以得到函数体内return 后面的值</span></code></pre></div><p>return 语句之后的代码不被执行<br>return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。</p><p><strong>break ,continue ,return 的区别</strong><br>break ：结束当前的循环体（如 for、while）<br>continue ：跳出本次循环，继续执行下次循环（如 for、while）<br>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</p></li></ul><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。</p><p>所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><p>arguments展示形式是一个<strong>伪数组</strong>，因此可以进行遍历。伪数组具有以下特点：<br> 具有 length 属性<br> 按索引方式储存数据<br> 不具有数组的 push , pop 等方法</p><h3 id="函数的声明方式"><a href="#函数的声明方式" class="headerlink" title="函数的声明方式"></a>函数的声明方式</h3><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明定义方式 </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;...&#125; <span class="hljs-comment">// 调用 </span>fn();</code></pre></div><p> 因为有名字，所以也被称为命名函数<br> 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</p></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 这是函数表达式写法，匿名函数后面跟分号结束 </span><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;； <span class="hljs-comment">// 调用的方式，函数调用必须写到函数体下面 </span>fn();</code></pre></div><p> 因为函数没有名字，所以也被称为匿名函数<br> 这个fn 里面存储的是一个函数<br> 函数表达式方式原理跟声明变量方式是一致的<br> <strong>函数调用的代码必须写到函数体后面</strong></p></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。</p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块作用域由 { } 包括（es6）</p><h3 id="变量作用域的分类"><a href="#变量作用域的分类" class="headerlink" title="变量作用域的分类"></a>变量作用域的分类</h3><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p><ul><li><p>全局变量</p><ul><li>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</li><li>全局变量在代码的任何位置都可以使用</li><li>特殊情况下，在函数内不使用全局变量（不建议使用）</li></ul></li><li><p>局部变量</p><ul><li>在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</li><li>局部变量只能在该函数内部使用</li><li>函数的形参实际上就是局部变量</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>采取就近原则的方式来查找变量最终的值。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。<br><strong>预解析</strong>：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和function 声明的变量在内存中进行提前声明或者定义。<br><strong>代码执行</strong>： 从上到下执行JS语句。</p><p>预解析也叫做变量（函数）提升。</p><h3 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h3><p>变量提升： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升</p><h3 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h3><p>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。<br><strong>对象是由属性和方法组成的</strong>。<br>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>字面量创建对象</p><p>对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>{ }</strong> 里面采取<strong>键值对</strong>的形式表示<br>键：相当于属性名<br>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p><strong>对象的调用</strong></p><ul><li>对象里面的属性调用 : <strong>对象.属性名</strong></li><li>对象里面属性的另一种调用方式 : <strong>对象[‘属性名’]</strong>，注意方括号里面的属性必须加引号</li><li>对象里面的<strong>方法调用</strong>：<strong>对象.方法名()</strong> ，注意这个方法名字后面一定加括号</li></ul></li><li><p>new Object创建对象</p><p>Object() ：第一个字母大写<br>new Object() ：需要 new 关键字<br>使用格式：对象.属性 = 值;</p></li><li><p>构造函数创建对象</p><p><strong>构造函数</strong> ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起 使用。我们可以把<strong>对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面</strong>。</p><p>在 js 中，使用构造函数要时要注意以下几点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li><li>构造函数中不需要 return 返回结果。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ul><p><strong>构造函数</strong>，如 Stars()，抽象了<strong>对象的公共部分</strong>，<strong>封装</strong>到了<strong>函数</strong>里面，它泛指<strong>某一大类</strong>（class）<br><strong>创建对象</strong>，如 new Stars()，特指<strong>某一个</strong>，通过 new 关键字创建对象的过程也称为<strong>对象实例化</strong></p></li></ul><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>new 在执行时会做四件事情：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要return）。</li></ol><h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p><p>for (变量 in 对象名字) {<br>// 在此执行代码<br>}</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="1-Math-对象"><a href="#1-Math-对象" class="headerlink" title="1.Math 对象"></a>1.Math 对象</h3><p><strong>随机数方法 random()</strong><br>random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1</p><p>案例：得到一个两数之间的随机整数，包括两个数在内</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">min, max</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min; &#125;</code></pre></div><p><strong>Math 对象不是构造函数</strong>，具有数学常数和函数的属性和方法<br>Math.PI // 圆周率<br><strong>Math.floor()</strong> // 向下取整<br>Math.ceil() // 向上取整<br>Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3<br><strong>Math.abs()</strong> // 绝对值<br><strong>Math.max()/Math.min()</strong> // 求最大和最小值</p><h3 id="2-日期对象"><a href="#2-日期对象" class="headerlink" title="2.日期对象"></a>2.日期对象</h3><ol><li>获取当前时间必须实例化<br>var now = new Date();<br>console.log(now);</li><li>Date() 构造函数的参数<br><strong>如果括号里面有时间，就返回参数里面的时间</strong>。例如日期格式字符串为‘2019-5-1’，可以写成new Date(‘2019-5-1’) 或者 new Date(‘2019/5/1’)<br>如果Date()不写参数，就返回当前时间</li><li>使用Date实例的方法和属性<br><img src="https://img-blog.csdnimg.cn/20200602234800746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>获取日期的总的毫秒形式<br>Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数</li></ol><p><strong>Date 对象</strong>和 Math 对象不一样，<strong>是一个构造函数</strong>，所以<strong>需要实例化</strong>后才能使用<br>Date 实例用来处理日期和时间</p><h3 id="3-数组对象"><a href="#3-数组对象" class="headerlink" title="3.数组对象"></a>3.数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li><p>字面量方式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>,<span class="hljs-literal">true</span>];</code></pre></div></li><li><p>new Array()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</code></pre></div><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li><p>如果只传入一个参数，则参数规定了数组的长度</p></li><li><p>如果传入了多个参数，则参数称为数组的元素</p></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li><p><strong>instanceof 运算符</strong>，可以判断一个对象是否属于某种类型</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span></code></pre></div></li><li><p>Array.isArray()</p><p>用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr));   <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(obj));   <span class="hljs-comment">// false</span></code></pre></div></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234205992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>数组中有对数组本身排序的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234332535.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：sort方法需要传入参数来设置升序、降序排序</p><ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234519153.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234554828.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><img src="https://img-blog.csdnimg.cn/20200602234613578.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="4-字符串对象"><a href="#4-字符串对象" class="headerlink" title="4.字符串对象"></a>4.字符串对象</h3><ul><li><p>基本包装类型</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><p>js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'andy'</span>);<span class="hljs-comment">// 2. 赋值给我们声明的字符变量</span>str = temp;<span class="hljs-comment">// 3. 销毁临时变量</span>temp = <span class="hljs-literal">null</span>;</code></pre></div></li><li><p>字符串的不可变</p><ul><li>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</li></ul></li><li><p>根据字符返回位置</p><p>字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235548446.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>根据位置返回字符</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235521853.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>字符串操作方法</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：<br><img src="https://img-blog.csdnimg.cn/20200602235609516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>replace()方法</p><ul><li>replace() 方法用于在字符串中用一些字符替换另一些字符。<br>其使用格式如下：<br><code>replace(被替换的字符串， 要替换为的字符串)；</code></li></ul></li><li><p>split()方法</p><ul><li>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。<br>例如下面代码：<br><code>var str = &#39;a,b,c,d&#39;;</code><br><code>console.log(str.split(&#39;,&#39;)); // 返回的是一个数组 [a, b, c, d]</code></li></ul></li></ul><h2 id="JavaScript-输入输出语句"><a href="#JavaScript-输入输出语句" class="headerlink" title="JavaScript 输入输出语句"></a>JavaScript 输入输出语句</h2><h3 id="alert-msg"><a href="#alert-msg" class="headerlink" title="alert(msg)"></a>alert(msg)</h3><p>浏览器弹出警示框</p><h3 id="console-log-msg"><a href="#console-log-msg" class="headerlink" title="console.log(msg)"></a>console.log(msg)</h3><p>浏览器控制台打印输出信息</p><h3 id="prompt-info"><a href="#prompt-info" class="headerlink" title="prompt(info)"></a>prompt(info)</h3><p>浏览器弹出输入框，用户可以输入</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件化开发——学习笔记二</title>
    <link href="/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组件化基本介绍"><a href="#组件化基本介绍" class="headerlink" title="组件化基本介绍"></a>组件化基本介绍</h3><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ol><li>将一个完整的页面分成很多个组件。</li><li>每个组件都用于实现页面的一个功能块。</li><li>而每一个组件又可以进行细分。</li></ol><h4 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a><strong>Vue组件化思想</strong></h4><ul><li>提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树。<br><img src="https://img-blog.csdnimg.cn/20200530111834826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p>组件化思想的应用：</p><ul><li>尽可能的将页面拆分成一个个小的、可复用的组件。</li><li>让我们的代码更加方便组织和管理，并且扩展性也更强。</li></ul><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a><strong>注册组件</strong></h3><h4 id="组件的使用分成三个步骤"><a href="#组件的使用分成三个步骤" class="headerlink" title="组件的使用分成三个步骤"></a>组件的使用分成三个步骤</h4><p><img src="https://img-blog.csdnimg.cn/20200530112014942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.创建组件构造器</strong></p><p><strong>Vue.extend()：</strong></p><ol><li>调用Vue.extend()创建的是一个组件构造器。</li><li>通常在创建组件构造器时，传入template代表我们自定义组件的模板。</li><li>该模板就是在使用到组件的地方，显示HTML代码。</li></ol><p><strong>2.注册组件</strong></p><p><strong>Vue.component()：</strong></p><p>调用Vue.component()是将组件构造器注册为一个组件，并且给它起一个组件的标签名称。</p><p>需要传递两个参数：1、注册组件的标签名 2、组件构造器</p><p><strong>3.使用组件</strong></p><p>组件必须挂载在某个Vue实例下，否则它不会生效。</p><h4 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h4><p>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p><h4 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h4><p>Vue提供了两种方案来定义HTML模块内容：</p><ul><li>使用<code>&lt;script&gt;</code>标签</li><li>使用<code>&lt;template&gt;</code>标签</li></ul><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a><strong>全局组件和局部组件</strong></h3><p><strong>全局组件</strong></p><p>调用Vue.component()注册组件时，组件的注册是全局的,意味着该组件可以在任意Vue示例下使用</p><p><strong>局部组件</strong></p><p>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p><h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a><strong>父组件和子组件</strong></h3><h4 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h4><p><img src="https://img-blog.csdnimg.cn/20200530112106840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.父子组件间传递数据</strong></p><ul><li><p><strong>父组件向子组件传递（通过props）</strong></p><p>在组件中，使用选项props来声明需要从父级接收到的数据</p><p>props的值有两种方式：</p><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p><p>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</p><p><strong>props数据验证</strong></p><p>当需要对props进行类型等验证时，就需要使用对象写法。</p><p>验证都支持哪些数据类型呢？</p><ul><li><p>String</p></li><li><p>Number</p></li><li><p>Boolean</p></li><li><p>Array</p></li><li><p>Object</p></li><li><p>Date</p></li><li><p>Function</p></li><li><p>Symbol</p></li><li><p>自定义函数</p><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component'</span>, &#123;  props: &#123;<span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span>propA: <span class="hljs-built_in">Number</span>,<span class="hljs-comment">// 多个可能的类型</span>propB: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],<span class="hljs-comment">// 必填的字符串</span>propC: &#123;  type: <span class="hljs-built_in">String</span>,  required: <span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">// 带有默认值的数字</span>propD: &#123;  type: <span class="hljs-built_in">Number</span>,  <span class="hljs-keyword">default</span>: <span class="hljs-number">100</span>&#125;,<span class="hljs-comment">// 带有默认值的对象</span>propE: &#123;  type: <span class="hljs-built_in">Object</span>,  <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span>  <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span> &#125;    &#125;&#125;,<span class="hljs-comment">// 自定义验证函数</span>propF: &#123;  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">'success'</span>, <span class="hljs-string">'warning'</span>, <span class="hljs-string">'danger'</span>].indexOf(value) !== <span class="hljs-number">-1</span>  &#125;&#125;&#125;&#125;)</code></pre></div></li></ul></li></ul><p>注意这些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。</p><ul><li><strong>子组件向父组件传递（自定义事件）</strong></li></ul><p>​ 自定义事件的流程：</p><ol><li>在<strong>子组件</strong>中，通过<strong>$emit()</strong>来触发事件。</li><li>在<strong>父组件</strong>中，通过<strong>v-on</strong>来监听子组件事件。</li></ol><p><strong>2.父子组件的访问方式</strong></p><ul><li><p><strong>父组件访问子组件（使用$children或$refs）</strong></p><p>$children的访问</p><p>this.$children是一个数组类型，它包含所有子组件对象。</p><p>$children的<strong>缺陷</strong>：</p><ol><li>通过<strong>$children</strong>访问子组件时，是一个<strong>数组类型</strong>，<strong>访问其中的子组件</strong>必须通过<strong>索引值</strong>。</li><li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</li><li>有时候，我们想明确获取其中一个<strong>特定的组件</strong>，这个时候就可以使用<strong>$refs</strong></li></ol><p><strong>$refs的使用</strong>：</p><ul><li>$refs和<strong>ref指令</strong>通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过<strong>this.$refs.ID</strong>就可以访问到该组件了。</li></ul></li><li><p><strong>子组件访问父组件（使用$parent）</strong></p><p>真实开发中尽量不要使用</p></li></ul><h3 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a>组件数据存放</h3><p><strong>组件中不能直接访问Vue实例中的data数据</strong></p><p>组件自己的数据存放在哪里呢?</p><ul><li>组件对象也有一个data属性(也可以有methods等属性)</li><li>只是这个data属性必须是一个<strong>函数</strong></li><li>而且这个函数需要<strong>返回</strong>一个<strong>对象</strong>，对象内部保存着数据</li></ul><p>为什么data在组件中必须是一个函数呢?</p><p>首先，如果不是一个函数，Vue直接就会报错。</p><p>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</p><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a><strong>编译作用域</strong></h4><p>官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p>组件的插槽：</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li><li>让使用者可以决定组件内部到底展示什么内容。</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><p>如何使用slot？</p><p>在子组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为子组件开启一个插槽。</p><p>该插槽插入什么内容取决于父组件如何使用</p><h4 id="slot分类"><a href="#slot分类" class="headerlink" title="slot分类"></a><strong>slot分类</strong></h4><p><strong>1.具名插槽slot</strong></p><p>如何使用具名插槽呢？</p><p>非常简单，只要给slot元素一个name属性即可</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'myslot'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></code></pre></div><p><strong>2.作用域插槽</strong></p><p><strong>父组件替换插槽的标签，但是内容由子组件来提供</strong></p><p>可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去，绑定在 <code>&lt;slot&gt;</code>元素上的 attribute 被称为插槽 prop。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span>  &#123;&#123; user.lastName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p>现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>    &#123;&#123; slotProps.user.firstName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre></div><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flex布局</title>
    <link href="/2020/05/31/Flex%E5%B8%83%E5%B1%80/"/>
    <url>/2020/05/31/Flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>该文章是根据阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>和MDN——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">flex布局的基本概念</a>整理得出的。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”<br>任何一个容器都可以指定为 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>行内项目也可以使用 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: inline-flex;&#125;</code></pre></div><p>Webkit 内核的浏览器，必须加上-webkit前缀</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: -webkit-flex; <span class="hljs-comment">/* Safari */</span>  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>注意，设为 Flex 布局以后，容器中的直系子元素就会变为 flex 元素,并且子元素的<strong>float</strong>、<strong>clear</strong>和<strong>vertical-align</strong>属性将失效。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的项目，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="https://img-blog.csdnimg.cn/20200531101024720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li><strong>flex-direction</strong></li></ul><p>flex-direction属性决定主轴的方向（即flex 项目的排列方向）</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</code></pre></div><p>row（默认值）：主轴为水平方向，起点在左端。<br>row-reverse：主轴为水平方向，起点在右端。<br>column：主轴为垂直方向，起点在上沿。<br>column-reverse：主轴为垂直方向，起点在下沿。</p><ul><li><strong>flex-wrap</strong></li></ul><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</code></pre></div><p>1）nowrap（默认）：不换行。<br>2）wrap：换行，第一行在上方。<br>3）wrap-reverse：换行，第一行在下方。</p><ul><li><p><strong>flex-flow</strong></p><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre></div><ul><li><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上（水平方向）的对齐方式。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre></div><p>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔相等。<br>space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</p><ul><li><strong>align-items</strong><br>align-items属性定义项目在交叉轴上（垂直方向）如何对齐</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><ul><li>align-content<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre></div><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>order属性<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></div><ul><li><strong>flex-grow属性</strong><br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></div><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><ul><li><strong>flex-shrink属性</strong><br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-shrink 属性只能是一个 <code>&lt;number&gt;</code>。负值对该属性无效。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></div><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><ul><li><strong>flex-basis属性</strong><br>flex-basis属性定义了项目的空间大小。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p>取值<br>&lt;’width’&gt;<br>width 值可以是<code>&lt;length&gt;</code>; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。<br>content<br>基于 flex 项目的内容自动调整大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 指定&lt;'width'&gt; */</span><span class="hljs-selector-tag">flex-basis</span>: 10<span class="hljs-selector-tag">em</span>;<span class="hljs-selector-tag">flex-basis</span>: 3<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">auto</span>;<span class="hljs-comment">/* 在flex item内容上的自动尺寸 */</span><span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">content</span>;</code></pre></div><p>如果没有给项目设定尺寸，flex-basis 的值采用项目内容的尺寸。这就解释了：我们给只要给Flex项目的容器声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示项目的内容。<br>Note: 当一个项目同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) , flex-basis 具有更高的优先级.</p><ul><li><p><strong>flex属性</strong></p><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">'flex-grow'</span>&gt; &lt;<span class="hljs-string">'flex-shrink'</span>&gt;? || &lt;<span class="hljs-string">'flex-basis'</span>&gt; ]&#125;</code></pre></div><p>下面是几种预定义的值：<br><strong>flex: initial</strong><br>把flex项目重置为Flexbox的初始值，它相当于 <strong>flex: 0 1 auto</strong>。</p><p>解析：flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p>​ flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​ flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p><strong>flex: auto</strong><br>flex: auto 等同于 <strong>flex: 1 1 auto</strong>；这种情况下，flex项目在需要的时候既可以拉伸也可以收缩</p><p>解析：所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</p><p>​ flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​ flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><p><strong>flex: none</strong><br>flex: none 可以把flex项目设置为不可伸缩。它和设置为 <strong>flex: 0 0 auto</strong> 是一样的。项目既不能拉伸或者收缩，但是项目会按具有 flex-basis: auto 属性的flexbox进行布局。</p><ul><li>align-self属性<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    
    <categories>
      
      <category>flex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js学习笔记一</title>
    <link href="/2020/05/28/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2020/05/28/Vue.js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="Vue-js介绍"><a href="#Vue-js介绍" class="headerlink" title="Vue.js介绍"></a>Vue.js介绍</h2><h3 id="1-渐进式JavaScript框架"><a href="#1-渐进式JavaScript框架" class="headerlink" title="1.渐进式JavaScript框架"></a><strong>1.渐进式JavaScript框架</strong></h3><p>框架和库的区别：</p><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p></li><li><p>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</p></li></ul><h3 id="2-特点和功能"><a href="#2-特点和功能" class="headerlink" title="2.特点和功能"></a><strong>2.特点和功能</strong></h3><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><h2 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h2><p><img src="https://img-blog.csdnimg.cn/20200529180100715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>View层（视图层）</strong></p><ul><li>前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul><p><strong>Model层（数据层）</strong></p><ul><li>数据可能是固定的死数据，更多的是来自服务器，从网络上请求下来的数据。</li></ul><p><strong>VueModel层（视图模型层）</strong></p><ul><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul><p><strong>后端（Node）中的 MVC 与 前端中的 MVVM 之间的区别</strong></p><ol><li><p>MVC 是后端的分层开发概念；</p></li><li><p>MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM（ViewModel）</p><p><img src="https://img-blog.csdnimg.cn/20200529180156561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h2 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h2><p>1.生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件统称为生命周期</p><p>2.主要的生命周期函数分类：</p><ul><li><p>创建期间的生命周期函数：</p><ul><li><p>beforeCreate：实例对象初始化之后，此时，还没有初始化好 data 和 methods 属性</p></li><li><p>created：实例创建完成后，data和methods都已经被初始化好了</p><p>注：如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作</p></li><li><p>beforeMount：此函数执行的时候，已经完成了模板的编译，但是还没有挂载到页面中，页面并没有内容</p></li><li><p>mounted：Vue实例已经初始化完毕，编译好的HTML挂载到页面，组件脱离创建阶段，进入运行阶段</p><p>注：1.如果要通过插件操作页面的DOM节点，最早要在mounted中进行（一般会做一些ajax请求获取数据，进行数据初始化）</p><p>2.mounted在整个实例中只执行一次</p></li></ul></li><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li></ul></li><li><p>销毁期间的生命周期函数：</p><ul><li><p>beforeDestroy：实例销毁之前执行的钩子，Vue实例已经从运行阶段进入销毁阶段，实例仍然完全可用</p></li><li><p>destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</p><p><img src="https://img-blog.csdnimg.cn/20200529180359828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul></li></ul><h2 id="Vue的模板语法"><a href="#Vue的模板语法" class="headerlink" title="Vue的模板语法"></a>Vue的模板语法</h2><h3 id="插值（Mustache语法：双大括号）"><a href="#插值（Mustache语法：双大括号）" class="headerlink" title="插值（Mustache语法：双大括号）"></a>插值（Mustache语法：双大括号）</h3><p>v-once指令可以让元素和组件只渲染一次，不会随着数据的改变而改变。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-once</span>&gt;</span>这个将不会改变: &#123;&#123; msg &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><h3 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h3><ul><li><p><strong>v-html</strong><br>数据按照HTML格式进行解析，并且显示对应的内容。<br>注：该指令后面往往会跟上一个string类型</p></li><li><p><strong>v-text</strong><br>与Mustache语法相似，都是用于将数据显示在界面中.<br>如果要更新部分的 textContent，需要使用 {{ Mustache }} 插值。<br>v-text指令通常情况下，接受一个string类型</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-text</span>=<span class="hljs-string">"msg"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div></li><li><p>v-pre<br>跳过这个元素和它的子元素的编译过程。可以用来显示原始 Mustache 标签</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-pre</span>&gt;</span>&#123;&#123; this will not be compiled &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div></li><li><p>v-cloak<br>可以隐藏未编译的 Mustache 标签直到实例准备完毕，需要和CSS 规则如 <code>[v-cloak] { display: none }</code> 一起使用</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span> &#123;  <span class="hljs-attribute">display</span>: none;&#125;</code></pre></div><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-cloak</span>&gt;</span>  &#123;&#123; message &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul><p>以上四种指令都与插值相关</p><ul><li><p><strong>v-bind</strong></p><p>作用： <strong>动态绑定属性</strong><br>缩写： <strong>:</strong> （语法糖）<br>用于绑定一个或多个属性值，或者向另一个组件传递props值<br>在开发中，有哪些属性需要动态进行绑定呢？如图片的链接src、网站的链接href、动态绑定一些类、样式等等</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 绑定一个 attribute --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">v-bind:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span><span class="hljs-comment">&lt;!-- 缩写 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">:src</span>=<span class="hljs-string">"imageSrc"</span>&gt;</span></code></pre></div><ul><li><p>绑定class的两种方式</p><ul><li><p>对象语法</p><p>对象语法的含义：class后面跟的是一个对象</p><p>用法一：直接通过{}绑定一个类</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123;'active': isActive&#125;"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><p>用法二：也可以通过判断，传入多个值</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123;'active': isActive, 'line': isLine&#125;"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><p>用法三：和普通的类同时存在，并不冲突<br>注：如果isActive和isLine都为true，那么会有title/active/line三个类</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"&#123;'active': isActive, 'line': isLine&#125;"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><p>用法四：如果过于复杂，可以放在一个methods或者computed中<br>注：classes是一个计算属性</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"classes"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div></li><li><p>数组语法</p><p>数组语法的含义:class后面跟的是一个数组</p><p>用法一：直接通过[ ]绑定一个类</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"['active']"</span>&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><p>用法二：也可以传入多个值</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">“[‘active’,</span> '<span class="hljs-attr">line</span>']"&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div><p>用法三：和普通的类同时存在，并不冲突<br>注：会有title/active/line三个类</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">h2</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"title"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">“[‘active’,</span> '<span class="hljs-attr">line</span>']"&gt;</span>Hello World<span class="hljs-tag">&lt;/<span class="hljs-name">h2</span>&gt;</span></code></pre></div></li></ul></li><li><p>绑定style的两种方式</p><p>可以利用v-bind:style来绑定一些CSS内联样式。<br>在写CSS属性名的时候，比如font-size，我们可以使用<strong>驼峰式 (camelCase)</strong> fontSize 或<strong>短横线分隔</strong> (kebab-case，记得用单引号括起来) ‘font-size’</p><ul><li><p>对象语法</p><p><code>:style=&quot;{color: currentColor, fontSize: fontSize + &#39;px&#39;}&quot;</code><br>style后面跟的是一个对象类型<br>对象的key是CSS属性名称<br>对象的value是具体赋的值，值可以来自于data中的属性</p></li><li><p>数组语法</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-bind:style</span>=<span class="hljs-string">"[baseStyles, overridingStyles]"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><p>style后面跟的是一个数组类型,多个值以，分割即可</p></li></ul></li></ul></li><li><p><strong>v-on</strong></p><p>作用：<strong>绑定事件监听器</strong><br>缩写：<strong>@</strong></p><ul><li><p>v-on参数</p><p>当通过在methods中定义方法，以供@click调用时，需要注意参数问题：<br>情况一：如果该方法不需要额外参数，那么方法后的()可以不添加。<br>注意：如果方法本身中有一个参数，那么会默认将原生事件event参数传递进去<br>情况二：如果需要同时传入某个参数，同时需要event时，可以通过$event传入事件。</p></li><li><p>v-on修饰符</p><p>Vue提供了修饰符来帮助我们方便的处理一些事件：</p><ul><li>.stop - 调用 event.stopPropagation()。</li><li>.prevent - 调用 event.preventDefault()。</li><li>.{keyCode | keyAlias} - 只当事件是从特定键触发时才触发回调。</li><li>.native - 监听组件根元素的原生事件。</li><li>.once - 只触发一次回调。</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-comment">&lt;!-- 停止冒泡 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-comment">&lt;!-- 阻止默认行为 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.prevent</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-comment">&lt;!-- 阻止默认行为，没有表达式 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">submit.prevent</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span><span class="hljs-comment">&lt;!--  串联修饰符 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click.stop.prevent</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span><span class="hljs-comment">&lt;!-- 键修饰符，键别名 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.enter</span>=<span class="hljs-string">"onEnter"</span>&gt;</span><span class="hljs-comment">&lt;!-- 键修饰符，键代码 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">input</span> @<span class="hljs-attr">keyup.13</span>=<span class="hljs-string">"onEnter"</span>&gt;</span><span class="hljs-comment">&lt;!-- 点击回调只会触发一次 --&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">v-on:click.once</span>=<span class="hljs-string">"doThis"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></code></pre></div></li></ul></li><li><p><strong>v-if、v-else-if、v-else</strong></p><p>这三个指令与JavaScript的条件语句if、else、else if类似。<br><strong>Vue的条件指令</strong>可以根据表达式的值在DOM中<strong>渲染或销毁元素或组件</strong></p><p>v-if的原理：<br>v-if后面的条件为false时，对应的元素以及其子元素不会渲染。也就是根本不会有对应的标签出现在DOM中。</p></li><li><p><strong>v-show</strong></p><p>和v-if非常相似，也用于决定一个元素是否渲染<br><strong>v-if和v-show对比</strong><br>v-if和v-show都可以决定一个元素是否渲染，那么开发中我们如何选择呢？<br><strong>v-if</strong>当条件为<strong>false</strong>时，压根<strong>不会有对应的元素在DOM中</strong>。<br><strong>v-show</strong>当条件为<strong>false</strong>时，仅仅是将<strong>元素的display属性设置为none</strong>而已。<br>开发中如何选择呢？<br>当需要在显示与隐藏之间切换很频繁时，使用v-show<br>当只有一次切换时，通过使用v-if</p></li><li><p><strong>v-for</strong></p><p>v-for的语法类似于JavaScript中的for循环。</p><p>官方推荐我们在使用v-for时，给对应的元素或组件添加上一个<strong>:key属性</strong>。<br>key的作用主要是为了高效的更新虚拟DOM</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in items"</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">"item.id"</span>&gt;</span>  &#123;&#123; item.text &#125;&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div></li></ul><ul><li><p>遍历数组</p><p>如果在遍历的过程中，我们需要拿到元素在数组中的索引值呢？<br>语法格式：<code>v-for=(item, index) in items</code><br>其中的index就代表了取出的item在原数组的索引值。</p></li><li><p>遍历对象</p></li></ul><ul><li><p><strong>v-model</strong></p><p>实现表单元素和数据的双向绑定<br><strong>v-model原理</strong><br>v-model其实是一个语法糖，它的背后本质上是包含两个操作：<br>1.v-bind绑定一个value属性<br>2.v-on指令给当前元素绑定input事件</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-model</span>=<span class="hljs-string">"message"</span>&gt;</span>等同于<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">"text"</span> <span class="hljs-attr">v-bind:value</span>=<span class="hljs-string">"message"</span> <span class="hljs-attr">v-on:input</span>=<span class="hljs-string">"message = $event.target.value"</span>&gt;</span></code></pre></div><p>修饰符<br>lazy修饰符：可以让数据在失去焦点或者回车时才会更新：<br>number修饰符：可以让输入框中输入的内容自动转成数字类型<br>trim修饰符：可以过滤内容左右两边的空格</p></li></ul><h2 id="计算属性"><a href="#计算属性" class="headerlink" title="计算属性"></a>计算属性</h2><h3 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>对于任何复杂逻辑，都应当使用计算属性，如要对数据进行一些转化后再显示，或者需要将多个数据结合起来进行显示</p><p>计算属性是写在实例的computed对象中的</p><div class="hljs"><pre><code class="hljs js">computed: &#123;    <span class="hljs-comment">// 计算属性的 getter</span>    reversedMessage: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;      <span class="hljs-comment">// `this` 指向 vm 实例</span>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.message.split(<span class="hljs-string">''</span>).reverse().join(<span class="hljs-string">''</span>)    &#125;</code></pre></div><h3 id="setter和getter"><a href="#setter和getter" class="headerlink" title="setter和getter"></a>setter和getter</h3><p>每个计算属性都包含一个getter和一个setter（不常用）</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>计算属性会进行缓存，如果多次使用时，计算属性只会调用一次</p><p>对比：<br>methods也可以实现相同的功能，不同的是计算属性是基于它们的响应式依赖进行缓存的，相比之下，每当触发重新渲染时，调用方法将总会再次执行该功能的相关函数</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目（仿外卖APP）</title>
    <link href="/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/"/>
    <url>/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>项目:关于外卖业务的前后台分离Web App</strong></p><ul><li>前台应用技术架构为: vue + vuex + vue-router + webpack + ES6；</li><li>核心功能模块:商家, 商品, 购物车, 评论,用户等多个子模块;</li><li>采用模块化、组件化、工程化的模式开发；</li><li>后台使用 mockjs 模拟后台数据接口和API接口;</li></ul><p><strong>项目展示地址(<a href="http://tq07.gitee.io/vue-food" target="_blank" rel="noopener">点击前往</a>)</strong><br><img src="https://img-blog.csdnimg.cn/20200430112702320.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702290.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702280.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>学习心得：</strong></p><p>1) 熟悉一个项目的开发流程<br>2) 学会组件化、模块化、工程化的开发模式<br>3) 掌握使用 vue-cli 脚手架初始化 Vue.js 项目<br>4) 学会模拟 json 后端数据，实现前后端分离开发<br>5) 掌握一些项目优化技巧</p><p><strong>项目中使用的Vue 插件或第三方库</strong></p><ul><li>使用 vue-router 开发单页应用</li><li>使用 axios/vue-resource 与后端进行数据交互</li><li>使用 vuex 管理应用组件状态</li><li>使用 better-scroll/vue-scroller 实现页面滑动效果</li><li>使用 mint-ui 组件库构建界面</li><li>使用 vue-lazyload 实现图片惰加载</li><li>使用 mockjs 模拟后台数据接口</li></ul><p><strong>样式和布局</strong></p><ul><li>使用 stylus 编写模块化的 CSS</li><li>使用 Vue.js 的过渡编写酷炫的交互动画</li></ul><h3 id="项目中遇到的问题（难点）和项目优化方法"><a href="#项目中遇到的问题（难点）和项目优化方法" class="headerlink" title="项目中遇到的问题（难点）和项目优化方法"></a>项目中遇到的问题（难点）和项目优化方法</h3><p>1.解决点击响应延时 0.3s 问题<br>原因：当用户一次点击屏幕之后，浏览器并不能立刻判断用户是否要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。<br>解决方法：利用FastClick，其原理是检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉</p><div class="hljs"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;fastclick&#x2F;1.0.6&#x2F;fastclick.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;      if(&#39;addEventListener&#39; in document)&#123;        document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;          FastClick.attach(document.body);        &#125;,false)      &#125;      if(!window.Promise) &#123;       document.writeln(&#39;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;es6-promise&#x2F;3.2.2&#x2F;es6-promise.min.js&quot; &#39;+&#39;&gt;&#39;+&#39;&lt;&#39;+&#39;&#x2F;&#39;+&#39;script&gt;&#39;);       &#125;    &lt;&#x2F;script&gt;</code></pre></div><p>2.后台应用</p><blockquote><p>后台应用负责处理前台应用提交的请求, 并给前台应用返回 json 数据<br>前台应用负责展现数据, 与用户交互, 与后台应用交互<br>API接口 <a href="https://github.com/bailicangdu/node-elm/blob/master/API.md" target="_blank" rel="noopener">githup上面找的API接口</a></p></blockquote><p>3.封装 ajax 请求模块</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; ajax 请求函数模块import axios from &#39;axios&#39;export default function ajax(url&#x3D;&#39;&#39;,data&#x3D;&#123;&#125;,type&#x3D;&#39;GET&#39;)&#123;    return new Promise(function(resolve, reject)&#123;        &#x2F;&#x2F; 执行axios异步请求        let promise           if (type &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;             &#x2F;&#x2F; 准备 url query 参数数据             let dataStr &#x3D; &#39;&#39; &#x2F;&#x2F;数据拼接字符串             Object.keys(data).forEach(key &#x3D;&gt; &#123;                 dataStr +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;            &#125;)            if (dataStr !&#x3D;&#x3D; &#39;&#39;) &#123;             dataStr &#x3D; dataStr.substring(0, dataStr.lastIndexOf(&#39;&amp;&#39;))             url &#x3D; url + &#39;?&#39; + dataStr             &#125;            &#x2F;&#x2F; 发送 get 请求             promise &#x3D; axios.get(url)         &#125; else &#123;             &#x2F;&#x2F; 发送 post 请求             promise &#x3D; axios.post(url,data)         &#125;        promise.then(response &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用resolve()            resolve(response)         &#125;).catch(error &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用reject()            reject(error)         &#125;)     &#125;)&#125;</code></pre></div><p>4.vuex 应用组件状态<br>vuex 的核心管理对象 <strong>store 对象模块</strong><br>state模块：状态对象<br>mutation type 常量名称模块<br>mutations 模块 ：直接更新state的多个方法的对象<br>actions 模块：通过mutations间接更新state的多个方法的对象</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F;store 对象模块import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;.&#x2F;state&#39;import mutations from &#39;.&#x2F;mutations&#39; import actions from &#39;.&#x2F;actions&#39;import getters from &#39;.&#x2F;getters&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state,  mutations,   actions,  getters,&#125;)</code></pre></div><p>5.模拟(mock)数据/接口<br>利用 mockjs 拦截 ajax 请求, 生成随机数据返回<br><a href="http://mockjs.com/" target="_blank" rel="noopener">mockjs</a></p><p>6.ShopGoods 组件</p><ul><li><p>内部使用了另外 3 个组件<br>a. ShopCart: 购物车组件<br>b. Cart: 购物车操作组件<br>c. Food: 食品详情组件</p></li><li><p>使用第三方库 better-scroll: UI 滑动</p><p>问题：Cart组件在添加食物的时候，第一次增加时, 没有 count，如果直接添加属性并赋值，新添加的属性没有数据劫持==&gt;数据绑定==&gt;更新了数据但界面不变<br>解决方法：Vue.set(food, ‘count’, 1) 给有数据绑定的对象添加指定属性名和值的属性(有绑定)<br>7.项目优化/扩展<br>（1）缓存路由组件对象</p></li></ul><div class="hljs"><pre><code class="hljs plain">&lt;keep-alive&gt; &lt;router-view &#x2F;&gt; &lt;&#x2F;keep-alive&gt;</code></pre></div><p>好处: 复用路由组件对象, 复用路由组件获取的后台数据<br>（2）路由组件懒加载</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; 返回路由组件的函数，只有执行该函数才会加载路由组件，这个函数在请求对应的路由路径时才会执行const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Home.vue&#39;)const Order &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Order.vue&#39;)const Search &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Search.vue&#39;)const Profile &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Profile.vue&#39;)</code></pre></div><p>8.打包文件分析与优化</p><p>1) vue 脚手架提供了一个用于可视化分析打包文件的包 webpack-bundle-analyzer 和配置<br>2) 启用打包可视化: npm run build – –report</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo+github搭建个人博客</title>
    <link href="/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是基于 Node.js 开发的一个静态博客生成器，提供本地实时预览及部署功能。</p><h3 id="1-安装node和npm-或者cnpm"><a href="#1-安装node和npm-或者cnpm" class="headerlink" title="1.安装node和npm (或者cnpm)"></a>1.安装node和npm (或者cnpm)</h3><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p>前两步我之前已经安装过 ，就不详细记述了</p><p><strong>3.1 全局安装hexo</strong></p><div class="hljs"><pre><code class="hljs plain">npm install -g hexo-cli</code></pre></div><p><strong>3.2 安装 Hexo 完成后，在指定的目录执行下列命令，Hexo 将会指定的文件夹中新建所需要的文件</strong></p><div class="hljs"><pre><code class="hljs plain">hexo init blog</code></pre></div><p><strong>3.3 在指定文件夹下，启动本地预览服务</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<span class="hljs-comment"># 启动本地预览服务，默认是 127.0.0.1:4000（简写hexo s）</span>hexo server</code></pre></div><p>也可以参考 Hexo 官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a> , 里面有具体的使用方式。</p><h3 id="4-注册githup账号并新建仓库"><a href="#4-注册githup账号并新建仓库" class="headerlink" title="4.注册githup账号并新建仓库"></a>4.注册githup账号并新建仓库</h3><p>新建一个名为<code>你的用户名.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来个人博客访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://用户名.github.io</a></p><h3 id="5-自动发布-Hexo-搭建的静态博客"><a href="#5-自动发布-Hexo-搭建的静态博客" class="headerlink" title="5.自动发布 Hexo 搭建的静态博客"></a>5.自动发布 Hexo 搭建的静态博客</h3><p><strong>5.1先修改 <code>_config.yml</code> 配置文件</strong></p><p>下面是一个示例：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github用户名:密码@github.com/sherlockkid7/sherlockkid7.github.io.git</span></code></pre></div><p>上面的配置选项中，一定要注意在 repo 中按照对应的格式加入 Github 用户名和密码。</p><p><strong>5.2安装自动发布的插件</strong></p><div class="hljs"><pre><code class="hljs bash">npm install hexo-deployer-git --save</code></pre></div><p><strong>5.3使用命令一键进行发布</strong></p><div class="hljs"><pre><code class="hljs bash">hexo generate --deploy<span class="hljs-comment"># 或者</span>hexo deploy --generate</code></pre></div><p>上面两条命令都可以，发布可能有延时，稍微等待即可。</p><h3 id="6-新建文章"><a href="#6-新建文章" class="headerlink" title="6.新建文章"></a>6.新建文章</h3><div class="hljs"><pre><code class="hljs plain">hexo new 文章标题</code></pre></div><h3 id="7-修改默认hexo主题"><a href="#7-修改默认hexo主题" class="headerlink" title="7.修改默认hexo主题"></a>7.修改默认hexo主题</h3><p>在github下载hexo-theme-fluid-1.8.0主题，并解压到themes文件夹中，修改 <code>_config.yml</code> 配置文件(注主题文件可以重命名为fluid)</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
