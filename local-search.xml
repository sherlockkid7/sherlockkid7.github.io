<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>数据可视化ECharts项目</title>
    <link href="/2020/06/08/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96ECharts%E9%A1%B9%E7%9B%AE/"/>
    <url>/2020/06/08/%E6%95%B0%E6%8D%AE%E5%8F%AF%E8%A7%86%E5%8C%96ECharts%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200608152310511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>此项目是根据<a href="https://www.bilibili.com/video/BV1v7411R7mp?p=51" target="_blank" rel="noopener">pink老师的课程</a>实现的ECharts数据可视化项目<br>项目地址： <a href="http://tq07.gitee.io/echarts" target="_blank" rel="noopener">http://tq07.gitee.io/echarts</a></p><h3 id="Echarts基础知识"><a href="#Echarts基础知识" class="headerlink" title="Echarts基础知识"></a>Echarts基础知识</h3><blockquote><p>ECharts，一个使用 JavaScript 实现的开源可视化库，可以流畅的运行在 PC和移动设备上，兼容当前绝大部分浏览器（IE8/9/10/11，Chrome，Firefox，Safari等），底层依赖矢量图形库ZRender，提供直观，交互丰富，可高度个性化定制的数据可视化图表。<br>官网地址：<a href="https://www.echartsjs.com/zh/index.html" target="_blank" rel="noopener">https://www.echartsjs.com/zh/index.html</a></p></blockquote><h4 id="1-使用步骤："><a href="#1-使用步骤：" class="headerlink" title="1.使用步骤："></a>1.使用步骤：</h4><p>1.获取 ECharts （<a href="https://echarts.apache.org/zh/download.html" target="_blank" rel="noopener">Apache ECharts (incubating) 官网下载界面</a>）（该项目使用直接下载的ECharts插件）</p><p>2.引入ECharts 插件到html页面中</p><div class="hljs"><pre><code class="hljs js">&lt;script src=<span class="hljs-string">"./js/echarts.min.js"</span>&gt;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p>3.准备一个具备大小的DOM容器</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span>    <span class="hljs-comment">&lt;!-- 为 ECharts 准备一个具备大小（宽高）的 DOM --&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">"main"</span> <span class="hljs-attr">style</span>=<span class="hljs-string">"width: 600px;height:400px;"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span></code></pre></div><p>4.初始化echarts实例对象</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 基于准备好的dom，初始化echarts实例</span> <span class="hljs-keyword">var</span> myChart = echarts.init(<span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">'main'</span>));</code></pre></div><p>5.指定配置项和数据(option)</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> option = &#123;            title: &#123;                text: <span class="hljs-string">'ECharts 入门示例'</span>            &#125;,            tooltip: &#123;&#125;,            legend: &#123;                data:[<span class="hljs-string">'销量'</span>]            &#125;,            xAxis: &#123;                data: [<span class="hljs-string">"衬衫"</span>,<span class="hljs-string">"羊毛衫"</span>,<span class="hljs-string">"雪纺衫"</span>,<span class="hljs-string">"裤子"</span>,<span class="hljs-string">"高跟鞋"</span>,<span class="hljs-string">"袜子"</span>]            &#125;,            yAxis: &#123;&#125;,            series: [&#123;                name: <span class="hljs-string">'销量'</span>,                type: <span class="hljs-string">'bar'</span>,                data: [<span class="hljs-number">5</span>, <span class="hljs-number">20</span>, <span class="hljs-number">36</span>, <span class="hljs-number">10</span>, <span class="hljs-number">10</span>, <span class="hljs-number">20</span>]            &#125;]        &#125;;</code></pre></div><p>6.将配置项设置给echarts实例对象</p><div class="hljs"><pre><code class="hljs js">myChart.setOption(option);</code></pre></div><h4 id="2-Echarts基础配置"><a href="#2-Echarts基础配置" class="headerlink" title="2.Echarts基础配置"></a>2.Echarts基础配置</h4><ul><li>series（系列）<br>每个系列通过 <code>series.type</code> 决定自己的图表类型（图表数据，指定什么类型的图表，可以多个图表重叠）。</li><li>xAxis：直角坐标系 grid 中的 x 轴</li><li>yAxis：直角坐标系 grid 中的 y 轴</li><li>grid：直角坐标系内绘图网格</li><li>title：标题组件</li><li>tooltip：提示框组件</li><li>legend：图例组件</li><li>color：调色盘颜色列表</li><li>boundaryGap:<br>坐标轴两边留白策略，类目轴中 boundaryGap 可以配置为 true 和 false。默认为 true，可以保证刻度线和标签对齐。这时候刻度只是作为分隔线，标签和数据点都会在两个刻度之间的带(band)中间。<img src="https://img-blog.csdnimg.cn/20200608161640464.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>数据堆叠，同个类目轴上系列配置相同的<code>stack</code>值后 后一个系列的值会在前一个系列的值上相加。</li></ul><p>示例：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">let</span> option = &#123;<span class="hljs-comment">// color设置线条的颜色 注意后面是个数组</span>        color: [<span class="hljs-string">'pink'</span>, <span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'skyblue'</span>],        <span class="hljs-comment">// 设置图表的标题</span>    title: &#123;        text: <span class="hljs-string">'折线图堆叠123'</span>    &#125;,    <span class="hljs-comment">// 图表的提示框组件</span>    tooltip: &#123;    <span class="hljs-comment">// 触发方式</span>            trigger: <span class="hljs-string">'axis'</span>,            <span class="hljs-comment">// 坐标轴指示器，坐标轴触发有效</span>            axisPointer: &#123;                type: <span class="hljs-string">'shadow'</span>  <span class="hljs-comment">// 默认为直线，可选为：'line' | 'shadow'</span>            &#125;        &#125;,        <span class="hljs-comment">// 图例组件</span>    legend: &#123;       <span class="hljs-comment">// series里面有了 name值，则 legend里面的data可以删掉</span>    &#125;,    <span class="hljs-comment">// 网格配置  grid可以控制线形图 柱状图 图表大小</span>        grid: &#123;            top: <span class="hljs-string">"10%"</span>,            left: <span class="hljs-string">"22%"</span>,            bottom: <span class="hljs-string">"10%"</span>，            <span class="hljs-comment">// 是否显示刻度标签 如果是true 就显示， false则不显示</span>           containLabel: <span class="hljs-literal">true</span>        &#125;,        <span class="hljs-comment">// 工具箱组件  可以另存为图片等功能</span>    toolbox: &#123;        feature: &#123;            saveAsImage: &#123;&#125;        &#125;    &#125;,    <span class="hljs-comment">// 设置x轴的相关配置</span>        xAxis: &#123;            show:<span class="hljs-literal">false</span>        &#125;,        <span class="hljs-comment">// 设置y轴的相关配置</span>        yAxis: [            &#123;                type: <span class="hljs-string">'category'</span>,                inverse: <span class="hljs-literal">true</span>,                data: [<span class="hljs-string">"HTML5"</span>, <span class="hljs-string">"CSS3"</span>, <span class="hljs-string">"javascript"</span>, <span class="hljs-string">"VUE"</span>, <span class="hljs-string">"NODE"</span>],                <span class="hljs-comment">//不显示y轴线条</span>                axisLine: &#123;                    show: <span class="hljs-literal">false</span>                    <span class="hljs-comment">// 如果想要设置单独的线条样式 </span>    <span class="hljs-comment">// lineStyle: &#123;</span>     <span class="hljs-comment">//    color: "rgba(255,255,255,.1)",</span>       <span class="hljs-comment">//    width: 1,</span>       <span class="hljs-comment">//    type: "solid"</span>      <span class="hljs-comment">//  &#125;</span>                        &#125;,                <span class="hljs-comment">// 不显示刻度</span>                axisTick: &#123;                show: <span class="hljs-literal">false</span>                &#125;,               Y轴的文字颜色和大小                axisLabel:&#123;                    color:<span class="hljs-string">"#fff"</span>，                    fontSize: <span class="hljs-string">"12"</span>                &#125;，                <span class="hljs-comment">// y 轴分隔线样式</span>   splitLine: &#123;       lineStyle: &#123;          color: <span class="hljs-string">"rgba(255,255,255,.1)"</span>        &#125;   &#125;            &#125;,            &#123;                type: <span class="hljs-string">'category'</span>,                inverse: <span class="hljs-literal">true</span>,                data: [<span class="hljs-number">702</span>, <span class="hljs-number">350</span>, <span class="hljs-number">610</span>, <span class="hljs-number">793</span>, <span class="hljs-number">664</span>],                <span class="hljs-comment">//不显示y轴线条</span>                axisLine: &#123;                    show: <span class="hljs-literal">false</span>                        &#125;,                <span class="hljs-comment">// 不显示刻度</span>                axisTick: &#123;                show: <span class="hljs-literal">false</span>                &#125;,                                axisLabel:&#123;                    color:<span class="hljs-string">"#fff"</span>,                    fontSize:<span class="hljs-number">12</span>                &#125;            &#125;,        ],        <span class="hljs-comment">// 系列图表配置 它决定着显示那种类型的图表</span>        series: [            &#123;                name: <span class="hljs-string">'bar'</span>,                type: <span class="hljs-string">'bar'</span>,                <span class="hljs-comment">// 柱子之间的距离</span>                barCategoryGap:<span class="hljs-number">50</span>,                <span class="hljs-comment">// 修改柱子宽度</span>                barWidth:<span class="hljs-number">10</span>,                itemStyle:&#123;                 <span class="hljs-comment">// 修改柱子圆角</span>                        barBorderRadius:<span class="hljs-number">20</span>,                        <span class="hljs-comment">//给 itemStyle  里面的color 属性设置一个 返回值函数</span>                        <span class="hljs-comment">// params 传进来的是柱子对象</span>                        color:<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">params</span>)</span>&#123;                        <span class="hljs-comment">// dataIndex 是当前柱子的索引号</span>                        <span class="hljs-keyword">return</span> myColor[params.dataIndex];                        &#125;                 &#125;,                data: [<span class="hljs-number">70</span>, <span class="hljs-number">34</span>, <span class="hljs-number">60</span>, <span class="hljs-number">78</span>, <span class="hljs-number">69</span>],                <span class="hljs-comment">// 图形上的文本标签</span>                label:&#123;                    normal:&#123;                        show: <span class="hljs-literal">true</span>,                        <span class="hljs-comment">// 图形内显示</span>                        position: <span class="hljs-string">"inside"</span>,                        <span class="hljs-comment">// 文字的显示格式   &#123;c&#125; 会自动的解析为 数据  data里面的数据</span>                        formatter: <span class="hljs-string">"&#123;c&#125;%"</span>                    &#125;                &#125;,                yAxisIndex: <span class="hljs-number">0</span>, <span class="hljs-comment">//层级关系</span>            &#125;,            &#123;                name: <span class="hljs-string">'box'</span>,                type: <span class="hljs-string">'bar'</span>,                barCategoryGap: <span class="hljs-number">50</span>,                barWidth: <span class="hljs-number">15</span>,                itemStyle: &#123;                    color: <span class="hljs-string">"none"</span>,                    borderColor: <span class="hljs-string">"#00c1de"</span>,                    borderWidth: <span class="hljs-number">3</span>,                    barBorderRadius: <span class="hljs-number">15</span>                &#125;,                data: [<span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>, <span class="hljs-number">100</span>],                yAxisIndex: <span class="hljs-number">1</span>, <span class="hljs-comment">//层级关系</span>            &#125;        ]    &#125;;</code></pre></div><p>补充知识点：<br>1.折线类型图表把折线修饰为圆滑 ，在series 数据中添加 smooth 为 true<br>2.带有直角坐标系的比如折线图、柱状图是 grid修改图形大小，而饼形图是通过 radius 修改大小<br>3.饼图图形上的文本标签可以控制饼形图的文字的一些样式， label 对象中设置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 文本标签控制饼形图文字的相关样式， 注意它是一个对象</span>       label: &#123;         fontSize: <span class="hljs-number">10</span>       &#125;,</code></pre></div><p>4.引导线调整，在series对象里面的 labelLine 对象设置</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 引导线调整</span>      labelLine: &#123;       <span class="hljs-comment">// 连接扇形图线长</span>        length: <span class="hljs-number">6</span>,       <span class="hljs-comment">// 连接文字线长</span>       length2: <span class="hljs-number">8</span>      &#125;</code></pre></div><p>5.地图放大通过 zoom ，设置为数字</p><h3 id="项目使用的技术："><a href="#项目使用的技术：" class="headerlink" title="项目使用的技术："></a>项目使用的技术：</h3><ul><li><p>div + css</p></li><li><p>flex 布局</p></li><li><p>Less （在html页面中需导入对应的css文件，在VScode中安装Easy LESS插件可以直接把less文件转成css文件）</p></li><li><p>原生js</p><p>注意：每个图表指定配置项和数据(option)需要使用立即执行函数或者在函数中使用let声明变量，避免命名冲突</p></li><li><p>rem适配</p></li><li><p>引用淘宝的flexible.js 把屏幕分为 24 等份</p></li><li><p>VScode中安装cssrem插件，并修改cssrem 插件的基准值为 80px<br><img src="https://img-blog.csdnimg.cn/20200608181816692.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述">注：别忘记重启vscode软件保证生效</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ECharts</category>
      
    </categories>
    
    
    <tags>
      
      <tag>ECharts</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>WebAPI</title>
    <link href="/2020/06/05/WebAPI/"/>
    <url>/2020/06/05/WebAPI/</url>
    
    <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2020/6/5/17282a52b579827e?w=3111&h=10775&f=png&s=2950128" srcset="/img/loading.gif" alt=""></p><h2 id="1-基本介绍"><a href="#1-基本介绍" class="headerlink" title="1.基本介绍"></a>1.基本介绍</h2><p>API（Application Programming Interface,应用程序编程接口）是一些预先定义的函数，帮助我们实现某种功能</p><p>Web API 是浏览器提供的一套操作浏览器功能和页面元素的 API ( BOM 和 DOM )。</p><h2 id="2-DOM"><a href="#2-DOM" class="headerlink" title="2.DOM"></a>2.DOM</h2><p>文档对象模型（Document Object Model，简称DOM），是 W3C组织推荐的处理可扩展标记语言（html或者xhtml）的标准编程接口。<br><strong>文档</strong>：一个页面就是一个文档，DOM中使用<strong>document</strong>表示<br><strong>节点</strong>：网页中的所有内容，在文档树中都是节点（标签、属性、文本、注释等），使用<strong>node</strong>表示<br><strong>标签节点</strong>：网页中的所有标签，通常称为<strong>元素节点</strong>，又简称为“元素”，使用<strong>element</strong>表示</p><h3 id="2-1获取元素"><a href="#2-1获取元素" class="headerlink" title="2.1获取元素"></a>2.1获取元素</h3><ul><li><p>ID 获取</p><ul><li>语法：document.getElementById(‘id’)</li><li>作用：根据ID获取元素对象</li><li>参数：id值，区分大小写的<strong>字符串</strong></li><li>返回值：元素对象 或 null</li></ul></li><li><p>标签名获取</p><ul><li><p>语法：</p><p>1.<strong>document</strong>.getElementsByTagName(‘标签名’)</p><p>2.<strong>element</strong>.getElementsByTagName(‘标签名’)</p></li><li><p>作用：根据标签名获取元素对象</p></li><li><p>参数：标签名</p></li><li><p>返回值：元素对象集合（伪数组，数组元素是元素对象）</p><p>注意：</p><p>1.因为得到的是一个对象的集合，所以我们想要操作里面的元素就需要遍历。</p><p>2.得到元素对象是动态的</p><p>3.如果获取不到元素,则返回为空的伪数组</p></li></ul></li><li><p>HTML5 新增的方法获取</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.getElementsByClassName(‘类名’)；<span class="hljs-comment">// 根据类名返回元素对象集合</span><span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'选择器'</span>); <span class="hljs-comment">// 根据指定选择器返回第一个元素对象</span><span class="hljs-built_in">document</span>.querySelectorAll(<span class="hljs-string">'选择器'</span>); <span class="hljs-comment">// 根据指定选择器返回所有元素对象集合</span></code></pre></div><p>注意：querySelector 和querySelectorAll里面的选择器需要加符号</p><p><code>document.querySelector(&#39;#nav&#39;);</code></p></li><li><p>特殊元素获取</p><ul><li>获取body元素<br><code>doucumnet.body // 返回body元素对象</code></li><li>获取html元素<br><code>document.documentElement // 返回html元素对象</code></li></ul></li></ul><h3 id="2-2事件基础"><a href="#2-2事件基础" class="headerlink" title="2.2事件基础"></a>2.2事件基础</h3><ul><li><p>事件三要素</p><ul><li><p>事件源（谁）：触发事件的元素</p></li><li><p>事件类型（什么事件）： 例如 click 点击事件</p></li><li><p>事件处理程序（做啥）：事件触发后要执行的代码(函数形式)，事件处理函数</p></li></ul></li><li><p>执行事件的步骤</p><ul><li>获取事件源</li><li>注册事件（绑定事件）</li><li>添加事件处理程序（采取函数赋值形式）</li></ul></li><li><p>常见的鼠标事件</p><p><img src="https://img-blog.csdnimg.cn/20200604225603884.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="2-3操作元素"><a href="#2-3操作元素" class="headerlink" title="2.3操作元素"></a>2.3操作元素</h3><p>JavaScript的 DOM 操作可以改变网页内容、结构和样式，我们可以利用 DOM 操作元素来改变元素里面的内容、属性等。（注意：这些操作都是通过元素对象的属性实现的）</p><p><strong>获取属性的值</strong><br>元素对象.属性名<br><strong>设置属性的值</strong><br>元素对象.属性名 = 值<br><strong>表单元素</strong>中有一些属性如：disabled、checked、selected，元素对象的这些<strong>属性的值</strong>是<strong>布尔型</strong>。</p><ul><li><p>改变元素内容</p><ul><li>element.innerText<br>从起始位置到终止位置的内容, 但它去除 html 标签， 同时空格和换行也会去掉</li><li><strong>element.innerHTML</strong>(W3C标准)<br>起始位置到终止位置的全部内容，包括 html 标签，同时保留空格和换行</li></ul></li><li><p>常用元素的属性操作</p><ol><li><p>nnerText、innerHTML 改变元素内容</p></li><li><p>src、href</p></li><li><p>id、alt、title</p></li></ol></li><li><p>表单元素的属性操作</p><p>type、value、checked、selected、disabled</p></li><li><p>样式属性操作</p><ul><li><p>element.style 行内样式操作<br><code>元素对象.style.样式属性 = 值;</code><br><strong>注意</strong>：<br>1.JS 里面的样式采取驼峰命名法 比如 fontSize、 backgroundColor<br>2.JS 修改 style 样式操作，产生的是行内样式，CSS 权重比较高</p></li><li><p>element.className 类名样式操作<br><code>元素对象.className = 值;</code><br><strong>注意</strong>：</p><p>1.如果样式修改较多，可以采取操作类名方式更改元素样式。</p><p>2.class因为是个保留字，因此使用className来操作元素类名属性</p><p>3.className 会直接更改元素的类名，会覆盖原先的类名。</p></li></ul></li><li><p>自定义属性的操作<br><strong>H5自定义属性</strong><br>自定义属性目的：是为了<strong>保存并使用数据</strong>。有些数据可以保存到页面中而不用保存到数据库中<br><strong>1. 设置H5自定义属性</strong><br>H5规定自定义属性data-开头做为属性名并且赋值。<br><code>&lt;div data-index=&quot;1&quot;&gt;&lt;/div&gt;</code><br>或者使用 JS 设置<br><code>element.setAttribute(‘data-index’, 2)</code><br><strong>2. 获取H5自定义属性</strong><br>兼容性获取 element.getAttribute(‘data-index’);<br>H5新增 element.dataset.index 或者 element.dataset[‘index’] ie 11才开始支持<br><strong>获取属性值</strong><br>element.属性 获取内置属性值（元素本身自带的属性）<br><code>element.getAttribute(‘属性’);</code> 主要获得自定义的属性 （标准）<br><strong>设置属性值</strong><br>element.属性 设置内置属性值<br><code>element.setAttribute(‘属性’);</code> 主要设置自定义的属性 （标准）<br><strong>移除属性</strong><br><code>element.removeAttribute(&#39;属性&#39;);</code></p></li></ul><h3 id="2-4节点操作"><a href="#2-4节点操作" class="headerlink" title="2.4节点操作"></a>2.4节点操作</h3><ul><li><p>节点概述</p><p>一般地，节点至少拥有nodeType（节点类型）、nodeName（节点名称）和nodeValue（节点值）这三个基本属性。</p><ul><li>元素节点 nodeType 为 1</li><li>属性节点 nodeType 为 2</li><li>文本节点 nodeType 为 3 （文本节点包含文字、空格、换行等）<br>我们在实际开发中，节点操作主要操作的是<strong>元素节点</strong></li></ul></li><li><p>节点层级</p><p>利用 DOM 树可以把节点划分为不同的层级关系，常见的是父子兄层级关系。</p><p>1.父级节点<br><code>node.parentNode</code></p><ul><li>parentNode 属性可返回某节点的父节点，注意是最近的一个父节点</li><li>如果指定的节点没有父节点则返回 null</li></ul><p>2.子节点</p><ul><li><p>所有子节点<br>parentNode.childNodes（标准）<br>parentNode.childNodes 返回包含指定节点的子节点的集合，该集合为即时更新的集合。<br>注意：返回值里面包含了所有的子节点，包括元素节点，文本节点等。<br>如果只想要获得里面的元素节点，则需要专门处理。 所以我们一般不提倡使用childNodes</p></li><li><p><strong>子元素节点</strong><br>parentNode.<strong>children</strong>（非标准）<br>parentNode.children 是一个只读属性，返回所有的子元素节点。它只返回子元素节点，其余节点不返回 （<strong>这个是我们重点掌握的</strong>）。</p><p>parentNode.<strong>firstChild</strong><br>firstChild 返回第一个子节点，找不到则返回null。同样，也是包含所有的节点。parentNode.<strong>lastChild</strong> 最后一个子节点<br>lastChild 返回最后一个子节点，找不到则返回null。同样，也是包含所有的节点。</p><p>parentNode.<strong>firstElementChild</strong><br>firstElementChild 返回第一个子元素节点，找不到则返回null。parentNode.<strong>lastElementChild</strong><br>lastElementChild 返回最后一个子元素节点，找不到则返回null。<br>注意：这两个方法有兼容性问题，IE9 以上才支持。</p><p>实际开发中，firstChild 和 lastChild 包含其他节点，操作不方便，而 firstElementChild 和lastElementChild 又有兼容性问题，那么我们如何<strong>获取第一个子元素节点</strong>或<strong>最后一个子元素节点</strong>呢？</p><p><strong>解决方案：</strong></p><ol><li>如果想要第一个子元素节点，可以使用 <strong>parentNode.chilren[0]</strong></li><li>如果想要最后一个子元素节点，可以使用<strong>parentNode.chilren[parentNode.chilren.length - 1]</strong></li></ol></li></ul><p>3.兄弟节点</p><p>​ node.<strong>nextSibling</strong><br>​ nextSibling 返回当前元素的下一个兄弟节点，找不到则返回null。同样，也是包含所有的节点。<br>​ node.<strong>previousSibling</strong><br>​ previousSibling 返回当前元素上一个兄弟节点，找不到则返回null。同样，也是包含所有的节点。</p><p>​ 注意：这下面两个方法有兼容性问题， IE9 以上才支持。<br>​ node.nextElementSibling<br>​ nextElementSibling 返回当前元素下一个兄弟元素节点，找不到则返回null。<br>​ node.previousElementSibling<br>​ previousElementSibling 返回当前元素上一个兄弟节点，找不到则返回null。</p></li><li><p>创建节点</p><p><strong>document.createElement(‘tagName’)</strong><br>document.createElement() 方法创建由 tagName 指定的 HTML 元素。因为这些元素原先不存在，是根据我们的需求动态生成的，所以我们也称为<strong>动态创建元素节点</strong>。</p></li><li><p>添加节点</p><p><strong>node.appendChild(child)</strong><br>node.appendChild() 方法将<strong>一个节点</strong>添加到指定<strong>父节点的子节点列表末尾</strong>。类似于 CSS 里面的after 伪元素。</p><p><strong>node.insertBefore(child, 指定元素)</strong><br>node.insertBefore() 方法将<strong>一个节点</strong>添加到<strong>父节点的指定子节点前面</strong>。类似于 CSS 里面的 before 伪元素。</p></li><li><p>删除节点</p><p>node.removeChild() 方法从 DOM 中删除一个子节点，返回删除的节点。</p></li><li><p>复制节点</p><p>node.cloneNode()<br>node.cloneNode() 方法返回调用该方法的节点的一个副本。<br>注意：</p><p>1.如果括号<strong>参数为空</strong>或者为 <strong>false</strong> ，则是<strong>浅拷贝</strong>，即只克隆复制节点本身，不克隆里面的子节点。</p><p>2.如果括号<strong>参数为 tru</strong>e ，则是<strong>深度拷贝</strong>，会复制节点本身以及里面所有的子节点。</p></li><li><p>替换节点</p><p>parentNode.replaceChild(newChild, oldChild);<br>用指定的节点替换当前节点的一个子节点，并返回被替换掉的节点。</p></li><li><p><strong>三种动态创建元素区别</strong></p><p>document.write()<br>element.innerHTML<br>document.createElement()<br>区别：</p><ol><li><p><strong>document.write</strong> 是直接将内容写入页面的内容流，会<strong>导致页面</strong>全部<strong>重绘</strong></p></li><li><p>innerHTML 是将内容写入某个 DOM 节点，不会导致页面全部重绘</p></li><li><p>如果页面<strong>创建元素很多</strong>，建议使用 <strong>innerHTML</strong> ，因其<strong>效率更高</strong>（不要拼接字符串，<strong>采取数组形式拼接</strong>） ，但是结构稍微复杂</p></li><li><p>如果页面创建元素较少，建议使用 createElement() ，结构更清晰<br>总结：不同浏览器下，innerHTML 效率要比 creatElement 高</p><p><strong>createElement方式</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'div'</span>);            div.style.width = <span class="hljs-string">'100px'</span>;            div.style.height = <span class="hljs-string">'2px'</span>;            div.style.border = <span class="hljs-string">'1px solid red'</span>;            <span class="hljs-built_in">document</span>.body.appendChild(div);        &#125;        <span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p><strong>innerHTML数组方式</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-keyword">var</span> d1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-keyword">var</span> array = [];        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++) &#123;            array.push(<span class="hljs-string">'&lt;div style="width:100px; height:2px; border:1px solid blue;"&gt;&lt;/div&gt;'</span>);        &#125;        <span class="hljs-built_in">document</span>.body.innerHTML = array.join(<span class="hljs-string">''</span>);        <span class="hljs-keyword">var</span> d2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();        <span class="hljs-built_in">console</span>.log(d2 - d1);    &#125;    fn();&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div></li></ol></li></ul><h2 id="3-BOM"><a href="#3-BOM" class="headerlink" title="3.BOM"></a>3.BOM</h2><p>BOM（Browser Object Model）即浏览器对象模型，它提供了独立于内容而与浏览器窗口进行交互的对象，其核心对象是 window。</p><p><img src="https://img-blog.csdnimg.cn/20200605084652710.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-1window"><a href="#3-1window" class="headerlink" title="3.1window"></a>3.1window</h3><p>window 对象是浏览器的顶级对象，它具有双重角色。</p><ol><li>它是 JS 访问浏览器窗口的一个接口。</li><li>它是一个全局对象。定义在全局作用域中的变量、函数都会变成 window 对象的属性和方法。</li><li>在调用的时候可以省略 window， alert()、prompt()都属于 window 对象方法。<br>注意：window下的一个特殊属性 window.name</li></ol><h3 id="3-2window-对象的常见事件"><a href="#3-2window-对象的常见事件" class="headerlink" title="3.2window 对象的常见事件"></a>3.2window 对象的常见事件</h3><ul><li><p>窗口加载事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;;<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"load"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);</code></pre></div><p>window.onload 是窗口 (页面）加载事件,当文档内容完全加载完成会触发该事件(包括图像、脚本文件、CSS 文件等)。<br>注意：</p><ul><li><p>有了 window.onload 就可以把 JS 代码写到页面元素的上方，因为 onload 是等页面内容全部加载完毕， 再去执行处理函数。</p></li><li><p>window.onload 传统注册事件方式 只能写一次，如果有多个，会以最后一个为准。如果使用 addEventListener 则没有限制</p></li></ul><p><code>document.addEventListener(&#39;DOMContentLoaded&#39;,function(){}) //Ie9以上才支持</code><br>DOMContentLoaded 事件触发时，仅当DOM加载完成，不包括样式表，图片，flash等等。<br>如果页面的图片很多的话, 从用户访问到onload触发可能需要较长的时间, 交互效果就不能实现，必然影响用户的体验，此时用 DOMContentLoaded 事件比较合适。</p></li><li><p>调整窗口大小事件</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">window</span>.onresize = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;<span class="hljs-built_in">window</span>.addEventListener(<span class="hljs-string">"resize"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;&#125;);</code></pre></div><p>window.onresize 是调整窗口大小加载事件<br>注意：</p><ul><li>只要窗口大小发生像素变化，就会触发这个事件。</li><li>经常利用这个事件完成响应式布局。window.innerWidth 当前屏幕的宽度</li></ul></li></ul><h3 id="3-3location-对象"><a href="#3-3location-对象" class="headerlink" title="3.3location 对象"></a>3.3location 对象</h3><p>​ 用于获取或设置窗体的 URL，并且可以用于解析 URL</p><ul><li><p>统一资源定位符 (Uniform Resource Locator, URL)</p><p>是互联网上标准资源的地址。互联网上的每个文件都有一个唯一的 URL，它包含的信息指出文件的位置以及浏览器应该怎么处理它。</p></li></ul><p>​ URL 的一般语法格式为：protocol://host[:port]/path/[?query]#fragment</p><p><img src="https://img-blog.csdnimg.cn/20200605093430290.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>location 对象的属性</p><p><img src="https://img-blog.csdnimg.cn/20200605093832429.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>重点记住： href 和 search</p></li><li><p>location对象的常见方法</p><p><img src="https://img-blog.csdnimg.cn/20200605093832427.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul><h3 id="3-4navigator-对象"><a href="#3-4navigator-对象" class="headerlink" title="3.4navigator 对象"></a>3.4navigator 对象</h3><p>navigator 对象包含有关浏览器的信息，它有很多属性，我们最常用的是 userAgent，该属性可以返回由客户端发送服务器的 user-agent 头部的值,可以判断用户使用什么终端打开页面，实现跳转</p><h3 id="3-5history-对象"><a href="#3-5history-对象" class="headerlink" title="3.5history 对象"></a>3.5history 对象</h3><p>window 对象给我们提供了一个 history 对象，与浏览器历史记录进行交互。该对象包含用户（在浏览器窗口中）访问过的 URL。（ 一般在OA 办公系统中使用）</p><p><img src="https://img-blog.csdnimg.cn/20200605093831302.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="3-6定时器"><a href="#3-6定时器" class="headerlink" title="3.6定时器"></a>3.6定时器</h3><ul><li><p><strong>setTimeout() 定时器</strong>（炸弹）</p><p>开启定时器：window.setTimeout(调用函数, [延迟的毫秒数]);<br>setTimeout() 的调用函数我们也称为回调函数 callback，在<strong>定时器到期后执行调用函数</strong><br>注意：</p><ul><li><p>window 可以省略。</p></li><li><p>这个调用函数可以直接写函数，或者写函数名</p></li><li><p>延迟的毫秒数省略默认是 0</p></li><li><p>因为定时器可能有很多，所以我们经常给定时器赋值一个标识符。</p></li></ul><p>停止定时器：<br>window.clearTimeout(timeoutID)<br>clearTimeout()方法取消了先前通过调用 setTimeout() 建立的定时器。<br>注意：里面的参数就是定时器的标识符 。</p></li><li><p><strong>setInterval() 定时器（闹钟）</strong></p><p>开启定时器：<br>window.setInterval(回调函数, [间隔的毫秒数]);<br>setInterval() 方法重复调用一个函数，<strong>每隔这个时间，就去调用一次回调函数</strong>。<br>注意：</p><ul><li><p>window 可以省略。</p></li><li><p>这个调用函数可以直接写函数，或者写函数名。</p></li><li><p>间隔的毫秒数省略默认是 0，如果写，必须是毫秒，表示每隔多少毫秒就自动调用这个函数。</p></li><li><p>第一次执行也是间隔毫秒数之后执行，之后每隔毫秒数就执行一次。</p></li></ul><p>停止 setInterval() 定时器：<br>window.clearInterval(intervalID);<br>clearInterval()方法取消了先前通过调用 setInterval()建立的定时器。</p></li></ul><h3 id="3-7this指向问题"><a href="#3-7this指向问题" class="headerlink" title="3.7this指向问题"></a>3.7this指向问题</h3><p>this的指向在函数定义的时候是确定不了的，只有函数执行的时候才能确定this到底指向谁，一般情况下this的最终指向的是那个调用它的对象。</p><ol><li>全局作用域或者普通函数中this指向全局对象window（注意定时器里面的this指向window）</li><li>方法调用中谁调用this指向谁</li><li>构造函数中this指向构造函数的实例</li></ol><h2 id="4-事件高级"><a href="#4-事件高级" class="headerlink" title="4.事件高级"></a>4.事件高级</h2><h3 id="4-1注册事件"><a href="#4-1注册事件" class="headerlink" title="4.1注册事件"></a>4.1注册事件</h3><p>给元素添加事件，称为注册事件或者绑定事件。<br>注册事件有两种方式：传统方式和方法监听注册方式</p><ul><li><p>传统注册方式</p><ul><li>利用 on 开头的事件 onclick</li><li><code>&lt;button onclick=“alert(&#39;hi~&#39;)”&gt;&lt;/button&gt;</code>或者<code>btn.onclick = function() {}</code><br>特点：同一个元素同一个事件只能设置一个处理函数，最后注册的处理函数将会覆盖前面注册的处理函数</li></ul></li><li><p>方法监听注册方式(w3c 标准推荐方式)</p><p><strong>addEventListener 事件监听方式</strong></p><p><code>eventTarget.addEventListener(type, listener[, useCapture])</code></p><p>eventTarget.addEventListener()方法将指定的监听器注册到 eventTarget（目标对象）上，当该对象触发指定的事件时，就会执行事件处理函数。<br>该方法接收三个参数：</p><ul><li><p>type：事件类型字符串，比如 click 、mouseover ，注意这里不要带 on</p></li><li><p>listener：事件处理函数，事件发生时，会调用该监听函数</p></li><li><p>useCapture：可选参数，是一个布尔值，默认是 false。</p><p>特点：不支持IE9 之前的 IE，同一个元素同一个事件可以注册多个监听器,按注册顺序依次执行</p></li></ul><p><strong>attachEvent 事件监听方式</strong></p><p><code>eventTarget.attachEvent(eventNameWithOn, callback)</code></p><p>eventTarget.attachEvent()方法将指定的监听器注册到 eventTarget（目标对象） 上，当该对象触</p><p>发指定的事件时，指定的回调函数就会被执行。</p><p>该方法接收两个参数：</p><ul><li><p>eventNameWithOn：事件类型字符串，比如 onclick 、onmouseover ，这里要带 on</p></li><li><p>callback： 事件处理函数，当目标触发事件时回调函数被调用</p><p><strong>注意：</strong>IE8 及早期版本支持</p></li></ul></li></ul><h3 id="4-2删除事件"><a href="#4-2删除事件" class="headerlink" title="4.2删除事件"></a>4.2删除事件</h3><ul><li>传统方式<br>eventTarget.onclick = null;</li><li>方法监听注册方式<br>① eventTarget.removeEventListener(type, listener[, useCapture]);<br>② eventTarget.detachEvent(eventNameWithOn, callback);</li></ul><h3 id="4-3DOM-事件流"><a href="#4-3DOM-事件流" class="headerlink" title="4.3DOM 事件流"></a>4.3DOM 事件流</h3><p>事件发生时会在元素节点之间按照特定的顺序传播，这个传播过程即 DOM 事件流。</p><p>注意 :</p><ul><li>JS代码中只能执行捕获或者冒泡其中的一个阶段。</li><li>onclick 和 attachEvent 只能得到冒泡阶段。</li><li>addEventListener(type, listener[, <strong>useCapture</strong>])第三个参数如果是 <strong>true</strong>，表示在<strong>事件捕</strong><br><strong>获阶段</strong>调用事件处理程序；如果是 <strong>false</strong>（不写默认就是false），表示在<strong>事件冒泡阶段</strong>调用事件处理<br>程序。</li><li>实际开发中我们很少使用事件捕获，我们更关注事件冒泡。</li><li>有些事件是没有冒泡的，比如 onblur、onfocus、onmouseenter、onmouseleave</li></ul><p>DOM 事件流会经历3个阶段：</p><ol><li><p>捕获阶段</p><p>由 DOM 最顶层节点开始，然后逐级向下传播到到最具体的元素接收的过程。</p></li><li><p>当前目标阶段</p></li><li><p>冒泡阶段</p><p>事件开始时由最具体的元素接收，然后逐级向上传播到到 DOM 最顶层节点的过程</p><p><img src="https://img-blog.csdnimg.cn/20200605101429216.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h3 id="4-4事件对象"><a href="#4-4事件对象" class="headerlink" title="4.4事件对象"></a>4.4事件对象</h3><div class="hljs"><pre><code class="hljs js">eventTarget.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125; eventTarget.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>) </span>&#123;&#125;） <span class="hljs-comment">// 这个 event 就是事件对象</span></code></pre></div><p>官方解释：event 对象代表事件的状态，比如键盘按键的状态、鼠标的位置、鼠标按钮的状态。<br>简单理解：事件发生后，跟事件相关的一系列信息数据的集合都放到这个对象里面，这个对象就是事件对象event，它有很多属性和方法。</p><p><strong>事件对象本身的获取存在兼容问题：</strong></p><ol><li><p>标准浏览器中是浏览器给方法传递的参数，只需要定义形参 e 就可以获取到。</p></li><li><p>在 IE6~8 中，浏览器不会给方法传递参数，如果需要的话，需要到 window.event 中获取查找。<br>解决:<br>e = e || window.event;</p><p>只要“||”前面为false, 不管“||”后面是true 还是 false，都返回 “||” 后面的值。<br>只要“||”前面为true, 不管“||”后面是true 还是 false，都返回 “||” 前面的值。</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-keyword">var</span> div = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'div'</span>);    div.onclick = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;            <span class="hljs-comment">// 事件对象</span>            e = e || <span class="hljs-built_in">window</span>.event;            <span class="hljs-built_in">console</span>.log(e);    &#125;&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div></li></ol><p><strong>事件对象的属性和方法</strong></p><p><img src="https://img-blog.csdnimg.cn/202006051021537.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>e.target 和 this 的区别</strong>：<br><strong>this</strong> 是<strong>事件绑定的元素</strong>， 这个函数的调用者（绑定这个事件的元素）<br><strong>e.target</strong> 是<strong>事件触发的元素</strong>。</p><p>通常情况下terget 和 this是一致的，但有一种情况不同，那就是在事件冒泡时（父子元素有相同事件，单击子元素，父元素的事件处理函数也会被触发执行），这时候this指向的是父元素，因为它是绑定事件的元素对象，而target指向的是子元素，因为他是触发事件的那个具体元素对象。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//事件冒泡下的e.target和this</span>&lt;ul&gt;    &lt;li&gt;abc&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">    &lt;li&gt;abc&lt;/</span>li&gt;    &lt;li&gt;abc&lt;<span class="hljs-regexp">/li&gt;</span><span class="hljs-regexp">&lt;/u</span>l&gt;&lt;script&gt;    <span class="hljs-keyword">var</span> ul = <span class="hljs-built_in">document</span>.querySelector(<span class="hljs-string">'ul'</span>);    ul.addEventListener(<span class="hljs-string">'click'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;          <span class="hljs-comment">// 我们给ul 绑定了事件  那么this 就指向ul  </span>          <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">this</span>); <span class="hljs-comment">// ul</span>          <span class="hljs-comment">// e.target 触发了事件的对象 我们点击的是li e.target 指向的就是li</span>          <span class="hljs-built_in">console</span>.log(e.target); <span class="hljs-comment">// li</span>    &#125;);&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h3 id="4-5阻止默认行为"><a href="#4-5阻止默认行为" class="headerlink" title="4.5阻止默认行为"></a>4.5阻止默认行为</h3><blockquote><p>html中一些标签有默认行为，例如a标签被单击后，默认会进行页面跳转。</p></blockquote><div class="hljs"><pre><code class="hljs js">&lt;a href=<span class="hljs-string">"http://www.baidu.com"</span>&gt;百度&lt;<span class="hljs-regexp">/a&gt;</span><span class="hljs-regexp">&lt;script&gt;</span><span class="hljs-regexp">    /</span><span class="hljs-regexp">/阻止默认行为 让链接不跳转 </span><span class="hljs-regexp">    var a = document.querySelector('a');</span><span class="hljs-regexp">    a.addEventListener('click', function(e) &#123;</span><span class="hljs-regexp">         e.preventDefault(); /</span><span class="hljs-regexp">/  dom 标准写法</span><span class="hljs-regexp">    &#125;);</span><span class="hljs-regexp">   /</span><span class="hljs-regexp">/传统的注册方式</span><span class="hljs-regexp">    a.onclick = function(e) &#123;</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 普通浏览器 e.preventDefault();  方法</span><span class="hljs-regexp">        e.preventDefault();</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 低版本浏览器 ie678  returnValue  属性</span><span class="hljs-regexp">        e.returnValue = false;</span><span class="hljs-regexp">        /</span><span class="hljs-regexp">/ 我们可以利用return false 也能阻止默认行为 没有兼容性问题</span><span class="hljs-regexp">        return false;</span><span class="hljs-regexp">    &#125;</span><span class="hljs-regexp">&lt;/</span>script&gt;</code></pre></div><h3 id="4-6阻止事件冒泡"><a href="#4-6阻止事件冒泡" class="headerlink" title="4.6阻止事件冒泡"></a>4.6阻止事件冒泡</h3><ul><li>标准写法：利用事件对象里面的 stopPropagation()方法<br>e.stopPropagation()</li><li>非标准写法：IE 6-8 利用事件对象 cancelBubble 属性<br>e.cancelBubble = true;</li></ul><h3 id="4-7事件委托"><a href="#4-7事件委托" class="headerlink" title="4.7事件委托"></a>4.7事件委托</h3><p>事件委托也称为事件代理,通俗的讲就是不给子元素注册事件，<strong>给父元素注册事件</strong>，把处理代码在父元素的事件中执行。</p><p><strong>事件委托的原理</strong><br>给父元素注册事件，利用事件冒泡，当子元素的事件触发，会冒泡到父元素，然后去控制相应的子元素。</p><p><strong>事件委托的作用</strong></p><ul><li>只操作了一次 DOM ，提高了程序的性能。</li><li>动态新创建的子元素，也拥有事件。</li></ul><h3 id="4-8鼠标事件"><a href="#4-8鼠标事件" class="headerlink" title="4.8鼠标事件"></a>4.8鼠标事件</h3><p><img src="https://img-blog.csdnimg.cn/20200605103724655.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>1.禁止鼠标右键菜单</p><p>contextmenu主要控制应该何时显示上下文菜单，主要用于程序员取消默认的上下文菜单</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'contextmenu'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.preventDefault();&#125;)</code></pre></div><p>2.禁止鼠标选中（selectstart 开始选中）</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'selectstart'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;e.preventDefault();&#125;)</code></pre></div><p><strong>鼠标事件对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200605103724703.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="img"></p><h3 id="4-9键盘事件"><a href="#4-9键盘事件" class="headerlink" title="4.9键盘事件"></a>4.9键盘事件</h3><p><img src="https://img-blog.csdnimg.cn/20200605105020906.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 常用的键盘事件</span>    <span class="hljs-comment">//1. keyup 按键弹起的时候触发 </span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我弹起了'</span>);    &#125;)    <span class="hljs-comment">//3. keypress 按键按下的时候触发  不能识别功能键 比如 ctrl shift 左右箭头啊</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我按下了press'</span>);    &#125;)    <span class="hljs-comment">//2. keydown 按键按下的时候触发  能识别功能键 比如 ctrl shift 左右箭头啊</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keydown'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;            <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'我按下了down'</span>);    &#125;)    <span class="hljs-comment">// 4. 三个事件的执行顺序  keydown -- keypress -- keyup</span>&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><p><strong>键盘事件对象</strong></p><p><img src="https://img-blog.csdnimg.cn/20200605105350505.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><img src="https://img-blog.csdnimg.cn/20200605105351133.png" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>使用keyCode属性判断用户按下哪个键</strong></p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;    <span class="hljs-comment">// 键盘事件对象中的keyCode属性可以得到相应键的ASCII码值</span>    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keyup'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'up:'</span> + e.keyCode);        <span class="hljs-comment">// 我们可以利用keycode返回的ASCII码值来判断用户按下了那个键</span>        <span class="hljs-keyword">if</span> (e.keyCode === <span class="hljs-number">65</span>) &#123;            alert(<span class="hljs-string">'您按下的a键'</span>);        &#125; <span class="hljs-keyword">else</span> &#123;            alert(<span class="hljs-string">'您没有按下a键'</span>)        &#125;    &#125;)    <span class="hljs-built_in">document</span>.addEventListener(<span class="hljs-string">'keypress'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>&#123;        <span class="hljs-comment">// console.log(e);</span>        <span class="hljs-built_in">console</span>.log(<span class="hljs-string">'press:'</span> + e.keyCode);    &#125;)&lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="5-JS-执行机制"><a href="#5-JS-执行机制" class="headerlink" title="5.JS 执行机制"></a>5.JS 执行机制</h2><p>JavaScript 语言的一大特点就是单线程，也就是说，同一个时间只能做一件事。</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>同步任务都在主线程上执行，形成一个执行栈。</p><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>JS 的异步是通过回调函数实现的。<br>一般而言，异步任务有以下三种类型:<br>1、普通事件，如 click、resize 等<br>2、资源加载，如 load、error 等<br>3、定时器，包括 setInterval、setTimeout 等<br>异步任务相关回调函数添加到任务队列中（任务队列也称为消息队列）。</p><h3 id="JS执行步骤"><a href="#JS执行步骤" class="headerlink" title="JS执行步骤"></a><strong>JS执行步骤</strong></h3><ol><li><strong>先执行</strong>执行栈中的<strong>同步任务</strong>。</li><li><strong>异步任务</strong>（回调函数）放入<strong>任务队列</strong>中。</li><li>一旦执行栈中的所有<strong>同步任务执行完毕</strong>，系统就会按次序<strong>读取</strong>任务队列中的<strong>异步任务</strong>，于是被读取的异步任务结束等待状态，<strong>进入执行栈</strong>，开始<strong>执行</strong>。<br><img src="https://img-blog.csdnimg.cn/20200605111242706.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>由于主线程不断的重复获得任务、执行任务、再获取任务、再执行，所以这种机制被称为事件循环（ event loop）。</li></ol>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>JavaScript基础语法</title>
    <link href="/2020/06/03/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/"/>
    <url>/2020/06/03/JavaScript%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<p><img src="https://img-blog.csdnimg.cn/20200602233705724.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p><strong>JS 脚本语言–编程类语言</strong></p><p>一种运行在客户端的脚本语言 （Script 是脚本的意思）<br>作用：实现业务逻辑和页面控制( 决定功能 )</p><p><strong>浏览器怎么执行 JS</strong></p><p>浏览器一般由七个模块组成，User Interface（用户界面）、Browser engine（浏览器引擎）、Rendering engine（渲染引擎）、Networking（网络）、JavaScript Interpreter（js解释器）、UI Backend（UI 后端）、Date Persistence（数据持久化存储）<br><strong>渲染引擎</strong>：用来解析HTML与CSS，俗称内核，比如 chrome 浏览器的 blink ，老版本的 webkit<br><strong>JS 引擎</strong>：也称为 JS 解释器。 用来读取网页中的JavaScript代码，对其处理后运行，比如 chrome 浏览器的 V8<br>浏览器本身并不会执行JS代码，而是通过内置 JS 引擎来执行 JS 代码 。JS 引擎执行代码时逐行解释每一句源码（转换为机器语言），然后由计算机去执行</p><h2 id="JS-的组成"><a href="#JS-的组成" class="headerlink" title="JS 的组成"></a>JS 的组成</h2><h3 id="1-ECMAScript"><a href="#1-ECMAScript" class="headerlink" title="1.ECMAScript"></a>1.ECMAScript</h3><p>JS是 ECMAScript 语言的实现和扩展，ECMAScript 规定了JS的编程语法和基础核心知识</p><h3 id="2-DOM（页面文档对象模型）"><a href="#2-DOM（页面文档对象模型）" class="headerlink" title="2.DOM（页面文档对象模型）"></a>2.DOM（页面文档对象模型）</h3><p>是W3C组织推荐的处理可扩展标记语言的标准编程接口。<br>通过 DOM 提供的接口可以对页面上的各种元素进行操作</p><h3 id="3-BOM（浏览器对象模型）"><a href="#3-BOM（浏览器对象模型）" class="headerlink" title="3.BOM（浏览器对象模型）"></a>3.BOM（浏览器对象模型）</h3><p>它提供了独立于内容的、可以与浏览器窗口进行互动的对象结构。<br>通过BOM可以操作浏览器窗口，比如弹出框、控制浏览器跳转、获取分辨率等</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="基本介绍-1"><a href="#基本介绍-1" class="headerlink" title="基本介绍"></a>基本介绍</h3><p>通俗：变量是用于存放数据的容器<br>本质：变量是程序在内存中申请的一块用来存放数据的空间</p><h3 id="变量的使用"><a href="#变量的使用" class="headerlink" title="变量的使用"></a>变量的使用</h3><p>1.声明变量<br><code>var age; // 声明一个 名称为age 的变量</code><br><strong>var</strong> 是一个 JS关键字，用来声明变量( variable 变量的意思 )。使用该关键字声明变量后，计算机会自动为变量分配内存空间<br><strong>age</strong> 是定义的变量名，我们要通过变量名来访问内存中分配的空间</p><p>2.赋值<br><code>age = 10; // 给 age 这个变量赋值为 10</code><br><strong>=</strong> 用来把右边的值赋给左边的变量空间中<br>变量值是保存到变量空间里的值<br>3.变量的初始化<br><code>var age = 18; // 声明变量同时赋值为 18</code><br><strong>声明一个变量并赋值， 我们称之为变量的初始化。</strong></p><h3 id="变量命名规范"><a href="#变量命名规范" class="headerlink" title="变量命名规范"></a>变量命名规范</h3><ol><li>必须以字母(A-Za-z)、下划线(_)、美元符号( $ )开头，后续的字符也可以是数字（0-9）。如：usrAge, num01, _name</li><li>严格区分大小写。var app; 和 var App; 是两个变量</li><li>不能以数字开头。 18age 是错误的</li><li>不能是关键字、保留字。例如：var、for、while</li><li>变量名必须有意义。</li><li>遵守驼峰命名法。首字母小写，后面单词的首字母需要大写。 myFirstName</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="8种数据类型"><a href="#8种数据类型" class="headerlink" title="8种数据类型"></a>8种数据类型</h3><ul><li><p>基本数据类型（值类型/简单数据类型）</p><p>在存储时变量中存储的是值本身,值类型变量的数据直接存放在变量（<strong>栈空间</strong>）中</p><p><strong>简单类型传参</strong><br>函数的形参也可以看做是一个变量，当我们把一个值类型变量作为参数传给函数的形参时，其实是把变量在栈空间里的值复制了一份给形参，那么在方法内部对形参做任何修改，都不会影响到的外部变量。</p><ul><li><p>Number</p><p>既可以用来保存整数值，也可以保存小数(浮点数）<br>数字型三个特殊值</p><div class="hljs"><pre><code class="hljs js">alert(<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// Infinity </span>alert(-<span class="hljs-literal">Infinity</span>); <span class="hljs-comment">// -Infinity </span>alert(<span class="hljs-literal">NaN</span>); <span class="hljs-comment">// NaN</span></code></pre></div><p>Infinity ，代表无穷大，大于任何数值<br>-Infinity ，代表无穷小，小于任何数值<br>NaN ，Not a number，代表一个非数值<br><strong>isNaN()</strong> 用来判断一个变量是否为非数字的类型，返回 true 或者 false</p></li><li><p>String</p><p>字符串型是一串表示文本值的字符序列，其语法为 双引号 “” 和 单引号’’</p><p>因为 <strong>HTML 标签</strong>里面的属性使用的是<strong>双引号</strong>，<strong>JS</strong> 这里我们更推荐使用<strong>单引号</strong>。</p><p>字符串引号嵌套<br>JS 可以用单引号嵌套双引号 ，或者用双引号嵌套单引号 (外双内单，外单内双)<br><strong>字符串转义符</strong><br>转义符都是 \ 开头的，常用的转义符及其说明如下：</p><table><thead><tr><th>转义符</th><th>解释说明</th></tr></thead><tbody><tr><td>\n</td><td>换行符，n 是 newline 的意思</td></tr><tr><td>\ \</td><td>斜杠 \</td></tr><tr><td>&#39;</td><td>‘ 单引号</td></tr><tr><td>&quot;</td><td>”双引号</td></tr><tr><td>\t</td><td>tab 缩进</td></tr><tr><td>\b</td><td>空格 ，b 是 blank 的意思</td></tr></tbody></table><p>字符串长度<br>字符串是由若干字符组成的，这些字符的数量就是字符串的长度。通过字符串的 <strong>length</strong> 属性可以获取整个字符 串的长度。<br><strong>字符串拼接</strong><br>多个字符串之间可以使用 <strong>+</strong> 进行拼接，其拼接方式为 <strong>字符串 + 任何类型 = 拼接之后的新字符串</strong><br>拼接前会把与字符串相加的任何类型转成字符串，再拼接成一个新的字符串</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1.1 字符串 "相加" </span>alert(<span class="hljs-string">'hello'</span> + <span class="hljs-string">' '</span> + <span class="hljs-string">'world'</span>); <span class="hljs-comment">// hello world </span><span class="hljs-comment">//1.2 数值字符串 "相加" </span>alert(<span class="hljs-string">'100'</span> + <span class="hljs-string">'100'</span>); <span class="hljs-comment">// 100100 </span><span class="hljs-comment">//1.3 数值字符串 + 数值 </span>alert(<span class="hljs-string">'11'</span> + <span class="hljs-number">12</span>); <span class="hljs-comment">// 1112</span></code></pre></div><p>口诀：数值相加 ，字符相连<br><strong>字符串拼接加强</strong><br>我们经常会将字符串和变量来拼接，因为变量可以很方便地修改里面的值<br><strong>变量是不能添加引号的，因为加引号的变量会变成字符串</strong><br>如果变量两侧都有字符串拼接，口诀“引引加加 ”，删掉数字，变量写加中间</p></li><li><p>Boolean<br>布尔类型有两个值：true 和 false ，其中 true 表示真（对），而 false 表示假（错）。<br>布尔型和数字型相加的时候， true 的值为 1 ，false 的值为 0。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">true</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 2 </span><span class="hljs-built_in">console</span>.log(<span class="hljs-literal">false</span> + <span class="hljs-number">1</span>); <span class="hljs-comment">// 1</span></code></pre></div></li><li><p>Undefined</p><p>undefined表示“缺少值”，此处应该有一个值，只是声明后没有被赋值</p></li><li><p>Null</p><p>表示“没有对象”，即该处里面存的值为空</p></li><li><p>BigInt</p><p>是一种数字数据类型，可以以任意精度格式表示整数</p></li><li><p>Symbol</p><p>Symbol可以用来创建唯一常量</p></li></ul></li><li><p>引用类型/复杂数据类型：对象（Object）</p><p>在存储时变量中存储的仅仅是地址（引用），因此叫做引用数据类型</p><p>通过 new 关键字创建的对象（系统对象、自定义对象），如 Object、Array、Date等</p><p><strong>引用类型变量（栈空间）里存放的是地址，真正的对象实例存放在堆空间中</strong></p><p><strong>复杂类型传参</strong></p><p>函数的形参也可以看做是一个变量，当我们把引用类型变量传给形参时，其实是把变量在栈空间里保存的堆地址复制给了形参，形参和实参其实保存的是同一个堆地址，所以操作的是同一个对象。</p></li></ul><h3 id="获取变量数据类型"><a href="#获取变量数据类型" class="headerlink" title="获取变量数据类型"></a>获取变量数据类型</h3><ul><li>typeof 检测变量的数据类型，返回一个字符串</li><li>字面量是脚本中按字面意思给出的固定的值，而不是变量。（译注：字面量是常量，其值是固定的，而且在程序脚本运行中不可更改，比如false，3.1415</li></ul><h3 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h3><p>使用表单、prompt 获取过来的数据默认是字符串类型的，此时就不能直接简单的进行加法运算，而需要转换变量的数据类型。通俗来说，就是把一种数据类型的变量转换成另外一种数据类型。</p><ul><li><p>转换为字符串</p><p><strong>toString()</strong><br><code>var num= 1；num.toString()；</code><br>String() 强制转化<br><code>var num =1;String(num);</code><br><strong>加号拼接字符串</strong><br>和字符串拼接的结果都是字符串<br>三种转换方式，第三种加号拼接字符串转换方式也称之为<strong>隐式转换</strong>。</p></li><li><p>转换为数字型（重点）</p><p><strong>1.parseInt()</strong><br>将string类型转成<strong>整数数值型</strong><br><strong>2.parseFloat()</strong><br>将string类型转成<strong>浮点数数值型</strong><br>3.Number()强制转换函数<br>将string类型转成数值型<br>4.js隐式转化（- * /）<br>利用算术运算隐式转换成数值型<br>隐式转换是我们在进行算数运算的时候，JS 自动转换了数据类型</p></li><li><p>转换为布尔型</p><p>Boolean()函数 其它类型转换成布尔值<br>代表空、否定的值会被转换为 false ，如 ‘’、0、NaN、null、undefined ,其余值都会被转换为 true</p></li></ul><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><p>也被称为操作符，是用于实现赋值、比较和执行算数运算等功能的符号。</p><h3 id="算术运算符"><a href="#算术运算符" class="headerlink" title="算术运算符"></a>算术运算符</h3><p>算术运算使用的符号，用于执行两个变量或值的算术运算</p><h3 id="递增和递减运算符"><a href="#递增和递减运算符" class="headerlink" title="递增和递减运算符"></a>递增和递减运算符</h3><p>前置递增运算符<br><strong>++num</strong> 前置递增，就是自加1，类似于 num = num + 1，但是 ++num 写起来更简单。<br>使用口诀：<strong>先自加，后返回值</strong><br>后置递增运算符<br><strong>num++</strong> 后置递增，就是自加1，类似于 num = num + 1 ，但是 num++ 写起来更简单。<br>使用口诀：<strong>先返回原值，后自加</strong></p><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><p>比较运算符（关系运算符）是两个数据进行比较时所使用的运算符，比较运算后，会返回一个布尔值（true / false）作为比较运算的结果</p><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><p>逻辑运算符是用来进行布尔值运算的运算符，其返回值也是布尔值</p><ul><li><p>逻辑与 <strong>&amp;&amp;</strong><br>两边都是 true才返回 true，否则返回 false</p></li><li><p>逻辑或 <strong>||</strong><br>两边都为 false 才返回 false，否则都为true</p></li><li><p>逻辑非 <strong>！</strong><br>逻辑非（!）也叫作取反符，用来取一个布尔值相反的值，如 true 的相反值是 false</p></li><li><p>短路运算（逻辑中断）<br>短路运算的原理：当有多个表达式（值）时,左边的表达式值可以确定结果时,就不再继续运算右边的表达式的值;</p><ul><li><p>逻辑与<br> 语法： 表达式1 &amp;&amp; 表达式2<br> 如果第一个表达式的值为真，则返回表达式2<br> 如果第一个表达式的值为假，则返回表达式1</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-number">456</span> ); <span class="hljs-comment">// 0 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> &amp;&amp; <span class="hljs-number">456</span>&amp;&amp; <span class="hljs-number">789</span> ); <span class="hljs-comment">// 789</span></code></pre></div></li><li><p>逻辑或<br> 语法： 表达式1 || 表达式2<br> 如果第一个表达式的值为真，则返回表达式1<br> 如果第一个表达式的值为假，则返回表达式2</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 123 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">0</span> || <span class="hljs-number">456</span> ); <span class="hljs-comment">// 456 </span><span class="hljs-built_in">console</span>.log( <span class="hljs-number">123</span> || <span class="hljs-number">456</span> || <span class="hljs-number">789</span> ); <span class="hljs-comment">// 123</span></code></pre></div></li></ul></li></ul><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><p>用来把数据赋值给变量的运算符。</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>流程控制就是来控制我们的代码按照什么结构顺序来执行</p><h3 id="顺序结构"><a href="#顺序结构" class="headerlink" title="顺序结构"></a>顺序结构</h3><p>顺序结构是程序中最简单、最基本的流程控制，它没有特定的语法结构，程序会按照代码的先后顺序，依次执行，程序中大多数的代码都是这样执行的。</p><h3 id="分支结构"><a href="#分支结构" class="headerlink" title="分支结构"></a>分支结构</h3><p>由上到下执行代码的过程中，根据不同的条件，执行不同的路径代码（执行代码多选一的过程），从而得到不同的结果<br><strong>if 语句</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立执行代码，否则什么也不做 </span><span class="hljs-keyword">if</span> (条件表达式) &#123; <span class="hljs-comment">// 条件成立执行的代码语句 </span>&#125;</code></pre></div><p>语句可以理解为一个行为，循环语句和分支语句就是典型的语句。一个程序由很多个语句组成，<br><strong>if else语句（双分支语句）</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 条件成立 执行 if 里面代码，否则执行else 里面的代码 </span><span class="hljs-keyword">if</span> (条件表达式) &#123; <span class="hljs-comment">// [如果] 条件成立执行的代码 </span>&#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// [否则] 执行的代码 </span>&#125;</code></pre></div><p><strong>if else if 语句(多分支语句)</strong><br>语法结构</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 适合于检查多重条件。 </span><span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">1</span>) &#123; 语句<span class="hljs-number">1</span>； &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">2</span>) &#123; 语句<span class="hljs-number">2</span>； &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (条件表达式<span class="hljs-number">3</span>) &#123; 语句<span class="hljs-number">3</span>； .... &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 上述条件都不成立执行此处代码 </span>&#125;</code></pre></div><h3 id="三元表达式"><a href="#三元表达式" class="headerlink" title="三元表达式"></a>三元表达式</h3><p>三元表达式也能做一些简单的条件选择。 有三元运算符组成的式子称为三元表达式</p><ol><li>语法结构<br>表达式1 ? 表达式2 : 表达式3;</li><li>执行思路<ul><li>如果表达式1为 true ，则返回表达式2的值，如果表达式1为 false，则返回表达式3的值</li><li>简单理解： 就类似于 if else （双分支） 的简写</li></ul></li></ol><h3 id="switch-语句"><a href="#switch-语句" class="headerlink" title="switch 语句"></a>switch 语句</h3><p>switch 语句也是多分支语句，它用于基于<strong>不同的条件来执行不同的代码</strong>。当要针对变量设置一系列的特定值的选项时，就可以使用 switch。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">switch</span>( 表达式 )&#123; <span class="hljs-keyword">case</span> value1: <span class="hljs-comment">// 表达式 等于 value1 时要执行的代码 </span><span class="hljs-keyword">break</span>; <span class="hljs-keyword">case</span> value2: <span class="hljs-comment">// 表达式 等于 value2 时要执行的代码 </span><span class="hljs-keyword">break</span>; <span class="hljs-keyword">default</span>: <span class="hljs-comment">// 表达式 不等于任何一个 value 时要执行的代码 </span>&#125;</code></pre></div><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><h3 id="1-for循环"><a href="#1-for循环" class="headerlink" title="1.for循环"></a>1.for循环</h3><h3 id="2-while循环"><a href="#2-while循环" class="headerlink" title="2.while循环"></a>2.while循环</h3><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">while</span>语句的语法结构如下：<span class="hljs-keyword">while</span> (条件表达式) &#123;  <span class="hljs-comment">// 循环体代码 </span>&#125;</code></pre></div><p>执行思路：</p><ol><li><p>先执行条件表达式，如果结果为 true，则执行循环体代码；如果为 false，则退出循环，执行后面代码</p></li><li><p>执行循环体代码</p></li><li><p>循环体代码执行完毕后，程序会继续判断执行条件表达式，如条件仍为true，则会继续执行循环体，直到循环条件为 false 时，整个循环过程才会结束</p><p>注意：使用 while 循环时一定要注意，它必须要有退出条件，否则会成为死循环</p></li></ol><h3 id="3-do-while循环"><a href="#3-do-while循环" class="headerlink" title="3.do-while循环"></a>3.do-while循环</h3><p>do… while 语句的语法结构如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">do</span> &#123;  <span class="hljs-comment">// 循环体代码 - 条件表达式为 true 时重复执行循环体代码</span>&#125; <span class="hljs-keyword">while</span>(条件表达式);</code></pre></div><p>执行思路:</p><ol><li>先执行一次循环体代码</li><li>再执行条件表达式，如果结果为 true，则继续执行循环体代码，如果为 false，则退出循环，继续执行后面代码<br>注意：<strong>先再执行循环体，再判断</strong>，do…while循环语句至少会执行一次循环体代码</li></ol><h3 id="continue、break"><a href="#continue、break" class="headerlink" title="continue、break"></a>continue、break</h3><p>continue 关键字用于立即跳出本次循环，继续下一次循环（本次循环体中 continue 之后的代码就会少执行一次）。<br>break 关键字用于立即跳出整个循环（循环结束）。</p><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>数组是指一组数据的集合，其中的每个数据被称作元素，在数组中可以存放任意类型的元素。</p><h3 id="创建数组"><a href="#创建数组" class="headerlink" title="创建数组"></a>创建数组</h3><ul><li><p>new 创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> 数组名 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>() ； <span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>(); <span class="hljs-comment">// 创建一个新的空数组</span></code></pre></div><p>注意 Array () ，A 要大写</p></li><li><p>数组字面量创建数组</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">//1. 使用数组字面量方式创建空的数组 </span><span class="hljs-keyword">var</span> 数组名 = []； <span class="hljs-comment">//2. 使用数组字面量方式创建带初始值的数组 </span><span class="hljs-keyword">var</span> 数组名 = [<span class="hljs-string">'小白'</span>,<span class="hljs-string">'小黑'</span>,<span class="hljs-string">'大黄'</span>,<span class="hljs-string">'瑞奇'</span>];</code></pre></div><p> 数组的字面量是方括号 [ ]<br> 声明数组并赋值称为数组的初始化</p></li></ul><h3 id="获取数组元素"><a href="#获取数组元素" class="headerlink" title="获取数组元素"></a>获取数组元素</h3><p>数组可以通过索引来访问、设置、修改对应的数组元素，我们可以通过“数组名[索引]”的形式来获取数组中的元素。</p><h3 id="遍历数组"><a href="#遍历数组" class="headerlink" title="遍历数组"></a>遍历数组</h3><p>我们可以通过 for 循环索引遍历数组中的每一项<br><strong>数组的长度</strong> 使用“数组名.length”可以访问数组元素的数量（数组长度）。</p><h3 id="数组中新增元素"><a href="#数组中新增元素" class="headerlink" title="数组中新增元素"></a>数组中新增元素</h3><p>1.通过修改 length 长度新增数组元素<br>2.通过修改数组索引新增数组元素</p><ul><li>可以通过修改数组索引的方式追加数组元素</li><li>不能直接给数组名赋值，否则会覆盖掉以前的数据</li></ul><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-string">'red'</span>, <span class="hljs-string">'green'</span>, <span class="hljs-string">'blue'</span>, <span class="hljs-string">'pink'</span>]; arr[<span class="hljs-number">4</span>] = <span class="hljs-string">'hotpink'</span>; <span class="hljs-built_in">console</span>.log(arr);</code></pre></div><p>这种方式也是我们最常用的一种方式。</p><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><p>函数：就是封装了一段可被重复调用执行的代码块</p><h3 id="函数的使用"><a href="#函数的使用" class="headerlink" title="函数的使用"></a>函数的使用</h3><ul><li><p>声明函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params"></span>) </span>&#123; <span class="hljs-comment">//函数体代码 </span>&#125;</code></pre></div><p> function 是声明函数的关键字,必须小写<br> 由于函数一般是为了实现某个功能才定义的， 所以通常我们将函数名命名为动词，比如 getSum</p></li><li><p>调用函数</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 调用函数 </span>函数名(); <span class="hljs-comment">// 通过调用函数名来执行函数体代码</span></code></pre></div><p> 调用的时候千万不要忘记添加小括号<br> 口诀：函数不调用，自己不执行。<br>注意：声明函数本身并不会执行代码，只有调用函数时才会执行函数体代码。</p></li></ul><h3 id="函数的参数"><a href="#函数的参数" class="headerlink" title="函数的参数"></a>函数的参数</h3><p><strong>形参和实参</strong><br>在声明函数时，可以在函数名称后面的小括号中添加一些参数，这些参数被称为形参，而在调用该函数时,同样也需要传递相应的参数，这些参数被称为实参。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 带参数的函数声明 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名(<span class="hljs-params">形参<span class="hljs-number">1</span>, 形参<span class="hljs-number">2</span> , 形参<span class="hljs-number">3.</span>..</span>) </span>&#123; <span class="hljs-comment">// 可以定义任意多的参数，用逗号分隔 </span><span class="hljs-comment">// 函数体 </span>&#125; <span class="hljs-comment">// 带参数的函数调用 </span>函数名(实参<span class="hljs-number">1</span>, 实参<span class="hljs-number">2</span>, 实参<span class="hljs-number">3.</span>..);</code></pre></div><ol><li>调用的时候实参值是传递给形参的</li><li>形参简单理解为：不用声明的变量</li><li>实参和形参的多个参数之间用逗号（,）分隔</li></ol><h3 id="函数的返回值"><a href="#函数的返回值" class="headerlink" title="函数的返回值"></a>函数的返回值</h3><ul><li><p>return 语句</p><p>函数将值返回给调用者，此时通过使用 return 语句就可以实现<br>return 语句的语法格式如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明函数 </span><span class="hljs-function"><span class="hljs-keyword">function</span> 函数名（）</span>&#123; ... <span class="hljs-keyword">return</span> 需要返回的值； &#125; <span class="hljs-comment">// 调用函数 </span>函数名(); <span class="hljs-comment">// 此时调用函数就可以得到函数体内return 后面的值</span></code></pre></div><p>return 语句之后的代码不被执行<br>return 只能返回一个值。如果用逗号隔开多个值，以最后一个为准。</p><p><strong>break ,continue ,return 的区别</strong><br>break ：结束当前的循环体（如 for、while）<br>continue ：跳出本次循环，继续执行下次循环（如 for、while）<br>return ：不仅可以退出循环，还能够返回 return 语句中的值，同时还可以结束当前的函数体内的代码</p></li></ul><h3 id="arguments的使用"><a href="#arguments的使用" class="headerlink" title="arguments的使用"></a>arguments的使用</h3><p>当我们不确定有多少个参数传递的时候，可以用 arguments 来获取。在 JavaScript 中，arguments 实际上它是当前函数的一个内置对象。</p><p>所有函数都内置了一个 arguments 对象，arguments 对象中存储了传递的所有实参。</p><p>arguments展示形式是一个<strong>伪数组</strong>，因此可以进行遍历。伪数组具有以下特点：<br> 具有 length 属性<br> 按索引方式储存数据<br> 不具有数组的 push , pop 等方法</p><h3 id="函数的声明方式"><a href="#函数的声明方式" class="headerlink" title="函数的声明方式"></a>函数的声明方式</h3><ul><li><p>自定义函数方式(命名函数)</p><p>利用函数关键字 function 自定义函数方式。</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 声明定义方式 </span><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span>(<span class="hljs-params"></span>) </span>&#123;...&#125; <span class="hljs-comment">// 调用 </span>fn();</code></pre></div><p> 因为有名字，所以也被称为命名函数<br> 调用函数的代码既可以放到声明函数的前面，也可以放在声明函数的后面</p></li><li><p>函数表达式方式(匿名函数）</p><p>利用函数表达式方式的写法如下：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 这是函数表达式写法，匿名函数后面跟分号结束 </span><span class="hljs-keyword">var</span> fn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>&#123;...&#125;； <span class="hljs-comment">// 调用的方式，函数调用必须写到函数体下面 </span>fn();</code></pre></div><p> 因为函数没有名字，所以也被称为匿名函数<br> 这个fn 里面存储的是一个函数<br> 函数表达式方式原理跟声明变量方式是一致的<br> <strong>函数调用的代码必须写到函数体后面</strong></p></li></ul><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><h3 id="全局作用域"><a href="#全局作用域" class="headerlink" title="全局作用域"></a>全局作用域</h3><p>作用于所有代码执行的环境(整个 script 标签内部)或者一个独立的 js 文件。</p><h3 id="局部作用域"><a href="#局部作用域" class="headerlink" title="局部作用域"></a>局部作用域</h3><p>作用于函数内的代码环境，就是局部作用域。 因为跟函数有关系，所以也称为函数作用域。</p><h3 id="块级作用域"><a href="#块级作用域" class="headerlink" title="块级作用域"></a>块级作用域</h3><p>块作用域由 { } 包括（es6）</p><h3 id="变量作用域的分类"><a href="#变量作用域的分类" class="headerlink" title="变量作用域的分类"></a>变量作用域的分类</h3><p>在JavaScript中，根据作用域的不同，变量可以分为两种：</p><ul><li><p>全局变量</p><ul><li>在全局作用域下声明的变量叫做全局变量（在函数外部定义的变量）。</li><li>全局变量在代码的任何位置都可以使用</li><li>特殊情况下，在函数内不使用全局变量（不建议使用）</li></ul></li><li><p>局部变量</p><ul><li>在局部作用域下声明的变量叫做局部变量（在函数内部定义的变量）</li><li>局部变量只能在该函数内部使用</li><li>函数的形参实际上就是局部变量</li></ul></li></ul><h3 id="作用域链"><a href="#作用域链" class="headerlink" title="作用域链"></a>作用域链</h3><p>采取就近原则的方式来查找变量最终的值。</p><h2 id="预解析"><a href="#预解析" class="headerlink" title="预解析"></a>预解析</h2><p>JavaScript 解析器在运行 JavaScript 代码的时候分为两步：预解析和代码执行。<br><strong>预解析</strong>：在当前作用域下, JS 代码执行之前，浏览器会默认把带有 var 和function 声明的变量在内存中进行提前声明或者定义。<br><strong>代码执行</strong>： 从上到下执行JS语句。</p><p>预解析也叫做变量（函数）提升。</p><h3 id="变量预解析（变量提升）"><a href="#变量预解析（变量提升）" class="headerlink" title="变量预解析（变量提升）"></a>变量预解析（变量提升）</h3><p>变量提升： 变量的声明会被提升到当前作用域的最上面，变量的赋值不会提升</p><h3 id="函数预解析（函数提升）"><a href="#函数预解析（函数提升）" class="headerlink" title="函数预解析（函数提升）"></a>函数预解析（函数提升）</h3><p>函数提升： 函数的声明会被提升到当前作用域的最上面，但是不会调用函数。</p><h2 id="对象"><a href="#对象" class="headerlink" title="对象"></a>对象</h2><p>在 JavaScript 中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象，例如字符串、数值、数组、函数等。<br><strong>对象是由属性和方法组成的</strong>。<br>属性：事物的特征，在对象中用属性来表示（常用名词）<br>方法：事物的行为，在对象中用方法来表示（常用动词）</p><h3 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h3><ul><li><p>字面量创建对象</p><p>对象字面量：就是花括号 { } 里面包含了表达这个具体事物（对象）的属性和方法。</p><p><strong>{ }</strong> 里面采取<strong>键值对</strong>的形式表示<br>键：相当于属性名<br>值：相当于属性值，可以是任意类型的值（数字类型、字符串类型、布尔类型，函数类型等）</p><p><strong>对象的调用</strong></p><ul><li>对象里面的属性调用 : <strong>对象.属性名</strong></li><li>对象里面属性的另一种调用方式 : <strong>对象[‘属性名’]</strong>，注意方括号里面的属性必须加引号</li><li>对象里面的<strong>方法调用</strong>：<strong>对象.方法名()</strong> ，注意这个方法名字后面一定加括号</li></ul></li><li><p>new Object创建对象</p><p>Object() ：第一个字母大写<br>new Object() ：需要 new 关键字<br>使用格式：对象.属性 = 值;</p></li><li><p>构造函数创建对象</p><p><strong>构造函数</strong> ：是一种特殊的函数，主要用来初始化对象，即为对象成员变量赋初始值，它总与 new 运算符一起 使用。我们可以把<strong>对象中一些公共的属性和方法抽取出来，然后封装到这个函数里面</strong>。</p><p>在 js 中，使用构造函数要时要注意以下几点：</p><ul><li>构造函数用于创建某一类对象，其首字母要大写</li><li>函数内的属性和方法前面需要添加 this ，表示当前对象的属性和方法。</li><li>构造函数中不需要 return 返回结果。</li><li>当我们创建对象的时候，必须用 new 来调用构造函数。</li></ul><p><strong>构造函数</strong>，如 Stars()，抽象了<strong>对象的公共部分</strong>，<strong>封装</strong>到了<strong>函数</strong>里面，它泛指<strong>某一大类</strong>（class）<br><strong>创建对象</strong>，如 new Stars()，特指<strong>某一个</strong>，通过 new 关键字创建对象的过程也称为<strong>对象实例化</strong></p></li></ul><h3 id="new关键字"><a href="#new关键字" class="headerlink" title="new关键字"></a>new关键字</h3><p>new 在执行时会做四件事情：</p><ol><li>在内存中创建一个新的空对象。</li><li>让 this 指向这个新的对象。</li><li>执行构造函数里面的代码，给这个新对象添加属性和方法。</li><li>返回这个新对象（所以构造函数里面不需要return）。</li></ol><h3 id="遍历对象属性"><a href="#遍历对象属性" class="headerlink" title="遍历对象属性"></a>遍历对象属性</h3><p>for…in 语句用于对数组或者对象的属性进行循环操作。</p><p>for (变量 in 对象名字) {<br>// 在此执行代码<br>}</p><h2 id="内置对象"><a href="#内置对象" class="headerlink" title="内置对象"></a>内置对象</h2><h3 id="1-Math-对象"><a href="#1-Math-对象" class="headerlink" title="1.Math 对象"></a>1.Math 对象</h3><p><strong>随机数方法 random()</strong><br>random() 方法可以随机返回一个小数，其取值范围是 [0，1)，左闭右开 0 &lt;= x &lt; 1</p><p>案例：得到一个两数之间的随机整数，包括两个数在内</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">getRandom</span>(<span class="hljs-params">min, max</span>) </span>&#123; <span class="hljs-keyword">return</span> <span class="hljs-built_in">Math</span>.floor(<span class="hljs-built_in">Math</span>.random() * (max - min + <span class="hljs-number">1</span>)) + min; &#125;</code></pre></div><p><strong>Math 对象不是构造函数</strong>，具有数学常数和函数的属性和方法<br>Math.PI // 圆周率<br><strong>Math.floor()</strong> // 向下取整<br>Math.ceil() // 向上取整<br>Math.round() // 四舍五入版 就近取整 注意 -3.5 结果是 -3<br><strong>Math.abs()</strong> // 绝对值<br><strong>Math.max()/Math.min()</strong> // 求最大和最小值</p><h3 id="2-日期对象"><a href="#2-日期对象" class="headerlink" title="2.日期对象"></a>2.日期对象</h3><ol><li>获取当前时间必须实例化<br>var now = new Date();<br>console.log(now);</li><li>Date() 构造函数的参数<br><strong>如果括号里面有时间，就返回参数里面的时间</strong>。例如日期格式字符串为‘2019-5-1’，可以写成new Date(‘2019-5-1’) 或者 new Date(‘2019/5/1’)<br>如果Date()不写参数，就返回当前时间</li><li>使用Date实例的方法和属性<br><img src="https://img-blog.csdnimg.cn/20200602234800746.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li><li>获取日期的总的毫秒形式<br>Date 对象是基于1970年1月1日（世界标准时间）起的毫秒数</li></ol><p><strong>Date 对象</strong>和 Math 对象不一样，<strong>是一个构造函数</strong>，所以<strong>需要实例化</strong>后才能使用<br>Date 实例用来处理日期和时间</p><h3 id="3-数组对象"><a href="#3-数组对象" class="headerlink" title="3.数组对象"></a>3.数组对象</h3><h4 id="创建数组的两种方式"><a href="#创建数组的两种方式" class="headerlink" title="创建数组的两种方式"></a>创建数组的两种方式</h4><ul><li><p>字面量方式</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-string">"test"</span>,<span class="hljs-literal">true</span>];</code></pre></div></li><li><p>new Array()</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Array</span>();</code></pre></div><p>注意：上面代码中arr创建出的是一个空数组，如果需要使用构造函数Array创建非空数组，可以在创建数组时传入参数</p><p>参数传递规则如下：</p><ul><li><p>如果只传入一个参数，则参数规定了数组的长度</p></li><li><p>如果传入了多个参数，则参数称为数组的元素</p></li></ul></li></ul><h4 id="检测是否为数组"><a href="#检测是否为数组" class="headerlink" title="检测是否为数组"></a>检测是否为数组</h4><ul><li><p><strong>instanceof 运算符</strong>，可以判断一个对象是否属于某种类型</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(arr <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// false</span></code></pre></div></li><li><p>Array.isArray()</p><p>用于判断一个对象是否为数组，isArray() 是 HTML5 中提供的方法</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">23</span>];<span class="hljs-keyword">var</span> obj = &#123;&#125;;<span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(arr));   <span class="hljs-comment">// true</span><span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">Array</span>.isArray(obj));   <span class="hljs-comment">// false</span></code></pre></div></li></ul><h4 id="添加删除数组元素的方法"><a href="#添加删除数组元素的方法" class="headerlink" title="添加删除数组元素的方法"></a>添加删除数组元素的方法</h4><p>数组中有进行增加、删除元素的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234205992.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：push、unshift为增加元素方法；pop、shift为删除元素的方法</p><h4 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h4><p>数组中有对数组本身排序的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234332535.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：sort方法需要传入参数来设置升序、降序排序</p><ul><li>如果传入“function(a,b){ return a-b;}”，则为升序</li><li>如果传入“function(a,b){ return b-a;}”，则为降序</li></ul><h4 id="数组索引方法"><a href="#数组索引方法" class="headerlink" title="数组索引方法"></a>数组索引方法</h4><p>数组中有获取数组指定元素索引值的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234519153.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h4 id="数组转换为字符串"><a href="#数组转换为字符串" class="headerlink" title="数组转换为字符串"></a>数组转换为字符串</h4><p>数组中有把数组转化为字符串的方法，部分方法如下表</p><p><img src="https://img-blog.csdnimg.cn/20200602234554828.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p>注意：join方法如果不传入参数，则按照 “ , ”拼接元素</p><h4 id="其他方法"><a href="#其他方法" class="headerlink" title="其他方法"></a>其他方法</h4><p><img src="https://img-blog.csdnimg.cn/20200602234613578.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="4-字符串对象"><a href="#4-字符串对象" class="headerlink" title="4.字符串对象"></a>4.字符串对象</h3><ul><li><p>基本包装类型</p><p>基本包装类型就是把简单数据类型包装成为复杂数据类型，这样基本数据类型就有了属性和方法。</p><p>js 会把基本数据类型包装为复杂数据类型，其执行过程如下 ：</p><div class="hljs"><pre><code class="hljs js"><span class="hljs-comment">// 1. 生成临时变量，把简单类型包装为复杂数据类型</span><span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">String</span>(<span class="hljs-string">'andy'</span>);<span class="hljs-comment">// 2. 赋值给我们声明的字符变量</span>str = temp;<span class="hljs-comment">// 3. 销毁临时变量</span>temp = <span class="hljs-literal">null</span>;</code></pre></div></li><li><p>字符串的不可变</p><ul><li>指的是里面的值不可变，虽然看上去可以改变内容，但其实是地址变了，内存中新开辟了一个内存空间。</li></ul></li><li><p>根据字符返回位置</p><p>字符串所有的方法，都不会修改字符串本身(字符串是不可变的)，操作完成会返回一个新的字符串</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235548446.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>根据位置返回字符</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是根据位置返回指定位置上的字符：</p></li></ul><p><img src="https://img-blog.csdnimg.cn/20200602235521853.png#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><ul><li><p>字符串操作方法</p><p>字符串通过基本包装类型可以调用部分方法来操作字符串，以下是部分操作方法：<br><img src="https://img-blog.csdnimg.cn/20200602235609516.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li><li><p>replace()方法</p><ul><li>replace() 方法用于在字符串中用一些字符替换另一些字符。<br>其使用格式如下：<br><code>replace(被替换的字符串， 要替换为的字符串)；</code></li></ul></li><li><p>split()方法</p><ul><li>split()方法用于切分字符串，它可以将字符串切分为数组。在切分完毕之后，返回的是一个新数组。<br>例如下面代码：<br><code>var str = &#39;a,b,c,d&#39;;</code><br><code>console.log(str.split(&#39;,&#39;)); // 返回的是一个数组 [a, b, c, d]</code></li></ul></li></ul><h2 id="JavaScript-输入输出语句"><a href="#JavaScript-输入输出语句" class="headerlink" title="JavaScript 输入输出语句"></a>JavaScript 输入输出语句</h2><h3 id="alert-msg"><a href="#alert-msg" class="headerlink" title="alert(msg)"></a>alert(msg)</h3><p>浏览器弹出警示框</p><h3 id="console-log-msg"><a href="#console-log-msg" class="headerlink" title="console.log(msg)"></a>console.log(msg)</h3><p>浏览器控制台打印输出信息</p><h3 id="prompt-info"><a href="#prompt-info" class="headerlink" title="prompt(info)"></a>prompt(info)</h3><p>浏览器弹出输入框，用户可以输入</p>]]></content>
    
    
    <categories>
      
      <category>JS</category>
      
    </categories>
    
    
    <tags>
      
      <tag>JavaScript基础</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>前端面试——CSS篇一</title>
    <link href="/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87%E4%B8%80/"/>
    <url>/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="盒子水平垂直居中的五大方案"><a href="#盒子水平垂直居中的五大方案" class="headerlink" title="盒子水平垂直居中的五大方案"></a>盒子水平垂直居中的五大方案</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span> auto;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;    &#125;<span class="hljs-selector-class">.box</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><p>定位（三种）<br>1.使用定位移动box盒子到container盒子的宽高一半的位置，再使用margin移动box盒子宽高的一半（需要设置box盒子的宽高，并设置相应的位移）</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">position</span>: relative;   &#125;   <span class="hljs-selector-class">.box</span>&#123;       <span class="hljs-attribute">position</span>: absolute;       <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;     &#125;</code></pre></div><p>2.需要设置box盒子的宽高，不需要设置相应的位移</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>:auto; &#125;</code></pre></div><p>3.使用css3的transform属性，可以不用设置box盒子的宽高，让盒子内容撑开宽高，有兼容性问题</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);&#125;</code></pre></div><p>4.给居中盒子的父元素使用display:flex，可以不用设置box盒子的宽高，让盒子内容撑开宽高，有兼容性问题</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">display</span>: flex;       <span class="hljs-attribute">justify-content</span>: center;       <span class="hljs-attribute">align-items</span>: center;   &#125;</code></pre></div><p>5.使用js,需要给container设置相对定位，并且给container和box设置id(js可以根据id获取该元素)</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;        <span class="hljs-keyword">let</span> cWidth = container.offsetWidth,            cHeight = container.offsetHeight,            bWidth = box.offsetWidth,            bHeight = box.offsetHeight;        box.style.position = <span class="hljs-string">"absolute"</span>;        box.style.left = (cWidth-bWidth)/<span class="hljs-number">2</span> + <span class="hljs-string">'px'</span>;        box.style.top = (cHeight-bHeight)/<span class="hljs-number">2</span> +<span class="hljs-string">'px'</span>;    &lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="css3盒模型"><a href="#css3盒模型" class="headerlink" title="css3盒模型"></a>css3盒模型</h2><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p><img src="https://img-blog.csdnimg.cn/20200531130423268.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。<br>CSS如何设置标准盒模型<br>box-sizing:conent-box;<br>问题：当增加内边距、边框和外边距时，不会影响内容区域的尺寸，但是会增加元素框的总尺寸。<br>解决方法：box-sizing:border-box;</p><h3 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h3><p><img src="https://img-blog.csdnimg.cn/20200531130514396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。<br>CSS如何设置IE盒子模型<br>box-sizing:border-box;</p><h2 id="CSS-页面常用布局"><a href="#CSS-页面常用布局" class="headerlink" title="CSS 页面常用布局"></a>CSS 页面常用布局</h2><p>中间自适应，两边定宽</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 解决浮动引起的高度塌陷 */</span><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;       <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;       <span class="hljs-attribute">clear</span>: both;       <span class="hljs-attribute">display</span>: block;   &#125;<span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">float</span>: left;   &#125;   <span class="hljs-comment">/* 中间部分宽度自适应 */</span>   <span class="hljs-selector-class">.center</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;   &#125;   <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-comment">/* 左边栏使用margin-left移动中间部分的宽度，再使用相对定位向左移动自身的宽度 */</span>   <span class="hljs-selector-class">.left</span>&#123;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;       <span class="hljs-attribute">position</span>: relative;       <span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;   &#125;</code></pre></div><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><ul><li>left、container、right都设置左浮动</li><li>设置container宽度为100%</li><li>设置负边距，left设置margin-left为100%，right设置margin-left为自身宽度</li><li>设置center的margin值为left和right宽度，为左右两个侧栏留出空间</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">" clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;        <span class="hljs-attribute">clear</span>: both;        <span class="hljs-attribute">display</span>: block;    &#125;    <span class="hljs-selector-class">.container</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">float</span>: left;    &#125;    <span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    &#125;        <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;         <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;     &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;    &#125;    <span class="hljs-selector-class">.left</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;    &#125;    <span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;    &#125;</code></pre></div><h2 id="Flex弹性布局"><a href="#Flex弹性布局" class="headerlink" title="Flex弹性布局"></a>Flex弹性布局</h2><p>缺点：仅支持 IE9 以上浏览器</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: flex;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;    &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        /* flex: 0 0 200px; */ 与使用宽度能够实现同样的效果    &#125;    <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><h2 id="Grid-布局-网格布局"><a href="#Grid-布局-网格布局" class="headerlink" title="Grid 布局(网格布局)"></a>Grid 布局(网格布局)</h2><p>grid-template-columns属性定义每一列的列宽<br>grid-template-rows属性定义每一行的行高</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: grid;        <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span>;<span class="hljs-comment">/* 设置列宽，也可使用百分比 */</span>    &#125;     <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;      &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>面试CSS篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试 CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件化开发——学习笔记二</title>
    <link href="/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组件化基本介绍"><a href="#组件化基本介绍" class="headerlink" title="组件化基本介绍"></a>组件化基本介绍</h3><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ol><li>将一个完整的页面分成很多个组件。</li><li>每个组件都用于实现页面的一个功能块。</li><li>而每一个组件又可以进行细分。</li></ol><h4 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a><strong>Vue组件化思想</strong></h4><ul><li>提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树。<br><img src="https://img-blog.csdnimg.cn/20200530111834826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p>组件化思想的应用：</p><ul><li>尽可能的将页面拆分成一个个小的、可复用的组件。</li><li>让我们的代码更加方便组织和管理，并且扩展性也更强。</li></ul><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a><strong>注册组件</strong></h3><h4 id="组件的使用分成三个步骤"><a href="#组件的使用分成三个步骤" class="headerlink" title="组件的使用分成三个步骤"></a>组件的使用分成三个步骤</h4><p><img src="https://img-blog.csdnimg.cn/20200530112014942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.创建组件构造器</strong></p><p><strong>Vue.extend()：</strong></p><ol><li>调用Vue.extend()创建的是一个组件构造器。</li><li>通常在创建组件构造器时，传入template代表我们自定义组件的模板。</li><li>该模板就是在使用到组件的地方，显示HTML代码。</li></ol><p><strong>2.注册组件</strong></p><p><strong>Vue.component()：</strong></p><p>调用Vue.component()是将组件构造器注册为一个组件，并且给它起一个组件的标签名称。</p><p>需要传递两个参数：1、注册组件的标签名 2、组件构造器</p><p><strong>3.使用组件</strong></p><p>组件必须挂载在某个Vue实例下，否则它不会生效。</p><h4 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h4><p>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p><h4 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h4><p>Vue提供了两种方案来定义HTML模块内容：</p><ul><li>使用<code>&lt;script&gt;</code>标签</li><li>使用<code>&lt;template&gt;</code>标签</li></ul><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a><strong>全局组件和局部组件</strong></h3><p><strong>全局组件</strong></p><p>调用Vue.component()注册组件时，组件的注册是全局的,意味着该组件可以在任意Vue示例下使用</p><p><strong>局部组件</strong></p><p>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p><h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a><strong>父组件和子组件</strong></h3><h4 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h4><p><img src="https://img-blog.csdnimg.cn/20200530112106840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.父子组件间传递数据</strong></p><ul><li><strong>父组件向子组件传递（通过props）</strong></li></ul><p>在组件中，使用选项props来声明需要从父级接收到的数据</p><p>props的值有两种方式：</p><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p><p>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</p><p><strong>props数据验证</strong></p><p>当需要对props进行类型等验证时，就需要使用对象写法</p><p>验证都支持哪些数据类型呢？</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li><li>自定义函数</li></ul><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component'</span>, &#123;  props: &#123;<span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span>propA: <span class="hljs-built_in">Number</span>,<span class="hljs-comment">// 多个可能的类型</span>propB: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],<span class="hljs-comment">// 必填的字符串</span>propC: &#123;  type: <span class="hljs-built_in">String</span>,  required: <span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">// 带有默认值的数字</span>propD: &#123;  type: <span class="hljs-built_in">Number</span>,  <span class="hljs-keyword">default</span>: <span class="hljs-number">100</span>&#125;,<span class="hljs-comment">// 带有默认值的对象</span>propE: &#123;  type: <span class="hljs-built_in">Object</span>,  <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span>  <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span> &#125;  &#125;&#125;,<span class="hljs-comment">// 自定义验证函数</span>propF: &#123;  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">'success'</span>, <span class="hljs-string">'warning'</span>, <span class="hljs-string">'danger'</span>].indexOf(value) !== <span class="hljs-number">-1</span>  &#125;&#125;&#125;&#125;)</code></pre></div><p>注意这些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。</p><ul><li><strong>子组件向父组件传递（自定义事件）</strong></li></ul><p>​ 自定义事件的流程：</p><ol><li>在<strong>子组件</strong>中，通过<strong>$emit()</strong>来触发事件。</li><li>在<strong>父组件</strong>中，通过<strong>v-on</strong>来监听子组件事件。</li></ol><p><strong>2.父子组件的访问方式</strong></p><ul><li><p><strong>父组件访问子组件（使用$children或$refs）</strong></p><p>$children的访问</p><p>this.$children是一个数组类型，它包含所有子组件对象。</p><p>$children的<strong>缺陷</strong>：</p><ol><li>通过<strong>$children</strong>访问子组件时，是一个<strong>数组类型</strong>，<strong>访问其中的子组件</strong>必须通过<strong>索引值</strong>。</li><li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</li><li>有时候，我们想明确获取其中一个<strong>特定的组件</strong>，这个时候就可以使用<strong>$refs</strong></li></ol><p><strong>$refs的使用</strong>：</p><ul><li>$refs和<strong>ref指令</strong>通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过<strong>this.$refs.ID</strong>就可以访问到该组件了。</li></ul></li><li><p><strong>子组件访问父组件（使用$parent）</strong></p><p>真实开发中尽量不要使用</p></li></ul><h3 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a>组件数据存放</h3><p><strong>组件中不能直接访问Vue实例中的data数据</strong></p><p>组件自己的数据存放在哪里呢?</p><ul><li>组件对象也有一个data属性(也可以有methods等属性)</li><li>只是这个data属性必须是一个<strong>函数</strong></li><li>而且这个函数需要<strong>返回</strong>一个<strong>对象</strong>，对象内部保存着数据</li></ul><p>为什么data在组件中必须是一个函数呢?</p><p>首先，如果不是一个函数，Vue直接就会报错。</p><p>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</p><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a><strong>编译作用域</strong></h4><p>官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p>组件的插槽：</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li><li>让使用者可以决定组件内部到底展示什么内容。</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><p>如何使用slot？</p><p>在子组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为子组件开启一个插槽。</p><p>该插槽插入什么内容取决于父组件如何使用</p><h4 id="slot分类"><a href="#slot分类" class="headerlink" title="slot分类"></a><strong>slot分类</strong></h4><p><strong>1.具名插槽slot</strong></p><p>如何使用具名插槽呢？</p><p>非常简单，只要给slot元素一个name属性即可</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'myslot'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></code></pre></div><p><strong>2.作用域插槽</strong></p><p><strong>父组件替换插槽的标签，但是内容由子组件来提供</strong></p><p>可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去，绑定在 <code>&lt;slot&gt;</code>元素上的 attribute 被称为插槽 prop。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span>  &#123;&#123; user.lastName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p>现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>    &#123;&#123; slotProps.user.firstName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre></div><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flex布局</title>
    <link href="/2020/05/31/Flex%E5%B8%83%E5%B1%80/"/>
    <url>/2020/05/31/Flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>该文章是根据阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>和MDN——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">flex布局的基本概念</a>整理得出的。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”<br>任何一个容器都可以指定为 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>行内项目也可以使用 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: inline-flex;&#125;</code></pre></div><p>Webkit 内核的浏览器，必须加上-webkit前缀</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: -webkit-flex; <span class="hljs-comment">/* Safari */</span>  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>注意，设为 Flex 布局以后，容器中的直系子元素就会变为 flex 元素,并且子元素的<strong>float</strong>、<strong>clear</strong>和<strong>vertical-align</strong>属性将失效。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的项目，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="https://img-blog.csdnimg.cn/20200531101024720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li><strong>flex-direction</strong></li></ul><p>flex-direction属性决定主轴的方向（即flex 项目的排列方向）</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</code></pre></div><p>row（默认值）：主轴为水平方向，起点在左端。<br>row-reverse：主轴为水平方向，起点在右端。<br>column：主轴为垂直方向，起点在上沿。<br>column-reverse：主轴为垂直方向，起点在下沿。</p><ul><li><strong>flex-wrap</strong></li></ul><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</code></pre></div><p>1）nowrap（默认）：不换行。<br>2）wrap：换行，第一行在上方。<br>3）wrap-reverse：换行，第一行在下方。</p><ul><li><p><strong>flex-flow</strong></p><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre></div><ul><li><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上（水平方向）的对齐方式。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre></div><p>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔相等。<br>space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</p><ul><li><strong>align-items</strong><br>align-items属性定义项目在交叉轴上（垂直方向）如何对齐</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><ul><li>align-content<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre></div><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>order属性<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></div><ul><li><strong>flex-grow属性</strong><br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></div><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><ul><li><strong>flex-shrink属性</strong><br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-shrink 属性只能是一个 <code>&lt;number&gt;</code>。负值对该属性无效。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></div><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><ul><li><strong>flex-basis属性</strong><br>flex-basis属性定义了项目的空间大小。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p>取值<br>&lt;’width’&gt;<br>width 值可以是<code>&lt;length&gt;</code>; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。<br>content<br>基于 flex 项目的内容自动调整大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 指定&lt;'width'&gt; */</span><span class="hljs-selector-tag">flex-basis</span>: 10<span class="hljs-selector-tag">em</span>;<span class="hljs-selector-tag">flex-basis</span>: 3<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">auto</span>;<span class="hljs-comment">/* 在flex item内容上的自动尺寸 */</span><span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">content</span>;</code></pre></div><p>如果没有给项目设定尺寸，flex-basis 的值采用项目内容的尺寸。这就解释了：我们给只要给Flex项目的容器声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示项目的内容。<br>Note: 当一个项目同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) , flex-basis 具有更高的优先级.</p><ul><li><p><strong>flex属性</strong></p><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">'flex-grow'</span>&gt; &lt;<span class="hljs-string">'flex-shrink'</span>&gt;? || &lt;<span class="hljs-string">'flex-basis'</span>&gt; ]&#125;</code></pre></div><p>下面是几种预定义的值：<br><strong>flex: initial</strong><br>把flex项目重置为Flexbox的初始值，它相当于 <strong>flex: 0 1 auto</strong>。</p><p>解析：flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p>​ flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​ flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p><strong>flex: auto</strong><br>flex: auto 等同于 <strong>flex: 1 1 auto</strong>；这种情况下，flex项目在需要的时候既可以拉伸也可以收缩</p><p>解析：所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</p><p>​ flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​ flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><p><strong>flex: none</strong><br>flex: none 可以把flex项目设置为不可伸缩。它和设置为 <strong>flex: 0 0 auto</strong> 是一样的。项目既不能拉伸或者收缩，但是项目会按具有 flex-basis: auto 属性的flexbox进行布局。</p><ul><li>align-self属性<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    
    <categories>
      
      <category>flex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js学习笔记一</title>
    <link href="/2020/05/28/Vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2020/05/28/Vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue-js介绍"><a href="#Vue-js介绍" class="headerlink" title="Vue.js介绍"></a>Vue.js介绍</h3><p><strong>1.渐进式JavaScript框架</strong></p><p>框架和库的区别：</p><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p></li><li><p>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</p></li></ul><p><strong>2.特点和功能</strong></p><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><p><img src="https://img-blog.csdnimg.cn/20200529180100715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>View层（视图层）</strong></p><ul><li>前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul><p><strong>Model层（数据层）</strong></p><ul><li>数据可能是固定的死数据，更多的是来自服务器，从网络上请求下来的数据。</li></ul><p><strong>VueModel层（视图模型层）</strong></p><ul><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul><p><strong>后端（Node）中的 MVC 与 前端中的 MVVM 之间的区别</strong></p><ol><li><p>MVC 是后端的分层开发概念；</p></li><li><p>MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM（ViewModel）</p><p><img src="https://img-blog.csdnimg.cn/20200529180156561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p>1.生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件统称为生命周期</p><p>2.主要的生命周期函数分类：</p><ul><li><p>创建期间的生命周期函数：</p><ul><li><p>beforeCreate：实例对象初始化之后，此时，还没有初始化好 data 和 methods 属性</p></li><li><p>created：实例创建完成后，data和methods都已经被初始化好了</p><p>注：如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作</p></li><li><p>beforeMount：此函数执行的时候，已经完成了模板的编译，但是还没有挂载到页面中，页面并没有内容</p></li><li><p>mounted：Vue实例已经初始化完毕，编译好的HTML挂载到页面，组件脱离创建阶段，进入运行阶段</p><p>注：1.如果要通过插件操作页面的DOM节点，最早要在mounted中进行（一般会做一些ajax请求获取数据，进行数据初始化）</p><p>2.mounted在整个实例中只执行一次</p></li></ul></li><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li></ul></li><li><p>销毁期间的生命周期函数：</p><ul><li><p>beforeDestroy：实例销毁之前执行的钩子，Vue实例已经从运行阶段进入销毁阶段，实例仍然完全可用</p></li><li><p>destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</p><p><img src="https://img-blog.csdnimg.cn/20200529180359828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目（仿外卖APP）</title>
    <link href="/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/"/>
    <url>/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>项目:关于外卖业务的前后台分离Web App</strong></p><ul><li>前台应用技术架构为: vue + vuex + vue-router + webpack + ES6；</li><li>核心功能模块:商家, 商品, 购物车, 评论,用户等多个子模块;</li><li>采用模块化、组件化、工程化的模式开发；</li><li>后台使用 mockjs 模拟后台数据接口和API接口;</li></ul><p><strong>项目展示地址(<a href="http://tq07.gitee.io/vue-food" target="_blank" rel="noopener">点击前往</a>)</strong><br><img src="https://img-blog.csdnimg.cn/20200430112702320.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702290.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702280.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>学习心得：</strong></p><p>1) 熟悉一个项目的开发流程<br>2) 学会组件化、模块化、工程化的开发模式<br>3) 掌握使用 vue-cli 脚手架初始化 Vue.js 项目<br>4) 学会模拟 json 后端数据，实现前后端分离开发<br>5) 掌握一些项目优化技巧</p><p><strong>项目中使用的Vue 插件或第三方库</strong></p><ul><li>使用 vue-router 开发单页应用</li><li>使用 axios/vue-resource 与后端进行数据交互</li><li>使用 vuex 管理应用组件状态</li><li>使用 better-scroll/vue-scroller 实现页面滑动效果</li><li>使用 mint-ui 组件库构建界面</li><li>使用 vue-lazyload 实现图片惰加载</li><li>使用 mockjs 模拟后台数据接口</li></ul><p><strong>样式和布局</strong></p><ul><li>使用 stylus 编写模块化的 CSS</li><li>使用 Vue.js 的过渡编写酷炫的交互动画</li></ul><h3 id="项目中遇到的问题（难点）和项目优化方法"><a href="#项目中遇到的问题（难点）和项目优化方法" class="headerlink" title="项目中遇到的问题（难点）和项目优化方法"></a>项目中遇到的问题（难点）和项目优化方法</h3><p>1.解决点击响应延时 0.3s 问题<br>原因：当用户一次点击屏幕之后，浏览器并不能立刻判断用户是否要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。<br>解决方法：利用FastClick，其原理是检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉</p><div class="hljs"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;fastclick&#x2F;1.0.6&#x2F;fastclick.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;      if(&#39;addEventListener&#39; in document)&#123;        document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;          FastClick.attach(document.body);        &#125;,false)      &#125;      if(!window.Promise) &#123;       document.writeln(&#39;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;es6-promise&#x2F;3.2.2&#x2F;es6-promise.min.js&quot; &#39;+&#39;&gt;&#39;+&#39;&lt;&#39;+&#39;&#x2F;&#39;+&#39;script&gt;&#39;);       &#125;    &lt;&#x2F;script&gt;</code></pre></div><p>2.后台应用</p><blockquote><p>后台应用负责处理前台应用提交的请求, 并给前台应用返回 json 数据<br>前台应用负责展现数据, 与用户交互, 与后台应用交互<br>API接口 <a href="https://github.com/bailicangdu/node-elm/blob/master/API.md" target="_blank" rel="noopener">githup上面找的API接口</a></p></blockquote><p>3.封装 ajax 请求模块</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; ajax 请求函数模块import axios from &#39;axios&#39;export default function ajax(url&#x3D;&#39;&#39;,data&#x3D;&#123;&#125;,type&#x3D;&#39;GET&#39;)&#123;    return new Promise(function(resolve, reject)&#123;        &#x2F;&#x2F; 执行axios异步请求        let promise           if (type &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;             &#x2F;&#x2F; 准备 url query 参数数据             let dataStr &#x3D; &#39;&#39; &#x2F;&#x2F;数据拼接字符串             Object.keys(data).forEach(key &#x3D;&gt; &#123;                 dataStr +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;            &#125;)            if (dataStr !&#x3D;&#x3D; &#39;&#39;) &#123;             dataStr &#x3D; dataStr.substring(0, dataStr.lastIndexOf(&#39;&amp;&#39;))             url &#x3D; url + &#39;?&#39; + dataStr             &#125;            &#x2F;&#x2F; 发送 get 请求             promise &#x3D; axios.get(url)         &#125; else &#123;             &#x2F;&#x2F; 发送 post 请求             promise &#x3D; axios.post(url,data)         &#125;        promise.then(response &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用resolve()            resolve(response)         &#125;).catch(error &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用reject()            reject(error)         &#125;)     &#125;)&#125;</code></pre></div><p>4.vuex 应用组件状态<br>vuex 的核心管理对象 <strong>store 对象模块</strong><br>state模块：状态对象<br>mutation type 常量名称模块<br>mutations 模块 ：直接更新state的多个方法的对象<br>actions 模块：通过mutations间接更新state的多个方法的对象</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F;store 对象模块import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;.&#x2F;state&#39;import mutations from &#39;.&#x2F;mutations&#39; import actions from &#39;.&#x2F;actions&#39;import getters from &#39;.&#x2F;getters&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state,  mutations,   actions,  getters,&#125;)</code></pre></div><p>5.模拟(mock)数据/接口<br>利用 mockjs 拦截 ajax 请求, 生成随机数据返回<br><a href="http://mockjs.com/" target="_blank" rel="noopener">mockjs</a></p><p>6.ShopGoods 组件</p><ul><li><p>内部使用了另外 3 个组件<br>a. ShopCart: 购物车组件<br>b. Cart: 购物车操作组件<br>c. Food: 食品详情组件</p></li><li><p>使用第三方库 better-scroll: UI 滑动</p><p>问题：Cart组件在添加食物的时候，第一次增加时, 没有 count，如果直接添加属性并赋值，新添加的属性没有数据劫持==&gt;数据绑定==&gt;更新了数据但界面不变<br>解决方法：Vue.set(food, ‘count’, 1) 给有数据绑定的对象添加指定属性名和值的属性(有绑定)<br>7.项目优化/扩展<br>（1）缓存路由组件对象</p></li></ul><div class="hljs"><pre><code class="hljs plain">&lt;keep-alive&gt; &lt;router-view &#x2F;&gt; &lt;&#x2F;keep-alive&gt;</code></pre></div><p>好处: 复用路由组件对象, 复用路由组件获取的后台数据<br>（2）路由组件懒加载</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; 返回路由组件的函数，只有执行该函数才会加载路由组件，这个函数在请求对应的路由路径时才会执行const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Home.vue&#39;)const Order &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Order.vue&#39;)const Search &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Search.vue&#39;)const Profile &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Profile.vue&#39;)</code></pre></div><p>8.打包文件分析与优化</p><p>1) vue 脚手架提供了一个用于可视化分析打包文件的包 webpack-bundle-analyzer 和配置<br>2) 启用打包可视化: npm run build – –report</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo+github搭建个人博客</title>
    <link href="/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是基于 Node.js 开发的一个静态博客生成器，提供本地实时预览及部署功能。</p><h3 id="1-安装node和npm-或者cnpm"><a href="#1-安装node和npm-或者cnpm" class="headerlink" title="1.安装node和npm (或者cnpm)"></a>1.安装node和npm (或者cnpm)</h3><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p>前两步我之前已经安装过 ，就不详细记述了</p><p><strong>3.1 全局安装hexo</strong></p><div class="hljs"><pre><code class="hljs plain">npm install -g hexo-cli</code></pre></div><p><strong>3.2 安装 Hexo 完成后，在指定的目录执行下列命令，Hexo 将会指定的文件夹中新建所需要的文件</strong></p><div class="hljs"><pre><code class="hljs plain">hexo init blog</code></pre></div><p><strong>3.3 在指定文件夹下，启动本地预览服务</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<span class="hljs-comment"># 启动本地预览服务，默认是 127.0.0.1:4000（简写hexo s）</span>hexo server</code></pre></div><p>也可以参考 Hexo 官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a> , 里面有具体的使用方式。</p><h3 id="4-注册githup账号并新建仓库"><a href="#4-注册githup账号并新建仓库" class="headerlink" title="4.注册githup账号并新建仓库"></a>4.注册githup账号并新建仓库</h3><p>新建一个名为<code>你的用户名.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来个人博客访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://用户名.github.io</a></p><h3 id="5-自动发布-Hexo-搭建的静态博客"><a href="#5-自动发布-Hexo-搭建的静态博客" class="headerlink" title="5.自动发布 Hexo 搭建的静态博客"></a>5.自动发布 Hexo 搭建的静态博客</h3><p><strong>5.1先修改 <code>_config.yml</code> 配置文件</strong></p><p>下面是一个示例：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github用户名:密码@github.com/sherlockkid7/sherlockkid7.github.io.git</span></code></pre></div><p>上面的配置选项中，一定要注意在 repo 中按照对应的格式加入 Github 用户名和密码。</p><p><strong>5.2安装自动发布的插件</strong></p><div class="hljs"><pre><code class="hljs bash">npm install hexo-deployer-git --save</code></pre></div><p><strong>5.3使用命令一键进行发布</strong></p><div class="hljs"><pre><code class="hljs bash">hexo generate --deploy<span class="hljs-comment"># 或者</span>hexo deploy --generate</code></pre></div><p>上面两条命令都可以，发布可能有延时，稍微等待即可。</p><h3 id="6-新建文章"><a href="#6-新建文章" class="headerlink" title="6.新建文章"></a>6.新建文章</h3><div class="hljs"><pre><code class="hljs plain">hexo new 文章标题</code></pre></div><h3 id="7-修改默认hexo主题"><a href="#7-修改默认hexo主题" class="headerlink" title="7.修改默认hexo主题"></a>7.修改默认hexo主题</h3><p>在github下载hexo-theme-fluid-1.8.0主题，并解压到themes文件夹中，修改 <code>_config.yml</code> 配置文件(注主题文件可以重命名为fluid)</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
