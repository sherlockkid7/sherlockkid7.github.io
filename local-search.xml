<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>前端面试——CSS篇一</title>
    <link href="/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87%E4%B8%80/"/>
    <url>/2020/05/31/%E5%89%8D%E7%AB%AF%E9%9D%A2%E8%AF%95%E2%80%94%E2%80%94CSS%E7%AF%87%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h2 id="盒子水平垂直居中的五大方案"><a href="#盒子水平垂直居中的五大方案" class="headerlink" title="盒子水平垂直居中的五大方案"></a>盒子水平垂直居中的五大方案</h2><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">50px</span> auto;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#f5f5f5</span>;    &#125;<span class="hljs-selector-class">.box</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><p>定位（三种）<br>1.使用定位移动box盒子到container盒子的宽高一半的位置，再使用margin移动box盒子宽高的一半（需要设置box盒子的宽高，并设置相应的位移）</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">position</span>: relative;   &#125;   <span class="hljs-selector-class">.box</span>&#123;       <span class="hljs-attribute">position</span>: absolute;       <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;       <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;     &#125;</code></pre></div><p>2.需要设置box盒子的宽高，不需要设置相应的位移</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">right</span>:<span class="hljs-number">0</span>;    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;    <span class="hljs-attribute">margin</span>:auto; &#125;</code></pre></div><p>3.使用css3的transform属性，可以不用设置box盒子的宽高，让盒子内容撑开宽高，有兼容性问题</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;    <span class="hljs-attribute">position</span>: relative;&#125;<span class="hljs-selector-class">.box</span>&#123;    <span class="hljs-attribute">position</span>: absolute;    <span class="hljs-attribute">top</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">left</span>:<span class="hljs-number">50%</span>;    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);&#125;</code></pre></div><p>4.给居中盒子的父元素使用display:flex，可以不用设置box盒子的宽高，让盒子内容撑开宽高，有兼容性问题</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">display</span>: flex;       <span class="hljs-attribute">justify-content</span>: center;       <span class="hljs-attribute">align-items</span>: center;   &#125;</code></pre></div><p>5.使用js,需要给container设置相对定位，并且给container和box设置id(js可以根据id获取该元素)</p><div class="hljs"><pre><code class="hljs js">&lt;script&gt;        <span class="hljs-keyword">let</span> cWidth = container.offsetWidth,            cHeight = container.offsetHeight,            bWidth = box.offsetWidth,            bHeight = box.offsetHeight;        box.style.position = <span class="hljs-string">"absolute"</span>;        box.style.left = (cWidth-bWidth)/<span class="hljs-number">2</span> + <span class="hljs-string">'px'</span>;        box.style.top = (cHeight-bHeight)/<span class="hljs-number">2</span> +<span class="hljs-string">'px'</span>;    &lt;<span class="hljs-regexp">/script&gt;</span></code></pre></div><h2 id="css3盒模型"><a href="#css3盒模型" class="headerlink" title="css3盒模型"></a>css3盒模型</h2><h3 id="标准盒模型"><a href="#标准盒模型" class="headerlink" title="标准盒模型"></a>标准盒模型</h3><p><img src="https://img-blog.csdnimg.cn/20200531130423268.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>在标准盒子模型中，width 和 height 指的是内容区域的宽度和高度。<br>CSS如何设置标准盒模型<br>box-sizing:conent-box;<br>问题：当增加内边距、边框和外边距时，不会影响内容区域的尺寸，但是会增加元素框的总尺寸。<br>解决方法：box-sizing:border-box;</p><h3 id="IE盒模型"><a href="#IE盒模型" class="headerlink" title="IE盒模型"></a>IE盒模型</h3><p><img src="https://img-blog.csdnimg.cn/20200531130514396.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"><br>IE盒子模型中，width 和 height 指的是内容区域+border+padding的宽度和高度。<br>CSS如何设置IE盒子模型<br>box-sizing:border-box;</p><h2 id="CSS-页面常用布局"><a href="#CSS-页面常用布局" class="headerlink" title="CSS 页面常用布局"></a>CSS 页面常用布局</h2><p>中间自适应，两边定宽</p><h3 id="圣杯布局"><a href="#圣杯布局" class="headerlink" title="圣杯布局"></a>圣杯布局</h3><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 解决浮动引起的高度塌陷 */</span><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;       <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;       <span class="hljs-attribute">clear</span>: both;       <span class="hljs-attribute">display</span>: block;   &#125;<span class="hljs-selector-class">.container</span>&#123;       <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.center</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">float</span>: left;   &#125;   <span class="hljs-comment">/* 中间部分宽度自适应 */</span>   <span class="hljs-selector-class">.center</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;   &#125;   <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;       <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;   &#125;   <span class="hljs-comment">/* 左边栏使用margin-left移动中间部分的宽度，再使用相对定位向左移动自身的宽度 */</span>   <span class="hljs-selector-class">.left</span>&#123;       <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;       <span class="hljs-attribute">position</span>: relative;       <span class="hljs-attribute">left</span>:-<span class="hljs-number">200px</span>;   &#125;   <span class="hljs-selector-class">.right</span>&#123;       <span class="hljs-attribute">margin-right</span>: -<span class="hljs-number">200px</span>;       <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;   &#125;</code></pre></div><h3 id="双飞翼布局"><a href="#双飞翼布局" class="headerlink" title="双飞翼布局"></a>双飞翼布局</h3><ul><li>left、container、right都设置左浮动 </li><li>设置container宽度为100%</li><li>设置负边距，left设置margin-left为100%，right设置margin-left为自身宽度</li><li>设置center的margin值为left和right宽度，为左右两个侧栏留出空间</li></ul><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">" clearfix"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">::after</span>&#123;        <span class="hljs-attribute">content</span>: <span class="hljs-string">""</span>;        <span class="hljs-attribute">clear</span>: both;        <span class="hljs-attribute">display</span>: block;    &#125;    <span class="hljs-selector-class">.container</span>,<span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">float</span>: left;    &#125;    <span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;    &#125;        <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">margin</span>: <span class="hljs-number">0</span> <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;         <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#34495e</span>;     &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">200px</span>;    &#125;    <span class="hljs-selector-class">.left</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#2ecc71</span>;    &#125;    <span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#3498db</span>;    &#125;</code></pre></div><h2 id="Flex弹性布局"><a href="#Flex弹性布局" class="headerlink" title="Flex弹性布局"></a>Flex弹性布局</h2><p>缺点：仅支持 IE9 以上浏览器</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: flex;        <span class="hljs-attribute">min-height</span>: <span class="hljs-number">400px</span>;    &#125;    <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;        <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;        /* flex: 0 0 200px; */ 与使用宽度能够实现同样的效果    &#125;    <span class="hljs-selector-class">.center</span>&#123;        <span class="hljs-attribute">flex</span>:<span class="hljs-number">1</span>;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#000</span>;    &#125;</code></pre></div><h2 id="Grid-布局-网格布局"><a href="#Grid-布局-网格布局" class="headerlink" title="Grid 布局(网格布局)"></a>Grid 布局(网格布局)</h2><p>grid-template-columns属性定义每一列的列宽<br>grid-template-rows属性定义每一行的行高</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"container"</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"left"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"center"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"right"</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></code></pre></div><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.container</span>&#123;        <span class="hljs-attribute">display</span>: grid;        <span class="hljs-attribute">grid-template-rows</span>: <span class="hljs-number">400px</span>;        <span class="hljs-attribute">grid-template-columns</span>: <span class="hljs-number">200px</span> auto <span class="hljs-number">200px</span>;<span class="hljs-comment">/* 设置列宽，也可使用百分比 */</span>    &#125;     <span class="hljs-selector-class">.left</span>,<span class="hljs-selector-class">.right</span>&#123;        <span class="hljs-attribute">background-color</span>: <span class="hljs-number">#95a5a6</span>;      &#125;</code></pre></div>]]></content>
    
    
    <categories>
      
      <category>面试CSS篇</category>
      
    </categories>
    
    
    <tags>
      
      <tag>面试 CSS</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue组件化开发——学习笔记二</title>
    <link href="/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/"/>
    <url>/2020/05/31/Vue%E7%BB%84%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E2%80%94%E2%80%94%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%BA%8C/</url>
    
    <content type="html"><![CDATA[<h3 id="组件化基本介绍"><a href="#组件化基本介绍" class="headerlink" title="组件化基本介绍"></a>组件化基本介绍</h3><h4 id="组件化"><a href="#组件化" class="headerlink" title="组件化"></a>组件化</h4><ol><li>将一个完整的页面分成很多个组件。</li><li>每个组件都用于实现页面的一个功能块。</li><li>而每一个组件又可以进行细分。</li></ol><h4 id="Vue组件化思想"><a href="#Vue组件化思想" class="headerlink" title="Vue组件化思想"></a><strong>Vue组件化思想</strong></h4><ul><li>提供了一种抽象，让我们可以开发出一个个独立可复用的小组件来构造我们的应用。</li><li>任何的应用都会被抽象成一颗组件树。<br><img src="https://img-blog.csdnimg.cn/20200530111834826.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></li></ul><p>组件化思想的应用：</p><ul><li>尽可能的将页面拆分成一个个小的、可复用的组件。</li><li>让我们的代码更加方便组织和管理，并且扩展性也更强。</li></ul><h3 id="注册组件"><a href="#注册组件" class="headerlink" title="注册组件"></a><strong>注册组件</strong></h3><h4 id="组件的使用分成三个步骤"><a href="#组件的使用分成三个步骤" class="headerlink" title="组件的使用分成三个步骤"></a>组件的使用分成三个步骤</h4><p><img src="https://img-blog.csdnimg.cn/20200530112014942.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.创建组件构造器</strong></p><p><strong>Vue.extend()：</strong></p><ol><li>调用Vue.extend()创建的是一个组件构造器。 </li><li>通常在创建组件构造器时，传入template代表我们自定义组件的模板。</li><li>该模板就是在使用到组件的地方，显示HTML代码。</li></ol><p><strong>2.注册组件</strong></p><p><strong>Vue.component()：</strong></p><p>调用Vue.component()是将组件构造器注册为一个组件，并且给它起一个组件的标签名称。</p><p>需要传递两个参数：1、注册组件的标签名 2、组件构造器</p><p><strong>3.使用组件</strong></p><p>组件必须挂载在某个Vue实例下，否则它不会生效。</p><h4 id="注册组件语法糖"><a href="#注册组件语法糖" class="headerlink" title="注册组件语法糖"></a>注册组件语法糖</h4><p>主要是省去了调用Vue.extend()的步骤，而是可以直接使用一个对象来代替。</p><h4 id="模板的分离写法"><a href="#模板的分离写法" class="headerlink" title="模板的分离写法"></a>模板的分离写法</h4><p>Vue提供了两种方案来定义HTML模块内容：</p><ul><li>使用<code>&lt;script&gt;</code>标签</li><li>使用<code>&lt;template&gt;</code>标签</li></ul><h3 id="全局组件和局部组件"><a href="#全局组件和局部组件" class="headerlink" title="全局组件和局部组件"></a><strong>全局组件和局部组件</strong></h3><p><strong>全局组件</strong></p><p>调用Vue.component()注册组件时，组件的注册是全局的,意味着该组件可以在任意Vue示例下使用</p><p><strong>局部组件</strong></p><p>如果我们注册的组件是挂载在某个实例中, 那么就是一个局部组件</p><h3 id="父组件和子组件"><a href="#父组件和子组件" class="headerlink" title="父组件和子组件"></a><strong>父组件和子组件</strong></h3><h4 id="父子组件的通信"><a href="#父子组件的通信" class="headerlink" title="父子组件的通信"></a>父子组件的通信</h4><p><img src="https://img-blog.csdnimg.cn/20200530112106840.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>1.父子组件间传递数据</strong></p><ul><li><strong>父组件向子组件传递（通过props）</strong></li></ul><p>在组件中，使用选项props来声明需要从父级接收到的数据</p><p>props的值有两种方式：</p><p>方式一：字符串数组，数组中的字符串就是传递时的名称。</p><p>方式二：对象，对象可以设置传递时的类型，也可以设置默认值等</p><p><strong>props数据验证</strong></p><p>当需要对props进行类型等验证时，就需要使用对象写法</p><p>验证都支持哪些数据类型呢？</p><ul><li>String</li><li>Number</li><li>Boolean</li><li>Array</li><li>Object</li><li>Date</li><li>Function</li><li>Symbol</li><li>自定义函数</li></ul><div class="hljs"><pre><code class="hljs js">Vue.component(<span class="hljs-string">'my-component'</span>, &#123;  props: &#123;<span class="hljs-comment">// 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证)</span>propA: <span class="hljs-built_in">Number</span>,<span class="hljs-comment">// 多个可能的类型</span>propB: [<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Number</span>],<span class="hljs-comment">// 必填的字符串</span>propC: &#123;  type: <span class="hljs-built_in">String</span>,  required: <span class="hljs-literal">true</span>&#125;,<span class="hljs-comment">// 带有默认值的数字</span>propD: &#123;  type: <span class="hljs-built_in">Number</span>,  <span class="hljs-keyword">default</span>: <span class="hljs-number">100</span>&#125;,<span class="hljs-comment">// 带有默认值的对象</span>propE: &#123;  type: <span class="hljs-built_in">Object</span>,  <span class="hljs-comment">// 对象或数组默认值必须从一个工厂函数获取</span>  <span class="hljs-keyword">default</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) </span>&#123;    <span class="hljs-keyword">return</span> &#123; <span class="hljs-attr">message</span>: <span class="hljs-string">'hello'</span> &#125;  &#125;&#125;,<span class="hljs-comment">// 自定义验证函数</span>propF: &#123;  validator: <span class="hljs-function"><span class="hljs-keyword">function</span> (<span class="hljs-params">value</span>) </span>&#123;    <span class="hljs-comment">// 这个值必须匹配下列字符串中的一个</span>    <span class="hljs-keyword">return</span> [<span class="hljs-string">'success'</span>, <span class="hljs-string">'warning'</span>, <span class="hljs-string">'danger'</span>].indexOf(value) !== <span class="hljs-number">-1</span>  &#125;&#125;&#125;&#125;)</code></pre></div><p>注意这些 prop 会在一个组件实例创建之前进行验证，所以实例的 property (如 data、computed 等) 在 default 或 validator 函数中是不可用的。</p><ul><li><strong>子组件向父组件传递（自定义事件）</strong></li></ul><p>​    自定义事件的流程：</p><ol><li>在<strong>子组件</strong>中，通过<strong>$emit()</strong>来触发事件。</li><li>在<strong>父组件</strong>中，通过<strong>v-on</strong>来监听子组件事件。</li></ol><p><strong>2.父子组件的访问方式</strong></p><ul><li><p><strong>父组件访问子组件（使用$children或$refs）</strong></p><p>$children的访问</p><p>this.$children是一个数组类型，它包含所有子组件对象。</p><p>$children的<strong>缺陷</strong>：</p><ol><li>通过<strong>$children</strong>访问子组件时，是一个<strong>数组类型</strong>，<strong>访问其中的子组件</strong>必须通过<strong>索引值</strong>。</li><li>但是当子组件过多，我们需要拿到其中一个时，往往不能确定它的索引值，甚至还可能会发生变化。</li><li>有时候，我们想明确获取其中一个<strong>特定的组件</strong>，这个时候就可以使用<strong>$refs</strong></li></ol><p><strong>$refs的使用</strong>：</p><ul><li>$refs和<strong>ref指令</strong>通常是一起使用的。</li><li>首先，我们通过ref给某一个子组件绑定一个特定的ID。</li><li>其次，通过<strong>this.$refs.ID</strong>就可以访问到该组件了。</li></ul></li><li><p><strong>子组件访问父组件（使用$parent）</strong></p><p>真实开发中尽量不要使用</p></li></ul><h3 id="组件数据存放"><a href="#组件数据存放" class="headerlink" title="组件数据存放"></a>组件数据存放</h3><p><strong>组件中不能直接访问Vue实例中的data数据</strong></p><p>组件自己的数据存放在哪里呢?</p><ul><li>组件对象也有一个data属性(也可以有methods等属性)</li><li>只是这个data属性必须是一个<strong>函数</strong></li><li>而且这个函数需要<strong>返回</strong>一个<strong>对象</strong>，对象内部保存着数据</li></ul><p>为什么data在组件中必须是一个函数呢?</p><p>首先，如果不是一个函数，Vue直接就会报错。</p><p>其次，原因是在于Vue让每个组件对象都返回一个新的对象，因为如果是同一个对象的，组件在多次使用后会相互影响。</p><h3 id="插槽slot"><a href="#插槽slot" class="headerlink" title="插槽slot"></a>插槽slot</h3><h4 id="编译作用域"><a href="#编译作用域" class="headerlink" title="编译作用域"></a><strong>编译作用域</strong></h4><p>官方给出了一条准则：父组件模板的所有东西都会在父级作用域内编译；子组件模板的所有东西都会在子级作用域内编译。</p><h4 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a><strong>基本介绍</strong></h4><p>组件的插槽：</p><ul><li>组件的插槽也是为了让我们封装的组件更加具有扩展性。</li><li>让使用者可以决定组件内部到底展示什么内容。</li></ul><h4 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a><strong>基本使用</strong></h4><p>如何使用slot？</p><p>在子组件中，使用特殊的元素<code>&lt;slot&gt;</code>就可以为子组件开启一个插槽。</p><p>该插槽插入什么内容取决于父组件如何使用</p><h4 id="slot分类"><a href="#slot分类" class="headerlink" title="slot分类"></a><strong>slot分类</strong></h4><p><strong>1.具名插槽slot</strong></p><p>如何使用具名插槽呢？</p><p>非常简单，只要给slot元素一个name属性即可</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">name</span>=<span class="hljs-string">'myslot'</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span></code></pre></div><p><strong>2.作用域插槽</strong></p><p><strong>父组件替换插槽的标签，但是内容由子组件来提供</strong></p><p>可以将 user 作为 <code>&lt;slot&gt;</code> 元素的一个 attribute 绑定上去，绑定在 <code>&lt;slot&gt;</code>元素上的 attribute 被称为插槽 prop。</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">slot</span> <span class="hljs-attr">v-bind:user</span>=<span class="hljs-string">"user"</span>&gt;</span>  &#123;&#123; user.lastName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">slot</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></code></pre></div><p>现在在父级作用域中，我们可以使用带值的 v-slot 来定义我们提供的插槽 prop 的名字</p><div class="hljs"><pre><code class="hljs html"><span class="hljs-tag">&lt;<span class="hljs-name">current-user</span>&gt;</span>  <span class="hljs-tag">&lt;<span class="hljs-name">template</span> <span class="hljs-attr">v-slot:default</span>=<span class="hljs-string">"slotProps"</span>&gt;</span>    &#123;&#123; slotProps.user.firstName &#125;&#125;  <span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">current-user</span>&gt;</span></code></pre></div><p>在这个例子中，我们选择将包含所有插槽 prop 的对象命名为 slotProps，但你也可以使用任意你喜欢的名字</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Flex布局</title>
    <link href="/2020/05/31/Flex%E5%B8%83%E5%B1%80/"/>
    <url>/2020/05/31/Flex%E5%B8%83%E5%B1%80/</url>
    
    <content type="html"><![CDATA[<p>该文章是根据阮一峰老师的<a href="http://www.ruanyifeng.com/blog/2015/07/flex-grammar.html" target="_blank" rel="noopener">Flex 布局教程：语法篇</a>和MDN——<a href="https://developer.mozilla.org/zh-CN/docs/Web/CSS/CSS_Flexible_Box_Layout/Basic_Concepts_of_Flexbox" target="_blank" rel="noopener">flex布局的基本概念</a>整理得出的。</p><h2 id="基本介绍"><a href="#基本介绍" class="headerlink" title="基本介绍"></a>基本介绍</h2><p>Flex 是 Flexible Box 的缩写，意为”弹性布局”<br>任何一个容器都可以指定为 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>行内项目也可以使用 Flex 布局</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: inline-flex;&#125;</code></pre></div><p>Webkit 内核的浏览器，必须加上-webkit前缀</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">display</span>: -webkit-flex; <span class="hljs-comment">/* Safari */</span>  <span class="hljs-attribute">display</span>: flex;&#125;</code></pre></div><p>注意，设为 Flex 布局以后，容器中的直系子元素就会变为 flex 元素,并且子元素的<strong>float</strong>、<strong>clear</strong>和<strong>vertical-align</strong>属性将失效。</p><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><p>采用 Flex 布局的项目，称为 Flex 容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为 Flex 项目（flex item），简称”项目”。<br><img src="https://img-blog.csdnimg.cn/20200531101024720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><h3 id="容器的属性"><a href="#容器的属性" class="headerlink" title="容器的属性"></a>容器的属性</h3><ul><li><strong>flex-direction</strong>         </li></ul><p>flex-direction属性决定主轴的方向（即flex 项目的排列方向）</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-direction</span>: row | row-reverse | column | column-reverse;&#125;</code></pre></div><p>row（默认值）：主轴为水平方向，起点在左端。<br>row-reverse：主轴为水平方向，起点在右端。<br>column：主轴为垂直方向，起点在上沿。<br>column-reverse：主轴为垂直方向，起点在下沿。</p><ul><li><strong>flex-wrap</strong>     </li></ul><p>默认情况下，项目都排在一条线（又称”轴线”）上。flex-wrap属性定义，如果一条轴线排不下，如何换行。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span>&#123;  <span class="hljs-attribute">flex-wrap</span>: nowrap | wrap | wrap-reverse;&#125;</code></pre></div><p>1）nowrap（默认）：不换行。<br>2）wrap：换行，第一行在上方。<br>3）wrap-reverse：换行，第一行在下方。</p><ul><li><p><strong>flex-flow</strong> </p><p>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">flex-flow</span>: &lt;flex-direction&gt; || &lt;flex-wrap&gt;;&#125;</code></pre></div><ul><li><strong>justify-content</strong><br>justify-content属性定义了项目在主轴上（水平方向）的对齐方式。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">justify-content</span>: flex-start | flex-end | center | space-between | space-around;&#125;</code></pre></div><p>flex-start（默认值）：左对齐<br>flex-end：右对齐<br>center： 居中<br>space-between：两端对齐，项目之间的间隔相等。<br>space-around：每个项目两侧的间隔相等。项目之间的间隔比项目与边框的间隔大一倍。</p><ul><li><strong>align-items</strong><br>align-items属性定义项目在交叉轴上（垂直方向）如何对齐</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>flex-start：交叉轴的起点对齐。<br>flex-end：交叉轴的终点对齐。<br>center：交叉轴的中点对齐。<br>stretch（默认值）：如果项目未设置高度或设为auto，将占满整个容器的高度。</p><ul><li>align-content<br>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.box</span> &#123;  <span class="hljs-attribute">align-content</span>: flex-start | flex-end | center | space-between | space-around | stretch;&#125;</code></pre></div><p>flex-start：与交叉轴的起点对齐。<br>flex-end：与交叉轴的终点对齐。<br>center：与交叉轴的中点对齐。<br>space-between：与交叉轴两端对齐，轴线之间的间隔平均分布。<br>space-around：每根轴线两侧的间隔都相等。所以，轴线之间的间隔比轴线与边框的间隔大一倍。<br>stretch（默认值）：轴线占满整个交叉轴。</p><h3 id="项目的属性"><a href="#项目的属性" class="headerlink" title="项目的属性"></a>项目的属性</h3><ul><li>order属性<br>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">order</span>: &lt;integer&gt;;&#125;</code></pre></div><ul><li><strong>flex-grow属性</strong><br>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-grow</span>: &lt;number&gt;; <span class="hljs-comment">/* default 0 */</span>&#125;</code></pre></div><p>如果所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）。如果一个项目的flex-grow属性为2，其他项目都为1，则前者占据的剩余空间将比其他项多一倍。</p><ul><li><strong>flex-shrink属性</strong><br>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。<br>flex-shrink 属性只能是一个 <code>&lt;number&gt;</code>。负值对该属性无效。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-shrink</span>: &lt;number&gt;; <span class="hljs-comment">/* default 1 */</span>&#125;</code></pre></div><p>如果所有项目的flex-shrink属性都为1，当空间不足时，都将等比例缩小。如果一个项目的flex-shrink属性为0，其他项目都为1，则空间不足时，前者不缩小。</p><ul><li><strong>flex-basis属性</strong><br>flex-basis属性定义了项目的空间大小。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p>取值<br>&lt;’width’&gt;<br>width 值可以是<code>&lt;length&gt;</code>; 该值也可以是一个相对于其父弹性盒容器主轴尺寸的百分数 。负值是不被允许的。默认为 auto。<br>content<br>基于 flex 项目的内容自动调整大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-comment">/* 指定&lt;'width'&gt; */</span><span class="hljs-selector-tag">flex-basis</span>: 10<span class="hljs-selector-tag">em</span>;<span class="hljs-selector-tag">flex-basis</span>: 3<span class="hljs-selector-tag">px</span>;<span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">auto</span>;<span class="hljs-comment">/* 在flex item内容上的自动尺寸 */</span><span class="hljs-selector-tag">flex-basis</span>: <span class="hljs-selector-tag">content</span>;</code></pre></div><p>如果没有给项目设定尺寸，flex-basis 的值采用项目内容的尺寸。这就解释了：我们给只要给Flex项目的容器声明 display: flex ，所有子元素就会排成一行，且自动分配小大以充分展示项目的内容。<br>Note: 当一个项目同时被设置了 flex-basis (除值为 auto 外) 和 width (或者在 flex-direction: column 情况下设置了height) , flex-basis 具有更高的优先级.</p><ul><li><p><strong>flex属性</strong></p><p>flex属性是flex-grow, flex-shrink 和 flex-basis的简写，默认值为0 1 auto。后两个属性可选。<br>建议优先使用这个属性，而不是单独写三个分离的属性，因为浏览器会推算相关值。</p></li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex</span>: none | [ &lt;<span class="hljs-string">'flex-grow'</span>&gt; &lt;<span class="hljs-string">'flex-shrink'</span>&gt;? || &lt;<span class="hljs-string">'flex-basis'</span>&gt; ]&#125;</code></pre></div><p>下面是几种预定义的值：<br><strong>flex: initial</strong><br>把flex项目重置为Flexbox的初始值，它相当于 <strong>flex: 0 1 auto</strong>。</p><p>解析：flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</p><p>​            flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​            flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="hljs-comment">/* default auto */</span>&#125;</code></pre></div><p><strong>flex: auto</strong><br>flex: auto 等同于 <strong>flex: 1 1 auto</strong>；这种情况下，flex项目在需要的时候既可以拉伸也可以收缩</p><p>解析：所有项目的flex-grow属性都为1，则它们将等分剩余空间（如果有的话）</p><p>​            flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小</p><p>​            flex-basis属性定义了项目的空间大小。它的默认值为auto，即项目的本来大小。</p><p><strong>flex: none</strong><br>flex: none 可以把flex项目设置为不可伸缩。它和设置为 <strong>flex: 0 0 auto</strong> 是一样的。项目既不能拉伸或者收缩，但是项目会按具有 flex-basis: auto 属性的flexbox进行布局。</p><ul><li>align-self属性<br>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li></ul><div class="hljs"><pre><code class="hljs css"><span class="hljs-selector-class">.item</span> &#123;  <span class="hljs-attribute">align-self</span>: auto | flex-start | flex-end | center | baseline | stretch;&#125;</code></pre></div><p>该属性可能取6个值，除了auto，其他都与align-items属性完全一致。</p>]]></content>
    
    
    <categories>
      
      <category>flex</category>
      
    </categories>
    
    
    <tags>
      
      <tag>flex布局</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vue.js学习笔记一</title>
    <link href="/2020/05/28/Vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/"/>
    <url>/2020/05/28/Vue-js%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%E4%B8%80/</url>
    
    <content type="html"><![CDATA[<h3 id="Vue-js介绍"><a href="#Vue-js介绍" class="headerlink" title="Vue.js介绍"></a>Vue.js介绍</h3><p><strong>1.渐进式JavaScript框架</strong></p><p>框架和库的区别：</p><ul><li><p>框架：是一套完整的解决方案；对项目的侵入性较大，项目如果需要更换框架，则需要重新架构整个项目。</p></li><li><p>库（插件）：提供某一个小功能，对项目的侵入性较小，如果某个库无法完成某些需求，可以很容易切换到其它库实现需求。</p></li></ul><p><strong>2.特点和功能</strong></p><ul><li>解耦视图和数据</li><li>可复用的组件</li><li>前端路由技术</li><li>状态管理</li><li>虚拟DOM</li></ul><h3 id="Vue中的MVVM"><a href="#Vue中的MVVM" class="headerlink" title="Vue中的MVVM"></a>Vue中的MVVM</h3><p><img src="https://img-blog.csdnimg.cn/20200529180100715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p> <strong>View层（视图层）</strong></p><ul><li>前端开发中，通常就是DOM层。</li><li>主要的作用是给用户展示各种信息。</li></ul><p><strong>Model层（数据层）</strong></p><ul><li>数据可能是固定的死数据，更多的是来自服务器，从网络上请求下来的数据。</li></ul><p><strong>VueModel层（视图模型层）</strong></p><ul><li>视图模型层是View和Model沟通的桥梁。</li><li>一方面它实现了Data Binding，也就是数据绑定，将Model的改变实时的反应到View中</li><li>另一方面它实现了DOM Listener，也就是DOM监听，当DOM发生一些事件(点击、滚动、touch等)时，可以监听到，并在需要的情况下改变对应的Data。</li></ul><p><strong>后端（Node）中的 MVC 与 前端中的 MVVM 之间的区别</strong></p><ol><li><p>MVC 是后端的分层开发概念；</p></li><li><p>MVVM是前端视图层的概念，主要关注于视图层分离，也就是说：MVVM把前端的视图层，分为了 三部分 Model, View , VM（ViewModel）</p><p><img src="https://img-blog.csdnimg.cn/20200529180156561.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ol><h3 id="Vue的生命周期"><a href="#Vue的生命周期" class="headerlink" title="Vue的生命周期"></a>Vue的生命周期</h3><p>1.生命周期：从Vue实例创建、运行、到销毁期间，总是伴随着各种各样的事件，这些事件统称为生命周期</p><p>2.主要的生命周期函数分类：</p><ul><li><p>创建期间的生命周期函数：</p><ul><li><p>beforeCreate：实例对象初始化之后，此时，还没有初始化好 data 和 methods 属性</p></li><li><p>created：实例创建完成后，data和methods都已经被初始化好了</p><p>注：如果要调用methods中的方法或者操作data中的数据，最早只能在created中操作</p></li><li><p>beforeMount：此函数执行的时候，已经完成了模板的编译，但是还没有挂载到页面中，页面并没有内容</p></li><li><p>mounted：Vue实例已经初始化完毕，编译好的HTML挂载到页面，组件脱离创建阶段，进入运行阶段</p><p>注：1.如果要通过插件操作页面的DOM节点，最早要在mounted中进行（一般会做一些ajax请求获取数据，进行数据初始化）</p><p>2.mounted在整个实例中只执行一次</p></li></ul></li><li><p>运行期间的生命周期函数：</p><ul><li>beforeUpdate：状态更新之前执行此函数， 此时data中的状态值是最新的，但是界面上显示的数据还是旧的，因为此时还没有开始重新渲染DOM节点</li><li>updated：实例更新完毕之后调用此函数，此时data 中的状态值和界面上显示的数据，都已经完成了更新，界面已经被重新渲染好了</li></ul></li><li><p>销毁期间的生命周期函数：</p><ul><li><p>beforeDestroy：实例销毁之前执行的钩子，Vue实例已经从运行阶段进入销毁阶段，实例仍然完全可用</p></li><li><p>destroyed：Vue实例销毁后调用。调用后，Vue实例指示的所有东西都会解除绑定，所有的事件监听器会被移除，所有的子实例也会被销毁</p><p><img src="https://img-blog.csdnimg.cn/20200529180359828.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70#pic_center" srcset="/img/loading.gif" alt="在这里插入图片描述"></p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>vue项目（仿外卖APP）</title>
    <link href="/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/"/>
    <url>/2020/05/27/vue%E9%A1%B9%E7%9B%AE%EF%BC%88%E4%BB%BF%E5%A4%96%E5%8D%96APP%EF%BC%89/</url>
    
    <content type="html"><![CDATA[<p><strong>项目:关于外卖业务的前后台分离Web App</strong></p><ul><li>前台应用技术架构为: vue + vuex + vue-router + webpack + ES6； </li><li>核心功能模块:商家, 商品, 购物车, 评论,用户等多个子模块;</li><li>采用模块化、组件化、工程化的模式开发；</li><li>后台使用 mockjs 模拟后台数据接口和API接口;</li></ul><p><strong>项目展示地址(<a href="http://tq07.gitee.io/vue-food" target="_blank" rel="noopener">点击前往</a>)</strong><br><img src="https://img-blog.csdnimg.cn/20200430112702320.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702289.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702290.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702280.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702228.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"><br><img src="https://img-blog.csdnimg.cn/20200430112702136.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MjY4NDg2MA==,size_16,color_FFFFFF,t_70" srcset="/img/loading.gif" alt="在这里插入图片描述"></p><p><strong>学习心得：</strong></p><p>1) 熟悉一个项目的开发流程<br>2) 学会组件化、模块化、工程化的开发模式<br>3) 掌握使用 vue-cli 脚手架初始化 Vue.js 项目<br>4) 学会模拟 json 后端数据，实现前后端分离开发<br>5) 掌握一些项目优化技巧</p><p><strong>项目中使用的Vue 插件或第三方库</strong></p><ul><li>使用 vue-router 开发单页应用</li><li>使用 axios/vue-resource 与后端进行数据交互</li><li>使用 vuex 管理应用组件状态 </li><li>使用 better-scroll/vue-scroller 实现页面滑动效果</li><li>使用 mint-ui 组件库构建界面 </li><li>使用 vue-lazyload 实现图片惰加载 </li><li>使用 mockjs 模拟后台数据接口</li></ul><p><strong>样式和布局</strong></p><ul><li>使用 stylus 编写模块化的 CSS </li><li>使用 Vue.js 的过渡编写酷炫的交互动画 </li></ul><h3 id="项目中遇到的问题（难点）和项目优化方法"><a href="#项目中遇到的问题（难点）和项目优化方法" class="headerlink" title="项目中遇到的问题（难点）和项目优化方法"></a>项目中遇到的问题（难点）和项目优化方法</h3><p>1.解决点击响应延时 0.3s 问题<br>原因：当用户一次点击屏幕之后，浏览器并不能立刻判断用户是否要进行双击缩放，还是想要进行单击操作。因此，iOS Safari 就等待 300 毫秒，以判断用户是否再次点击了屏幕。<br>解决方法：利用FastClick，其原理是检测到touchend事件后，立刻出发模拟click事件，并且把浏览器300毫秒之后真正出发的事件给阻断掉</p><div class="hljs"><pre><code class="hljs plain">&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;fastclick&#x2F;1.0.6&#x2F;fastclick.js&quot;&gt;&lt;&#x2F;script&gt;    &lt;script&gt;      if(&#39;addEventListener&#39; in document)&#123;        document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;          FastClick.attach(document.body);        &#125;,false)      &#125;      if(!window.Promise) &#123;       document.writeln(&#39;&lt;script src&#x3D;&quot;https:&#x2F;&#x2F;as.alipayobjects.com&#x2F;g&#x2F;component&#x2F;es6-promise&#x2F;3.2.2&#x2F;es6-promise.min.js&quot; &#39;+&#39;&gt;&#39;+&#39;&lt;&#39;+&#39;&#x2F;&#39;+&#39;script&gt;&#39;);       &#125;    &lt;&#x2F;script&gt;</code></pre></div><p>2.后台应用</p><blockquote><p>后台应用负责处理前台应用提交的请求, 并给前台应用返回 json 数据<br>前台应用负责展现数据, 与用户交互, 与后台应用交互<br>API接口  <a href="https://github.com/bailicangdu/node-elm/blob/master/API.md" target="_blank" rel="noopener">githup上面找的API接口</a></p></blockquote><p>3.封装 ajax 请求模块</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; ajax 请求函数模块import axios from &#39;axios&#39;export default function ajax(url&#x3D;&#39;&#39;,data&#x3D;&#123;&#125;,type&#x3D;&#39;GET&#39;)&#123;    return new Promise(function(resolve, reject)&#123;        &#x2F;&#x2F; 执行axios异步请求        let promise           if (type &#x3D;&#x3D;&#x3D; &#39;GET&#39;) &#123;             &#x2F;&#x2F; 准备 url query 参数数据             let dataStr &#x3D; &#39;&#39; &#x2F;&#x2F;数据拼接字符串             Object.keys(data).forEach(key &#x3D;&gt; &#123;                 dataStr +&#x3D; key + &#39;&#x3D;&#39; + data[key] + &#39;&amp;&#39;            &#125;)            if (dataStr !&#x3D;&#x3D; &#39;&#39;) &#123;             dataStr &#x3D; dataStr.substring(0, dataStr.lastIndexOf(&#39;&amp;&#39;))             url &#x3D; url + &#39;?&#39; + dataStr             &#125;            &#x2F;&#x2F; 发送 get 请求             promise &#x3D; axios.get(url)         &#125; else &#123;             &#x2F;&#x2F; 发送 post 请求             promise &#x3D; axios.post(url,data)         &#125;        promise.then(response &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用resolve()            resolve(response)         &#125;).catch(error &#x3D;&gt; &#123;             &#x2F;&#x2F; 成功调用reject()            reject(error)         &#125;)     &#125;)&#125;</code></pre></div><p>4.vuex 应用组件状态<br>vuex 的核心管理对象 <strong>store 对象模块</strong><br>state模块：状态对象<br>mutation type 常量名称模块<br>mutations 模块 ：直接更新state的多个方法的对象<br>actions 模块：通过mutations间接更新state的多个方法的对象</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F;store 对象模块import Vue from &#39;vue&#39;import Vuex from &#39;vuex&#39;import state from &#39;.&#x2F;state&#39;import mutations from &#39;.&#x2F;mutations&#39; import actions from &#39;.&#x2F;actions&#39;import getters from &#39;.&#x2F;getters&#39;Vue.use(Vuex)export default new Vuex.Store(&#123;  state,  mutations,   actions,  getters,&#125;)</code></pre></div><p>5.模拟(mock)数据/接口<br>利用 mockjs 拦截 ajax 请求, 生成随机数据返回<br><a href="http://mockjs.com/" target="_blank" rel="noopener">mockjs</a></p><p> 6.ShopGoods 组件</p><ul><li><p>内部使用了另外 3 个组件<br> a. ShopCart: 购物车组件<br> b. Cart: 购物车操作组件<br> c. Food: 食品详情组件 </p></li><li><p>使用第三方库 better-scroll: UI 滑动</p><p>问题：Cart组件在添加食物的时候，第一次增加时, 没有 count，如果直接添加属性并赋值，新添加的属性没有数据劫持==&gt;数据绑定==&gt;更新了数据但界面不变<br>解决方法：Vue.set(food, ‘count’, 1) 给有数据绑定的对象添加指定属性名和值的属性(有绑定)<br>7.项目优化/扩展<br>（1）缓存路由组件对象</p></li></ul><div class="hljs"><pre><code class="hljs plain">&lt;keep-alive&gt; &lt;router-view &#x2F;&gt; &lt;&#x2F;keep-alive&gt;</code></pre></div><p>好处: 复用路由组件对象, 复用路由组件获取的后台数据<br>（2）路由组件懒加载</p><div class="hljs"><pre><code class="hljs plain">&#x2F;&#x2F; 返回路由组件的函数，只有执行该函数才会加载路由组件，这个函数在请求对应的路由路径时才会执行const Home &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Home.vue&#39;)const Order &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Order.vue&#39;)const Search &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Search.vue&#39;)const Profile &#x3D; () &#x3D;&gt; import(&#39;..&#x2F;views&#x2F;Profile.vue&#39;)</code></pre></div><p>8.打包文件分析与优化</p><p>1) vue 脚手架提供了一个用于可视化分析打包文件的包 webpack-bundle-analyzer 和配置<br>2) 启用打包可视化: npm run build  – –report</p>]]></content>
    
    
    <categories>
      
      <category>Vue</category>
      
    </categories>
    
    
    <tags>
      
      <tag>vue</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用hexo+github搭建个人博客</title>
    <link href="/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <url>/2020/05/27/%E4%BD%BF%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<p>Hexo 是基于 Node.js 开发的一个静态博客生成器，提供本地实时预览及部署功能。</p><h3 id="1-安装node和npm-或者cnpm"><a href="#1-安装node和npm-或者cnpm" class="headerlink" title="1.安装node和npm (或者cnpm)"></a>1.安装node和npm (或者cnpm)</h3><h3 id="2-安装git"><a href="#2-安装git" class="headerlink" title="2.安装git"></a>2.安装git</h3><h3 id="3-安装hexo"><a href="#3-安装hexo" class="headerlink" title="3.安装hexo"></a>3.安装hexo</h3><p>前两步我之前已经安装过 ，就不详细记述了</p><p><strong>3.1 全局安装hexo</strong></p><div class="hljs"><pre><code class="hljs plain">npm install -g hexo-cli</code></pre></div><p><strong>3.2 安装 Hexo 完成后，在指定的目录执行下列命令，Hexo 将会指定的文件夹中新建所需要的文件</strong></p><div class="hljs"><pre><code class="hljs plain">hexo init blog</code></pre></div><p><strong>3.3 在指定文件夹下，启动本地预览服务</strong></p><div class="hljs"><pre><code class="hljs bash"><span class="hljs-built_in">cd</span> blog<span class="hljs-comment"># 启动本地预览服务，默认是 127.0.0.1:4000（简写hexo s）</span>hexo server</code></pre></div><p>也可以参考 Hexo 官方文档：<a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">https://hexo.io/zh-cn/</a> , 里面有具体的使用方式。</p><h3 id="4-注册githup账号并新建仓库"><a href="#4-注册githup账号并新建仓库" class="headerlink" title="4.注册githup账号并新建仓库"></a>4.注册githup账号并新建仓库</h3><p>新建一个名为<code>你的用户名.github.io</code>的仓库（必须是你的用户名，其它名称无效），将来个人博客访问地址就是 <a href="http://test.github.io/" target="_blank" rel="noopener">http://用户名.github.io</a> </p><h3 id="5-自动发布-Hexo-搭建的静态博客"><a href="#5-自动发布-Hexo-搭建的静态博客" class="headerlink" title="5.自动发布 Hexo 搭建的静态博客"></a>5.自动发布 Hexo 搭建的静态博客</h3><p><strong>5.1先修改 <code>_config.yml</code> 配置文件</strong></p><p>下面是一个示例：</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">deploy:</span>  <span class="hljs-attr">type:</span> <span class="hljs-string">git</span>  <span class="hljs-attr">repo:</span> <span class="hljs-string">https://github用户名:密码@github.com/sherlockkid7/sherlockkid7.github.io.git</span></code></pre></div><p>上面的配置选项中，一定要注意在 repo 中按照对应的格式加入 Github 用户名和密码。</p><p><strong>5.2安装自动发布的插件</strong></p><div class="hljs"><pre><code class="hljs bash">npm install hexo-deployer-git --save</code></pre></div><p><strong>5.3使用命令一键进行发布</strong></p><div class="hljs"><pre><code class="hljs bash">hexo generate --deploy<span class="hljs-comment"># 或者</span>hexo deploy --generate</code></pre></div><p>上面两条命令都可以，发布可能有延时，稍微等待即可。</p><h3 id="6-新建文章"><a href="#6-新建文章" class="headerlink" title="6.新建文章"></a>6.新建文章</h3><div class="hljs"><pre><code class="hljs plain">hexo new 文章标题</code></pre></div><h3 id="7-修改默认hexo主题"><a href="#7-修改默认hexo主题" class="headerlink" title="7.修改默认hexo主题"></a>7.修改默认hexo主题</h3><p>在github下载hexo-theme-fluid-1.8.0主题，并解压到themes文件夹中，修改 <code>_config.yml</code> 配置文件(注主题文件可以重命名为fluid)</p><div class="hljs"><pre><code class="hljs yml"><span class="hljs-attr">theme:</span> <span class="hljs-string">fluid</span></code></pre></div>]]></content>
    
    
    <categories>
      
      <category>hexo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>hexo</tag>
      
      <tag>github</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
